<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"s-chance.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.14.1","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文已收录到golang基础学习 | 青训营笔记 - 掘金 (juejin.cn)，主要记录了对golang的初步学习">
<meta property="og:type" content="article">
<meta property="og:title" content="golang基础">
<meta property="og:url" content="https://s-chance.github.io/2023/01/26/golang-day1/index.html">
<meta property="og:site_name" content="Entropy Tree">
<meta property="og:description" content="本文已收录到golang基础学习 | 青训营笔记 - 掘金 (juejin.cn)，主要记录了对golang的初步学习">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-01-25T18:24:18.000Z">
<meta property="article:modified_time" content="2023-01-29T18:08:00.889Z">
<meta property="article:author" content="Entropy">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="青训营">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://s-chance.github.io/2023/01/26/golang-day1/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://s-chance.github.io/2023/01/26/golang-day1/","path":"2023/01/26/golang-day1/","title":"golang基础"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>golang基础 | Entropy Tree</title>
  







<link rel="dns-prefetch" href="https://waline-hexo-nu.vercel.app/">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Entropy Tree" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Entropy Tree</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">the truth of life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-rss"><a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>rss</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E4%BB%80%E4%B9%88%E6%98%AFgo%E8%AF%AD%E8%A8%80"><span class="nav-text"> 1.1 什么是Go语言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E9%AB%98%E6%80%A7%E8%83%BD-%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="nav-text"> 1.高性能、高并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E8%AF%AD%E6%B3%95%E7%AE%80%E5%8D%95-%E5%AD%A6%E4%B9%A0%E6%9B%B2%E7%BA%BF%E5%B9%B3%E7%BC%93"><span class="nav-text"> 2.语法简单、学习曲线平缓</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E4%B8%B0%E5%AF%8C%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-text"> 3.丰富的标准库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E5%AE%8C%E5%96%84%E7%9A%84%E5%B7%A5%E5%85%B7%E9%93%BE"><span class="nav-text"> 4.完善的工具链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-text"> 5.静态链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E5%BF%AB%E9%80%9F%E7%BC%96%E8%AF%91"><span class="nav-text"> 6.快速编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E8%B7%A8%E5%B9%B3%E5%8F%B0"><span class="nav-text"> 7.跨平台</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text"> 8.垃圾回收</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E5%93%AA%E4%BA%9B%E5%85%AC%E5%8F%B8%E5%9C%A8%E4%BD%BF%E7%94%A8go%E8%AF%AD%E8%A8%80"><span class="nav-text"> 1.2 哪些公司在使用Go语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9go%E8%AF%AD%E8%A8%80"><span class="nav-text"> 1.3 为什么选择Go语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="nav-text"> 2.1 开发环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85golang"><span class="nav-text"> 安装Golang</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="nav-text"> 配置集成开发环境</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-text"> 2.2 基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1hello-world"><span class="nav-text"> 1.Hello World</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E5%8F%98%E9%87%8F"><span class="nav-text"> 2.变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-text"> 变量声明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3if-else"><span class="nav-text"> 3.if else</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E5%BE%AA%E7%8E%AF"><span class="nav-text"> 4.循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5switch"><span class="nav-text"> 5.switch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E6%95%B0%E7%BB%84"><span class="nav-text"> 6.数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E5%88%87%E7%89%87"><span class="nav-text"> 7.切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8map"><span class="nav-text"> 8.map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9range"><span class="nav-text"> 9.range</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E5%87%BD%E6%95%B0"><span class="nav-text"> 10.函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11%E6%8C%87%E9%92%88"><span class="nav-text"> 11.指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text"> 12.结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95"><span class="nav-text"> 13.结构体方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-text"> 14.错误处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="nav-text"> 15.字符串操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-text"> 16.字符串格式化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17json%E5%A4%84%E7%90%86"><span class="nav-text"> 17.JSON处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86"><span class="nav-text"> 18.时间处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19%E6%95%B0%E5%AD%97%E8%A7%A3%E6%9E%90"><span class="nav-text"> 19.数字解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF"><span class="nav-text"> 20.进程信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-%E7%8C%9C%E8%B0%9C%E6%B8%B8%E6%88%8F"><span class="nav-text"> 3.1 猜谜游戏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-text"> 1.生成随机数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E8%AF%BB%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5"><span class="nav-text"> 2.读取用户输入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E9%80%BB%E8%BE%91"><span class="nav-text"> 3.实现判断逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF"><span class="nav-text"> 4.实现游戏循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-%E5%9C%A8%E7%BA%BF%E8%AF%8D%E5%85%B8"><span class="nav-text"> 3.2 在线词典</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E6%8A%93%E5%8C%85"><span class="nav-text"> 1.抓包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="nav-text"> 2.代码生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E7%94%9F%E6%88%90request-body"><span class="nav-text"> 3.生成request body</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E8%A7%A3%E6%9E%90response-body"><span class="nav-text"> 4.解析response body</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C"><span class="nav-text"> 5.打印结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E5%AE%8C%E5%96%84%E4%BB%A3%E7%A0%81"><span class="nav-text"> 6.完善代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-socks5%E4%BB%A3%E7%90%86"><span class="nav-text"> 3.3 SOCKS5代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-text"> 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1tcp-echo-server"><span class="nav-text"> 1.TCP echo server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2auth"><span class="nav-text"> 2.auth</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E8%AF%B7%E6%B1%82%E9%98%B6%E6%AE%B5"><span class="nav-text"> 3.请求阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4relay%E9%98%B6%E6%AE%B5"><span class="nav-text"> 4.relay阶段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text"> 参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Entropy"
      src="/./images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Entropy</p>
  <div class="site-description" itemprop="description">一名普通开发者的第一个博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/s-chance" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;s-chance" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/entropy_tree" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;entropy_tree" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/19329372/entropy" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;19329372&#x2F;entropy" rel="noopener me" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://www.entropy-tree.top/" title="https:&#x2F;&#x2F;www.entropy-tree.top" rel="noopener" target="_blank">镜像站</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://s-chance.github.io/2023/01/26/golang-day1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/./images/avatar.jpg">
      <meta itemprop="name" content="Entropy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Entropy Tree">
      <meta itemprop="description" content="一名普通开发者的第一个博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="golang基础 | Entropy Tree">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          golang基础
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-26 02:24:18" itemprop="dateCreated datePublished" datetime="2023-01-26T02:24:18+08:00">2023-01-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-30 02:08:00" itemprop="dateModified" datetime="2023-01-30T02:08:00+08:00">2023-01-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/01/26/golang-day1/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/01/26/golang-day1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>本文已收录到<a target="_blank" rel="noopener" href="https://juejin.cn/post/7192662401240531004">golang基础学习 | 青训营笔记 - 掘金 (juejin.cn)</a>，主要记录了对golang的初步学习<span id="more"></span></p>
<h2 id="11-什么是go语言"><a class="markdownIt-Anchor" href="#11-什么是go语言"></a> 1.1 什么是Go语言</h2>
<h3 id="1高性能-高并发"><a class="markdownIt-Anchor" href="#1高性能-高并发"></a> 1.高性能、高并发</h3>
<p>拥有和C++、Java媲美的性能，拥有对高并发的支持，不需要额外的第三方库，只需要使用标准库或者基于标准库的第三方库就能进行高并发开发</p>
<h3 id="2语法简单-学习曲线平缓"><a class="markdownIt-Anchor" href="#2语法简单-学习曲线平缓"></a> 2.语法简单、学习曲线平缓</h3>
<p>语法风格类似C语言，且在C语言的基础上进行了大幅度简化，例如去掉了不必要的表达式括号，循环只有for循环一种方式就能实现各种数值、键值遍历</p>
<p>一个基于Go的简单的Http服务器demo</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(http.Dir(<span class="string">&quot;.&quot;</span>)))</span><br><span class="line">    http.ListenAndServer(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3丰富的标准库"><a class="markdownIt-Anchor" href="#3丰富的标准库"></a> 3.丰富的标准库</h3>
<p>拥有及其丰富、功能完善、质量可靠的标准库。在很多情况下，不需要借助第三方库就可以完成大部分基础功能的开发，大大降低了学习和使用成本。最关键的是，标准库具有很高的稳定性和兼容性保障，还能持续享受语言迭代所带来的性能优化。这是第三方库所不具备的</p>
<h3 id="4完善的工具链"><a class="markdownIt-Anchor" href="#4完善的工具链"></a> 4.完善的工具链</h3>
<p>拥有丰富的工具链，编译、代码格式化、错误检查、帮助文档、包管理以及代码补全提示。Go还内置了完整的单元测试框架，支持单元测试、性能测试、代码覆盖率、数据键增检测、性能优化，保障代码能够正确稳定运行</p>
<h3 id="5静态链接"><a class="markdownIt-Anchor" href="#5静态链接"></a> 5.静态链接</h3>
<p>在Go语言中所有的编译结构默认为静态链接，只需要编译后的唯一一个可执行文件不需要附加任何其它东西，即可部署运行。在线上的容器环境中运行，镜像体积可以控制得非常小，部署非常方便快捷。不同于C++，需要一堆动态链接库（linux下表现为.so文件，win下是.dll文件以及由.dll生成的.lib文件）才可以正确运行，文本不正确的话就会崩溃。Java则需要附加一个庞大的JRE才能运行</p>
<h3 id="6快速编译"><a class="markdownIt-Anchor" href="#6快速编译"></a> 6.快速编译</h3>
<p>Go语言拥有静态语言中几乎最快的编译速度，增量编译完成。这个速度对C++开发来说不可想象</p>
<h3 id="7跨平台"><a class="markdownIt-Anchor" href="#7跨平台"></a> 7.跨平台</h3>
<p>Go语言能在常见的linux、windows、macos，也能够开发android、ios软件，还能在一些硬件设备上运行，例如路由器、树莓派。Go还拥有很方便的交叉编译特性，能够轻松在笔记本上编译出二进制文件拷贝到路由器中运行，而无需配置交叉编译环境</p>
<h3 id="8垃圾回收"><a class="markdownIt-Anchor" href="#8垃圾回收"></a> 8.垃圾回收</h3>
<p>Go语言自带垃圾回收机制，和Java类似，在开发的时候无需考虑内存的分配和释放，可以专注于业务逻辑</p>
<h2 id="12-哪些公司在使用go语言"><a class="markdownIt-Anchor" href="#12-哪些公司在使用go语言"></a> 1.2 哪些公司在使用Go语言</h2>
<p>ByteDance字节跳动、Google谷歌、Tencent腾讯、facebook脸书、bilibili哔哩哔哩等</p>
<p>在云计算、微服务、大数据、区块链、物联网等领域广泛发展，尤其在云计算、微服务领域产出了大量的云原生组件</p>
<h2 id="13-为什么选择go语言"><a class="markdownIt-Anchor" href="#13-为什么选择go语言"></a> 1.3 为什么选择Go语言</h2>
<ol>
<li>随着业务体量的不断增长，Python对于Web业务存在性能瓶颈</li>
<li>C++的特性使其不太适合在线Web业务</li>
<li>Go的学习难度低于Java</li>
<li>Go的性能比较好</li>
<li>Go的部署简单，学习成本低（没有Python的依赖库版本问题）</li>
<li>基于Go研发的内部RPC框架和HTTP框架，推动了业务重构</li>
</ol>
<h2 id="21-开发环境"><a class="markdownIt-Anchor" href="#21-开发环境"></a> 2.1 开发环境</h2>
<h3 id="安装golang"><a class="markdownIt-Anchor" href="#安装golang"></a> 安装Golang</h3>
<p><a target="_blank" rel="noopener" href="https://go.dev/">Golang官网</a></p>
<p><a target="_blank" rel="noopener" href="https://studygolang.com/dl">Golang镜像</a></p>
<p><a target="_blank" rel="noopener" href="https://goproxy.cn/">Golang第三方包代理加速下载</a></p>
<h3 id="配置集成开发环境"><a class="markdownIt-Anchor" href="#配置集成开发环境"></a> 配置集成开发环境</h3>
<p>以下三种方案选其一即可</p>
<ol>
<li>
<p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/">Visual Studio Code</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.jetbrains.com.cn/go/promo">Goland</a></p>
<p>关于Goland控制台输出#gosetup的多余信息，影响观察。快捷键Ctrl+Alt+shift+/，打开Registry，取消勾选go.run.processes.with.pty。之后#gosetup的信息会被折叠，方便直接观察程序输出结果</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.gitpod.io/">云开发环境Gitpod</a></p>
</li>
</ol>
<h2 id="22-基础语法"><a class="markdownIt-Anchor" href="#22-基础语法"></a> 2.2 基础语法</h2>
<h3 id="1hello-world"><a class="markdownIt-Anchor" href="#1hello-world"></a> 1.Hello World</h3>
<p>main.go文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>package main代表这个文件属于main包，main包是程序的入口包</p>
</li>
<li>
<p>fmt包是标准库里的包，主要用于输入输出字符串，格式化字符串</p>
</li>
<li>
<p>func main就是go语言main函数的声明，需要注意的是 <strong>花括号{</strong> 必须和func main写在同一行，否则会报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">.\test.go:6:1: syntax error: unexpected semicolon or newline before &#123;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在main函数里用fmt.Println调用了fmt包中的Println函数，需要注意的是import的包必须要在程序中使用到，不能只是import这个包而不去使用，会报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">.\test.go:3:8: imported and not used: <span class="string">&quot;fmt&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>编译运行命令（在文件的同级目录下run或者build后执行）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line">go build main.go</span><br><span class="line">./main</span><br></pre></td></tr></table></figure>
<ul>
<li>go run 直接运行go文件</li>
<li>go build会生成一个exe文件，运行exe文件得到结果</li>
</ul>
<h3 id="2变量"><a class="markdownIt-Anchor" href="#2变量"></a> 2.变量</h3>
<p>go语言是一门强类型语言，每个变量都有各自的变量类型。</p>
<p>常见的变量类型：字符串、整型、浮点型、布尔型等。</p>
<p>go语言的字符串是内置类型，可以直接通过+号拼接，也能够直接使用==去比较两个字符串（不同于Java需要使用equals方法去比较）。</p>
<p>go语言大部分运算符的使用和优先级和C/C++类似。</p>
<h4 id="变量声明"><a class="markdownIt-Anchor" href="#变量声明"></a> 变量声明</h4>
<p>在go语言中变量的声明方式有两种</p>
<p>一种是通过var name string = &quot;&quot;这种方式来声明变量，声明变量的时候一般会自动推导变量的类型，有需要也可以显式写明变量类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;hello&quot;</span>  <span class="comment">//自动推导变量类型</span></span><br><span class="line"><span class="keyword">var</span> t1,t2 <span class="type">int</span>  <span class="comment">//可以声明多个相同类型的变量</span></span><br></pre></td></tr></table></figure>
<p>另一种变量声明是短声明，使用 变量 := 值 的格式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">name := <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是使用var声明过的变量名，不能用短声明重复声明。</p>
<p>go语言的常量，就是用const关键字替代var关键字声明。需要注意的是，go语言中的常量没有一个确定的类型，它会根据上下文来自动确定类型。</p>
<h3 id="3if-else"><a class="markdownIt-Anchor" href="#3if-else"></a> 3.if else</h3>
<p>go语言中的if else不同于其他语言</p>
<p>go语言中if后面没有小括号()</p>
<p>go语言中if后面必须要有大括号{}，没有C/C++那种缺省大括号写在同一行的写法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if-else</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">7</span>%<span class="number">22</span>==<span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;7 is even&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;7 is odd&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if后可以加上短声明和判断</span></span><br><span class="line"><span class="keyword">if</span> num := <span class="number">9</span>; num &lt; <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(num, <span class="string">&quot;is negative&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> num &lt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(num, has <span class="number">1</span> digit)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(num, <span class="string">&quot;has multiple digits&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4循环"><a class="markdownIt-Anchor" href="#4循环"></a> 4.循环</h3>
<p>go语言中没有while循环、do while循环，只有唯一的一种for循环。</p>
<p>最简单的for循环就是只有for没有循环条件，代表死循环。</p>
<p>循环中途可以用break跳出，也可以使用经典的循环（初值，阈值，步长），这三段中的任何一段都可以省略。</p>
<p>在循环里面还可以用continue直接进入下一个循环（在满足循环条件的情况下）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无条件循环(死循环),使用break跳出循环</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;loop&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 经典循环写法</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">7</span>; j &lt; <span class="number">9</span>; j++ &#123;</span><br><span class="line">    fmt.Println(j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// continue跳过本轮循环,直接进入下一轮循环</span></span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">5</span>; n++ &#123;</span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赋值、判断、增值分开写</span></span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5switch"><a class="markdownIt-Anchor" href="#5switch"></a> 5.switch</h3>
<p>go语言中的switch分支结构，也类似于C/C++。同样地，go语言的switch后面不需要小括号。</p>
<p>但是和C/C<ins>的switch不同，在C</ins>里面，switch case后面如果不显式加break会继续执行后面的case；go语言则不需要break，如果要执行后面的case还需要显式加fallthrough关键字。</p>
<p>相比C/C++，go语言的switch功能更加强大，可以使用任意的变量类型，甚至可以取代任意的if else语句。不在switch后面加任何的变量，在case里面写条件分支，相比多个if else语句，代码逻辑更加清晰</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// switch</span></span><br><span class="line">a := <span class="number">2</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;one&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;two&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;three&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>,<span class="number">5</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;four or five&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6数组"><a class="markdownIt-Anchor" href="#6数组"></a> 6.数组</h3>
<p>数组是一个具有编号且长度固定的元素序列。</p>
<p>对于一个数组，可以很方便地取特定索引的值或者在特定索引存储值，但实际开发中，很少直接使用数组，因为其长度是固定的，使用更多的是切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组声明,未初始化默认值为0(对于int类型数组)</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line"><span class="comment">// 对索引为4的元素赋值</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(<span class="string">&quot;get:&quot;</span>, a[<span class="number">2</span>]) <span class="comment">//a[2]未初始化,默认是0</span></span><br><span class="line">fmt.Println(<span class="string">&quot;len:&quot;</span>, <span class="built_in">len</span>(a)) <span class="comment">//获取数组a的长度5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 短声明,直接赋值</span></span><br><span class="line">b := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组,可直接赋值,也可以用嵌套循环赋值</span></span><br><span class="line"><span class="keyword">var</span> twoD [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure>
<h3 id="7切片"><a class="markdownIt-Anchor" href="#7切片"></a> 7.切片</h3>
<p>切片slice不同于数组array，可以任意更改长度，拥有更多数组不具备的操作。可以使用make来创建切片，使用append来追加元素（注意append的用法，需要把结果返回给原数组）。</p>
<p>slice的原理是存储了一个长度和一个容量，以及一根指向一个数组的指针。</p>
<p>在执行append操作时，如果容量不够，就会扩容并返回新的slice。</p>
<p>slice拥有类似python的切片操作，但不支持负数索引。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 短声明一个string类型的切片,初始化长度为3,容量默认和长度相等</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">3</span>)</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&quot;a&quot;</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="comment">// append追加元素,需要把结果返回给原数组</span></span><br><span class="line"><span class="comment">// 如果容量不够的话,会进行扩容</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>)</span><br><span class="line"><span class="comment">// 复制切片</span></span><br><span class="line">c := <span class="built_in">make</span>([]<span class="type">string</span>,<span class="built_in">len</span>(s))</span><br><span class="line"><span class="built_in">copy</span>(c,s) <span class="comment">//[a b c d e f]</span></span><br><span class="line"><span class="comment">// 切片索引操作</span></span><br><span class="line">fmt.Println(s[<span class="number">2</span>:<span class="number">5</span>]) <span class="comment">// [c d e]</span></span><br><span class="line">fmt.Println(s[:<span class="number">5</span>]) <span class="comment">// [a b c d e]</span></span><br><span class="line">fmt.Println(s[<span class="number">2</span>:]) <span class="comment">// [c d e f]</span></span><br><span class="line"><span class="comment">// 其他初始化方式</span></span><br><span class="line">str := []<span class="type">string</span>&#123;<span class="string">&quot;s&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;r&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8map"><a class="markdownIt-Anchor" href="#8map"></a> 8.map</h3>
<p>map在其他语言里又可能被称为哈希或者字典，是实际开发中使用最频繁的数据结构。</p>
<p>map也可以使用make来创建，创建时需要提供两个类型，key的类型和value的类型。</p>
<p>map可以存储键值对形式的数据，可以通过delete删除键值对。</p>
<p>go语言的map是完全无序的，遍历的时候是随机顺序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 短声明一个key为string类型,value为int类型的map</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">m[<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br><span class="line"><span class="comment">// 删除键值对</span></span><br><span class="line"><span class="built_in">delete</span>(m,<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment">// 其他初始化方式</span></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> m3 = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9range"><a class="markdownIt-Anchor" href="#9range"></a> 9.range</h3>
<p>range能够用于快速遍历slice和map，并且代码简洁。</p>
<p>range遍历数组时会返回两个字，第一个是索引，第二个是对应的值。如果不需要索引可以用下划线来忽略。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">2</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;index:&quot;</span>, i, <span class="string">&quot;num:&quot;</span>, num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;B&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10函数"><a class="markdownIt-Anchor" href="#10函数"></a> 10.函数</h3>
<p>go语言其他语言不同的是，go语言中函数的变量类型是后置的，且go函数原生支持多个返回值。实际开发中，几乎所有的函数都返回两个值，第一个是真正的返回结果，第二个是错误信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断map的值是否存在,返回值和错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exists</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, k <span class="type">string</span>)</span></span> (v <span class="type">string</span>, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    v, ok = m[k]</span><br><span class="line">    <span class="keyword">return</span> v, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11指针"><a class="markdownIt-Anchor" href="#11指针"></a> 11.指针</h3>
<p>go语言也支持指针，但指针操作相对于C/C++的指针比较局限。指针主要的用途就是对传入参数进行修改。</p>
<p>使用指针传参和不使用指针传参，主要区别就是有无拷贝的所带来开销以及能否直接修改数据。对于大型结构体来说，开销更大。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span> <span class="params">(n *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *n += <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := <span class="number">5</span></span><br><span class="line">    add(&amp;n)</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12结构体"><a class="markdownIt-Anchor" href="#12结构体"></a> 12.结构体</h3>
<p>结构体是带类型的字段的集合。可以用结构体的名称作为结构体类型去初始化一个结构体变量，构造的时候需要传入每个字段的初始值。也可以用这种键值对的方式只对一部分字段进行初始化。</p>
<p>结构体也支持指针，并且使用指针修改结构体能避免结构体的拷贝开销。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name    <span class="type">string</span></span><br><span class="line">    passwd  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化结构体的几种方式</span></span><br><span class="line">    a := user&#123;name: <span class="string">&quot;a&quot;</span>, passwd: <span class="string">&quot;123&quot;</span>&#125;</span><br><span class="line">    b := user&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;123&quot;</span>&#125;</span><br><span class="line">    c := user&#123;name: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">    c.passwd = <span class="string">&quot;123&quot;</span></span><br><span class="line">    <span class="keyword">var</span> d user</span><br><span class="line">    d.name = <span class="string">&quot;a&quot;</span></span><br><span class="line">    d.passwd = <span class="string">&quot;123&quot;</span></span><br><span class="line">    fmt.Println(check(&amp;a, <span class="string">&quot;456&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(u *user, passwd <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> u.passwd == passwd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13结构体方法"><a class="markdownIt-Anchor" href="#13结构体方法"></a> 13.结构体方法</h3>
<p>结构体方法类似于其他语言中的类成员函数。结构体方法可以选择带指针或不带指针，带指针的话，就是能够去修改结构体，不带指针的话，就是只能获取结构体数据不能修改数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对照上面12的user结构体和check函数</span></span><br><span class="line"><span class="comment">// 结构体方法不同于函数,在一开始就指明了结构体类型</span></span><br><span class="line"><span class="comment">// 不需要改动数据时,不带指针操作即可</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span></span> checkPasswd(passwd <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> u.passwd == passwd</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要改动数据时,带指针操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span></span> reset(passwd <span class="type">string</span>) &#123;</span><br><span class="line">    u.passwd = passwd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14错误处理"><a class="markdownIt-Anchor" href="#14错误处理"></a> 14.错误处理</h3>
<p>错误处理在go语言中的语言习惯做法就是使用一个单独的返回值来传递错误信息。</p>
<p>不同于Java的异常处理，go语言的处理方式能够很清晰地知道哪个函数返回了错误，并且能用简单的if else来处理错误。</p>
<p>在函数的返回值类型里面加上error，就代表这个函数可能返回错误。在函数实现的时候，如果出错的话，就可以返回一个nil和error，如果没有出错，就返回原本的结果和nil。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以12的user结构体为例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUser</span><span class="params">(users []user, name <span class="type">string</span>)</span></span> (v *user, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> _, u := <span class="keyword">range</span> users &#123;</span><br><span class="line">        <span class="keyword">if</span> u.name == name  &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;u, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;not found&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15字符串操作"><a class="markdownIt-Anchor" href="#15字符串操作"></a> 15.字符串操作</h3>
<p>在标准库strings包里面有很多常用的字符串工具函数。</p>
<ul>
<li>contains：判断一个字符串里面是否包含另一个字符串</li>
<li>count：统计字符串中某个字符或字符子串出现的次数</li>
<li>index：查找某个字符串第一次出现的位置</li>
<li>join：连接多个字符串，将两个字符串用字符连接起来</li>
<li>repeat：重复多个字符串</li>
<li>replace：替换字符串</li>
</ul>
<h3 id="16字符串格式化"><a class="markdownIt-Anchor" href="#16字符串格式化"></a> 16.字符串格式化</h3>
<p>在标准库的fmt包里面有很多字符串格式相关的方法。</p>
<p>go语言的printf类似C语言的printf，不同的是，在go语言中，可以用%v占位符来打印任意类型的变量，而不需要区分数字、字符串，可以用%+v打印详细结果，也可以用%#v打印得更详细。</p>
<h3 id="17json处理"><a class="markdownIt-Anchor" href="#17json处理"></a> 17.JSON处理</h3>
<p>go语言的JSON操作非常简单，对于一个结构体，只要保证每个字段的首字母大写（公开字段，相当于Java中的public），那么这个结构体就能用JSON.marshal序列化成JSON字符串。</p>
<p>序列化之后的字符串也可以用JSON.unmarshal反序列化到一个空变量中。</p>
<p>默认序列化的字符串风格是大写字母开头，不是下划线，可以用json tag等语法来修改输出结果的字段名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> userInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name   <span class="type">string</span></span><br><span class="line">    Age    <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">    Hobby  []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := userInfo&#123;Name: <span class="string">&quot;a&quot;</span>, Age: <span class="number">11</span>, Hobby: []<span class="type">string</span>&#123;<span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Typescript&quot;</span>&#125;&#125;</span><br><span class="line">    buf, err := json.Marshal(a) <span class="comment">// 序列化</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="type">string</span>(buf))</span><br><span class="line">    </span><br><span class="line">    buf, err = json.MarshalIndent(a, <span class="string">&quot;&quot;</span>, <span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="type">string</span>(buf))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b userInfo</span><br><span class="line">    err = json.Unmarshal(buf, &amp;b) <span class="comment">// 反序列化到空变量中</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18时间处理"><a class="markdownIt-Anchor" href="#18时间处理"></a> 18.时间处理</h3>
<p>go语言时间处理最常用的就是用time.now()来获取当前时间，也可以用time.date去构造一个带时区的时间。</p>
<p>使用sub对两个时间进行减法得到时间差，可以查看它们具体相差多少小时、多少分钟、多少秒。</p>
<p>在系统交互时，经常会使用到时间戳，可以使用UNIX方法生成时间戳。</p>
<p>需要注意的是使用format或者parse来处理时间时，都需要使用<code>2006-01-02 15:04:05</code>这个固定参数才能得到正确的时间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    now := time.Now()</span><br><span class="line">    t := time.Date(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">    t2 := time.Date(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">13</span>, <span class="number">45</span>, <span class="number">30</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">    fmt.Println(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute())</span><br><span class="line">    fmt.Println(t.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">    diff := t2.Sub(t)</span><br><span class="line">    fmt.Println(diff)</span><br><span class="line">    fmt.Println(diff.Minutes(), diff.Seconds())</span><br><span class="line">    t3, err := time.Parse(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2023-01-20 12:30:30&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(now.Unix())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="19数字解析"><a class="markdownIt-Anchor" href="#19数字解析"></a> 19.数字解析</h3>
<p>在go语言中可以通过strconv这个包来进行字符串和数字类型之间的转换。</p>
<p>可以使用parseInt或parseFloat来解析一个数字字符串，使用atoi将一个十进制字符串转换为数字，使用itoa将数字转换为字符串。如果转换的数据不合法就会返回error。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, _ := strconv.ParseFloat(<span class="string">&quot;1.234&quot;</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(f)</span><br><span class="line">    </span><br><span class="line">    n, _ := strconv.ParseInt(<span class="string">&quot;111&quot;</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    </span><br><span class="line">    n, _ = strconv.ParseInt(<span class="string">&quot;0x1000&quot;</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    </span><br><span class="line">    n2, _ := strconv.Atoi(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">    fmt.Println(n2)</span><br><span class="line">    </span><br><span class="line">    n2, err := strconv.Atoi(<span class="string">&quot;AAA&quot;</span>)</span><br><span class="line">    fmt.Println(n2, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="20进程信息"><a class="markdownIt-Anchor" href="#20进程信息"></a> 20.进程信息</h3>
<p>在go语言中能够通过os.args来获取程序执行时指定的命令行参数。可以用os.getenv获取环境变量。exec.command用于执行系统的命令。</p>
<p>以下部分代码在windows系统下可能会报错，需要在linux系统运行才能获取正确信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(os.Args)</span><br><span class="line">    fmt.Println(os.Getenv(<span class="string">&quot;PATH&quot;</span>))</span><br><span class="line">    fmt.Println(os.Setenv(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    buf, err := exec.Command(<span class="string">&quot;grep&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;/etc/hosts&quot;</span>).CombineOutput()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="type">string</span>(buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用go run加参数运行，例如<code>go run main.go a b c d</code></p>
<h2 id="31-猜谜游戏"><a class="markdownIt-Anchor" href="#31-猜谜游戏"></a> 3.1 猜谜游戏</h2>
<h3 id="1生成随机数"><a class="markdownIt-Anchor" href="#1生成随机数"></a> 1.生成随机数</h3>
<p>需要math/rand包用于生成随机数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">maxNum := <span class="number">100</span> <span class="comment">//最大范围</span></span><br><span class="line">random := rand.Intn(maxNum) <span class="comment">//生成0-100之间的随机整数</span></span><br></pre></td></tr></table></figure>
<p>注意到以上代码多次生成的数都是同一个数。查看这个包的官方文档可得知使用之前需要设置随机数种子用于生成随机数序列，否则每次生成的随机数序列都是相同的。习惯上用时间戳来初始化随机数种子。</p>
<p>在生成随机数之前用时间戳初始化随机数种子即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rand.Seed(time.Now().UnixNano())</span><br></pre></td></tr></table></figure>
<h3 id="2读取用户输入"><a class="markdownIt-Anchor" href="#2读取用户输入"></a> 2.读取用户输入</h3>
<p>每个程序执行时都会打开几个文件，stdin、stdou、stderr等。stdin可通过os.Stdin获取，但直接操作文件很不方便。</p>
<p>go语言中的bufio包提供了读取用户输入的方法，newReader方法能够将一个文件转换成一个reader变量，reader变量上拥有很多流的操作。使用ReadString方法读取一行，返回结果中包含结尾的换行符。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line">input, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">//读取</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;An error occured while reading input. Please try again&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 去掉换行符</span></span><br><span class="line">input = strings.Trim(input, <span class="string">&quot;\n&quot;</span>) <span class="comment">//这里根据不同的操作系统可能需要换成\r\n或其他参数</span></span><br><span class="line"><span class="comment">// 转换为数字</span></span><br><span class="line">guess, err := strconv.Atoi(input)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Invalid input. Please enter an integer value&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3实现判断逻辑"><a class="markdownIt-Anchor" href="#3实现判断逻辑"></a> 3.实现判断逻辑</h3>
<p>正常情况下，只有三种结果，过大、过小以及相等。使用简单的if else即可。</p>
<h3 id="4实现游戏循环"><a class="markdownIt-Anchor" href="#4实现游戏循环"></a> 4.实现游戏循环</h3>
<p>由于无法确定固定的循环次数，使用for循环配合continue和break，在读取和转换字符串失败用continue继续循环，在猜中数字时用break退出循环即可。</p>
<h2 id="32-在线词典"><a class="markdownIt-Anchor" href="#32-在线词典"></a> 3.2 在线词典</h2>
<p>通过调用第三方API查询单词的翻译并打印出来。</p>
<p>学会如何使用go语言来发送HTTP请求，解析json数据以及学习如何使用代码生成来提高开发效率。</p>
<h3 id="1抓包"><a class="markdownIt-Anchor" href="#1抓包"></a> 1.抓包</h3>
<p>以彩云APIhttps://fanyi.caiyunapp.com/为例，在在线翻译页面打开浏览器的开发者工具。</p>
<p>使用一次翻译，同时捕获查询单词的post请求，在预览里面找到具体的查询结果。</p>
<h3 id="2代码生成"><a class="markdownIt-Anchor" href="#2代码生成"></a> 2.代码生成</h3>
<p>在go语言里构造一个请求用于请求API，由于请求比较复杂，用代码构造麻烦。可以直接在浏览器中复制为cURL（bash）在linux终端或复制为powershell在windows的powershell下测试，成功的话就会返回一大堆json字符串。</p>
<p>在一个在线代码生成网站<a target="_blank" rel="noopener" href="https://curlconverter.com/go/">Convert curl to Go</a>里粘贴cURL，就可以看到生成的go语言代码。直接将代码粘贴到编辑器里即可。</p>
<p><strong>部分代码解读</strong></p>
<p>创建HTTP client，可以指定很多参数进行创建，如请求超时时间以及是否使用cookie等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">client := &amp;http.Client&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>创建请求，使用http包中的NewRequest方法创建一个post请求，第一个参数指定请求类型，第二个参数指定URL，第三个参数指定请求体。其中请求体可能很大，为了支持流式发送，使用strings.NewReader将字符串转换为一个只读流存放在data变量中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">req, err := http.NewRequest(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;https://api.interpreter.caiyunai.com/v1/dict&quot;</span>, data)</span><br></pre></td></tr></table></figure>
<p>设置请求头，往往需要设置很多个参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">req.Header.Set(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>) <span class="comment">//填写请求体的各种参数</span></span><br></pre></td></tr></table></figure>
<p>发起请求，使用HTTP client发起请求，获取结果。如果请求失败便会打印错误信息并退出进程。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resp, err := client.Do(req)</span><br></pre></td></tr></table></figure>
<p>读取响应，body同样是一个流，为了避免资源泄露，需要使用defer来手动关闭流，defer会在函数运行结束后执行。使用ioutil.ReadAll读取流，获取整个body的信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">bodyText, err := ioutil.ReadAll(resp.Body)</span><br></pre></td></tr></table></figure>
<p>目前已经能够成功发送请求，但是上面生成的代码是固定输入的。需要使用JSON序列化来实现手动输入请求参数。</p>
<h3 id="3生成request-body"><a class="markdownIt-Anchor" href="#3生成request-body"></a> 3.生成request body</h3>
<p>在go语言中，要生成一段JSON，常用的方式就是先构造一个对应json结构的结构体。注意结构体字段首字母一定要大写，否则无法访问该字段。</p>
<p>结构体中的字段对应了请求负载中的字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DictRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    TransType <span class="type">string</span> <span class="string">`json:&quot;trans_type&quot;`</span></span><br><span class="line">    Source    <span class="type">string</span> <span class="string">`json:&quot;source&quot;`</span></span><br><span class="line">    UserID    <span class="type">string</span> <span class="string">`json:&quot;user_id&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>json反序列化为字节数组，使用byte.NewReader来构造request body</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    request := DictRequest&#123;TransType: <span class="string">&quot;en2zh&quot;</span>, Source: <span class="string">&quot;good&quot;</span>&#125;</span><br><span class="line">    buf, err := json.Marshal(request)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> data = bytes.NewReader(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以此实现通过一个变量来发送HTTP请求。</p>
<h3 id="4解析response-body"><a class="markdownIt-Anchor" href="#4解析response-body"></a> 4.解析response body</h3>
<p>在js/python这些脚本语言中，body是一个字典或者map的结构，可以直接取值。但go语言是一个强类型语言，不适合这种直接取值的做法。常用的方式就是通过结构体，将json反序列化到结构体中。但是API返回的结构也比较复杂，可以借助代码生成工具<a target="_blank" rel="noopener" href="https://oktools.net/json2go">JSON转Golang Struct - 在线工具 - OKTools</a>用于快速生成对应的代码，将响应的json数据通过代码生成工具生成对应的结构体。如果不需要对返回结果进行精细处理，转换为嵌套结构体即可。</p>
<p>得到response结构体后，使用json.Unmarshal把body反序列化到结构体中，再打印出来。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dictResponse DictResponse <span class="comment">//DictResponse是生成的结构体的名称</span></span><br><span class="line">err = json.Unmarshal(bodyText, &amp;dictResponse) <span class="comment">//bodyText存储了body原始信息,反序列化到空变量中</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, dictResponse)</span><br></pre></td></tr></table></figure>
<p>之后就是打印特定字段的信息。</p>
<h3 id="5打印结果"><a class="markdownIt-Anchor" href="#5打印结果"></a> 5.打印结果</h3>
<p>在以上的API响应例子中，需要用到的信息是在<code>Dictionary.explanations</code>里面。</p>
<p>可以使用for range迭代并打印信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> dictResponse.Dictionary.Explanations &#123;</span><br><span class="line">    fmt.Println(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6完善代码"><a class="markdownIt-Anchor" href="#6完善代码"></a> 6.完善代码</h3>
<p>将代码主体改造成一个query函数，把需要查询的单词作为参数传递。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">`usage: simpleDict WORD</span></span><br><span class="line"><span class="string">        example: simpleDict hello`</span>)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    word := os.Args[<span class="number">1</span>]</span><br><span class="line">    query(word)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过命令行输入参数运行，使用<code>go run main.go</code>接需要查询的单词即可。</p>
<h2 id="33-socks5代理"><a class="markdownIt-Anchor" href="#33-socks5代理"></a> 3.3 SOCKS5代理</h2>
<p>编写一个socks5代理服务器。socks5协议都是明文传输，这个协议历史久远，诞生于互联网早期。它的用途就是在防火墙保证数据安全性时提供socks5协议的端口给授权的用户以便访问内部资源。</p>
<h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3>
<p>正常浏览器访问一个网站，如果不经过代理服务器，就是先和目标网站的服务器建立TCP连接，完成三次握手后发起HTTP请求，然后服务器返回HTTP响应。</p>
<p>如果设置了代理服务器，那么流程会变得复杂一些。首先是浏览器和sock5代理建立TCP连接，代理再和真正的服务器建立TCP连接。可以分成四个阶段，握手阶段、认证阶段、请求阶段、relay阶段。</p>
<p>第一个握手阶段，浏览器会向socks5代理发送请求，数据包的内容包括一个协议的版本号、支持认证的种类，socks5服务器会选择一个认证方式，返回给浏览器。如果返回的是00则代表不需要认证，返回其他结果则开始认证流程。</p>
<p>第二个认证阶段参考https://wiyi.org/socks5-protocol-in-deep.html</p>
<p>第三个请求阶段，认证通过之后浏览器会向socks5发起请求。主要信息包括版本号，请求的类型（一般是connection请求，表示代理服务器要和某个域名或者某个IP地址的某个端口建立TCP连接）。代理服务器收到响应后会真正和后端服务器建立连接，然后返回一个响应。</p>
<p>第四个relay阶段，此时浏览器会正常发送请求，然后代理服务器接收到请求之后直接转发给真正的服务器，真正的服务器返回的响应也经过代理服务器转发到浏览器这边。socks5代理服务器实际上并不关系流量的细节，可以是HTTP流量也可以是其他的TCP流量。</p>
<h3 id="1tcp-echo-server"><a class="markdownIt-Anchor" href="#1tcp-echo-server"></a> 1.TCP echo server</h3>
<p>在go语言中实现一个简单的TCP echo server。使用简单的逻辑，发送什么就返回什么，方便测试。</p>
<p>在main函数中使用net.listen监听一个端口，返回一个server。然后在一个死循环中反复accept请求，成功之后就会返回一个连接。接下来在一个process函数里处理这个连接。</p>
<p>process函数的实现，先添加一个defer connection.close防止资源泄露，接下来使用bufio.NewReader来创建一个带缓冲的只读流，带缓冲的流可以减少底层系统的调用次数，且具有更多的工具函数可以读取数据，可以使用readbyte来读取单个字节，再写进去连接。</p>
<p>main函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    server, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:1080&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        client, err := server.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Accept failed %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> process(client) <span class="comment">//go关键字代表启动一个goroutine,这里的goroutine可暂时类比为一个子线程,但是开销比子线程小很多,能够轻松处理上万的并发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>process函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    reader := bufio.NewReader(conn)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        b, err := reader.ReadByte()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        _, err = conn.Write([]<span class="type">byte</span>&#123;b&#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行nc命令测试服务器，nc是linux系统下的命令，windows系统需要额外安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc 127.0.0.1 1080</span><br></pre></td></tr></table></figure>
<p>输入什么服务器就会返回什么。</p>
<h3 id="2auth"><a class="markdownIt-Anchor" href="#2auth"></a> 2.auth</h3>
<p>认证阶段，这一部分会比较复杂。实现一个空的auth函数，在process函数里调用。</p>
<p>认证阶段的逻辑，第一步，浏览器会向代理服务器发送一个包。这个包有三个字段</p>
<p>第一个字段version，协议版本号，固定是5。</p>
<p>第二个字段methods，认证的方法数目。</p>
<p>第三个字段，每个method的编码，0表示不需要认证，2表示用户名密码认证。</p>
<p>使用readbyte读取版本号，不是socks5直接返回报错，再读取method size（同样是一个字节）。创建一个相应长度的slice，用io.ReadFull填充信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> socks5Ver = <span class="number">0x05</span> <span class="comment">//socks5的版本号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">auth</span><span class="params">(reader *bufio.Reader, conn net.Conn)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">    ver, err := reader.ReadByte()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read ver failed:%w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ver != socks5Ver &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;not supported ver:%v&quot;</span>, ver)</span><br><span class="line">    &#125;</span><br><span class="line">    methodSize, err := reader.ReadByte()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read methodSize failed:%w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    method := <span class="built_in">make</span>([]<span class="type">byte</span>, methodSize)</span><br><span class="line">    _, err = io.ReadFull(reader, method)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read method failed:%w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">&quot;ver&quot;</span>, ver, <span class="string">&quot;method&quot;</span>, method)</span><br><span class="line">    _, err = conn.Write([]<span class="type">byte</span>&#123;socks5Ver, <span class="number">0x00</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;write failed:%w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，代理服务器还需要返回一个response，返回包有两个字段，一个是version，一个是method，也就是鉴传方式。当前只考虑实现不需要鉴传的方式，即00。可以使用curl命令测试效果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --socks5 127.0.0.1:1080 -v http://www.baidu.com</span><br></pre></td></tr></table></figure>
<p>curl命令还不能成功，因为协议还没有完善。查看日志，version和method可以正常打印，说明目前协议实现正确。</p>
<h3 id="3请求阶段"><a class="markdownIt-Anchor" href="#3请求阶段"></a> 3.请求阶段</h3>
<p>请求阶段，读取携带URL或者IP地址+端口的包。实现一个和auth函数类似的connect函数，同样在process中调用。</p>
<p>请求阶段的逻辑，浏览器会发送一个包，包里有如下6个字段</p>
<p>version版本号，是5。command请求类型，这边只支持connection请求，也就是让代理服务器建立新的TCP连接。RSV保留字段，不需要理会。atype目标地址类型，可能是IPv4 IPv6或者域名。addr地址，这个地址的长度受atype的类型的影响会有不同。port端口号，两个字节，需要逐个读取。</p>
<p>前四个字段共四个字节，可以一次性读取，定义一个长度为4的buffer。读取完后，第0个就是version，判断是否为socks5，第1个就是cmd，判断是否为1（1表示connection请求），第3个就是atype，如果是IPv4，则再次读取到buffer，将buffer的字节逐个以IP地址的格式保存到addr变量中。如果是host，需要先读取长度，再创建一个相应长度的buf进行填充，转换成字符串保存到addr变量。IPv6目前不考虑支持。</p>
<p>最后的port有两个字节，读取后按协议规定的大端字节序转换成数字。前面的buffer不会再被其他变量使用，可以直接复用内存，创建一个临时slice，长度为2。接下来把IP地址和端口号打印出来。</p>
<p>收到浏览器的请求包之后，需要返回一个包。这个包里有很多字段，但大部分不会使用。</p>
<p>第一个是版本号socks5，第二个是返回类型，成功的话就返回0，第三个是保留字段，填0即可，第四个字段是atype地址类型，填1。第五、六个字段暂时用不到，都填0。一共是4+4+2个字节。</p>
<p>编写完connect函数后，使用curl重新测试，看到IP地址和端口信息被打印出来，说明当前协议实现正确。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --socks5 127.0.0.1:1080 -v http://www.baidu.com</span><br></pre></td></tr></table></figure>
<p>最后一步就是和端口建立连接，实现双向转发数据。</p>
<h3 id="4relay阶段"><a class="markdownIt-Anchor" href="#4relay阶段"></a> 4.relay阶段</h3>
<p>直接使用net.dial建立一个TCP连接。建立连接之后，不要忘记使用defer来关闭连接。</p>
<p>实现浏览器和下游服务器的双向数据转发。标准库的io.copy可以实现一个单向数据转发，那么可以使用两个goroutine实现双向转发。</p>
<p>此时存在一个问题，connect函数会立即返回并关闭连接，需要等待任意一个方向copy出错后再返回connect函数。可以使用标准库的context机制，用contextWithCancel来创建一个context，在最后等待ctx.Done，只要cancel被调用，ctx.Done就会立即返回，然后在两个goroutine里各调用一次cancal即可。</p>
<p>在connect函数中添加</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dest, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;%v:%v&quot;</span>, addr, port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Errorf(<span class="string">&quot;dial dst failed:%w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> dest.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在写入数据完成之后</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Backgrond())</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _, _ = io.Copy(dest, reader)</span><br><span class="line">    cancel()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _, _ = io.Copy(conn, dest)</span><br><span class="line">    cancel()</span><br><span class="line">&#125;()</span><br><span class="line">&lt;-ctx.Done()</span><br></pre></td></tr></table></figure>
<p>执行curl测试，返回成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --socks5 127.0.0.1:1080 -v http://www.baidu.com</span><br></pre></td></tr></table></figure>
<p>还可以在浏览器中测试代理，需要安装switchyomega插件。新建情景模式，代理服务器socks5，端口1080，保存并启用。访问网站，可以在代理服务器这边看到浏览器版本的域名和端口。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/wangkechun/go-by-example/">源代码</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Entropy
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://s-chance.github.io/2023/01/26/golang-day1/" title="golang基础">https://s-chance.github.io/2023/01/26/golang-day1/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 学习笔记</a>
              <a href="/tags/%E9%9D%92%E8%AE%AD%E8%90%A5/" rel="tag"><i class="fa fa-tag"></i> 青训营</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/01/17/blog-by-https/" rel="prev" title="关于个人Hexo博客的搭建历史">
                  <i class="fa fa-chevron-left"></i> 关于个人Hexo博客的搭建历史
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/01/26/golang-day2/" rel="next" title="golang工程进阶">
                  golang工程进阶 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2022 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Entropy</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">110k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:40</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://waline-hexo-nu.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"请评论","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":["nick"],"el":"#waline","comment":true,"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","path":"/2023/01/26/golang-day1/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
