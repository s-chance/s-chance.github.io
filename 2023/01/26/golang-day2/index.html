<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="mysql redis hexo go java git linux"><meta name="author" content="Entropy"><link rel="stylesheet" href="/css/katex.min.css" integrity="sha384-mXD7x5S50Ko38scHSnD4egvoExgMPbrseZorkbE49evAfv9nNcbrXJ8LLNsDgh9d" crossorigin="anonymous"><script defer src="/css/katex.min.js" integrity="sha384-j/ZricySXBnNMJy9meJCtyXTKMhIJ42heyr7oAdxTDBy/CYA9hzpMo+YTNV5C+1X" crossorigin="anonymous"></script><script defer src="/css/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body)"></script><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="canonical" href="https://s-chance.github.io/2023/01/26/golang-day2/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="本文来源于第五届字节跳动青训营活动，已收录到golang工程进阶 | 青训营笔记 - 掘金 (juejin.cn) ，主要记录了对golang工程开发的学习"><meta property="og:type" content="article"><meta property="og:title" content="Go 工程进阶"><meta property="og:url" content="https://s-chance.github.io/2023/01/26/golang-day2/index.html"><meta property="og:site_name" content="树下集熵"><meta property="og:description" content="本文来源于第五届字节跳动青训营活动，已收录到golang工程进阶 | 青训营笔记 - 掘金 (juejin.cn) ，主要记录了对golang工程开发的学习"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-01-26T10:01:52.000Z"><meta property="article:modified_time" content="2023-03-31T23:55:52.497Z"><meta property="article:author" content="Entropy"><meta property="article:tag" content="学习笔记"><meta property="article:tag" content="golang"><meta name="twitter:card" content="summary"><link rel="icon" type="image/png" href="/images/redefine-favicon.svg" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.svg"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="/images/redefine-favicon.svg"><title>Go 工程进阶 - 树下集熵</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/fonts/fonts.css"><link rel="stylesheet" href="/fonts/Satoshi/satoshi.css"><link rel="stylesheet" href="/fonts/Chillax/chillax.css"><script id="hexo-configurations">let Global=window.Global||{};Global.hexo_config={hostname:"s-chance.github.io",root:"/",language:"zh-CN",path:"search.xml"},Global.theme_config={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[""]},code_block:{copy:!0,style:"mac",font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:3,number:!1,expand:!0,init_open:!0},copyright:!0,lazyload:!0,recommendation:{enable:!0,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#A31F34",secondary:null},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!1},scroll_progress:{bar:!0,percentage:!1},busuanzi_counter:{enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},pjax:!0,open_graph:!0,google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/wallhaven-wqery6-light.webp",dark:"/images/wallhaven-wqery6-dark.webp"},title:"树下集熵",subtitle:{text:["the truth of life"],hitokoto:{enable:!0,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!0,links:{github:"https://github.com/s-chance",instagram:null,zhihu:null,twitter:"https://twitter.com/entropy_tree",email:"mailto:entropy.tree@outlook.com","stack-overflow":"https://stackoverflow.com/users/19329372/entropy"}}},plugins:{feed:{enable:!0},aplayer:{enable:!0,type:"fixed",audios:[{name:"Night Cursing",artist:"牛尾憲輔 (agraph)",url:"/NightCursing.m4a",cover:"/NightCursing.jpg"},{name:"Nightbreak",artist:"void",url:"/Nightbreak.m4a",cover:"/Nightbreak.jpg"},{name:"Counter Attack-Mankind (Sasha Version) (Cover)",artist:"Samuel Kim",url:"/Counter Attack-Mankind (Sasha Version) (Cover).m4a",cover:"/Counter Attack-Mankind (Sasha Version) (Cover).jpg"}]},mermaid:{enable:!1,version:"9.3.0"}},version:"2.2.2",navbar:{auto_hide:!0,color:{left:"#f78736",right:"#367df7",transparency:35},links:{Home:{path:"/",icon:"fa-regular fa-house"},Archives:{path:"/archives",icon:"fa-regular fa-archive"},About:{icon:"fa-regular fa-user",submenus:{Me:"/about",Github:"https://github.com/s-chance",Blog:"https://www.entropy-tree.top",RSS:"atom.xml"}},Friends:{path:"/links",icon:"fa-solid fa-link"}},search:{enable:!0,preload:!0}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:null,links:{Archives:{path:"/archives",icon:"fa-regular fa-archive"},Tags:{path:"/tags",icon:"fa-regular fa-tags"},Categories:{path:"/categories",icon:"fa-regular fa-folder"},RSS:{path:"atom.xml",icon:"fa-solid fa-rss"}}},article_date_format:"auto",categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2022/8/17 11:45:14"},Global.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"},Global.data_config={masonry:!1}</script><link rel="stylesheet" href="/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/fontawesome/brands.min.css"><link rel="stylesheet" href="/fontawesome/solid.min.css"><link rel="stylesheet" href="/fontawesome/regular.min.css"><link rel="stylesheet" href="/fontawesome/sharp-solid.min.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="树下集熵" type="application/atom+xml">
</head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <span class="pjax-progress-icon"><i class="fa-solid fa-circle-notch fa-spin"></i></span></div><main class="page-container"><div class="main-content-container"><div class="main-content-header"><header class="navbar-container"><div class="navbar-content"><div class="left"><a class="logo-title" href="/">树下集熵</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house"></i> 首页</a></li><li class="navbar-item"><a href="/archives"><i class="fa-regular fa-archive"></i> 归档</a></li><li class="navbar-item"><a class="has-dropdown" href="#" onclick="return!1"><i class="fa-regular fa-user"></i> 关于&nbsp;<i class="fa-solid fa-chevron-down"></i></a><ul class="sub-menu"><li><a href="/about">ME</a></li><li><a target="_blank" rel="noopener" href="https://github.com/s-chance">GITHUB</a></li><li><a target="_blank" rel="noopener" href="https://www.entropy-tree.top">BLOG</a></li><li><a href="/atom.xml">RSS</a></li></ul></li><li class="navbar-item"><a href="/links"><i class="fa-solid fa-link"></i> 友情链接</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer"><ul class="drawer-navbar-list"><li class="drawer-navbar-item flex-center"><a href="/"><i class="fa-regular fa-house"></i> 首页</a></li><li class="drawer-navbar-item flex-center"><a href="/archives"><i class="fa-regular fa-archive"></i> 归档</a></li><li class="drawer-navbar-item flex-center"><a class="has-dropdown" href="#" onclick="return!1"><i class="fa-regular fa-user"></i> 关于&nbsp;<i class="fa-solid fa-chevron-down"></i></a></li><li class="dropdown-item flex-center"><a class="dropdown-item" href="/about">ME</a></li><li class="dropdown-item flex-center"><a class="dropdown-item" target="_blank" rel="noopener" href="https://github.com/s-chance">GITHUB</a></li><li class="dropdown-item flex-center"><a class="dropdown-item" target="_blank" rel="noopener" href="https://www.entropy-tree.top">BLOG</a></li><li class="dropdown-item flex-center"><a class="dropdown-item" href="/atom.xml">RSS</a></li><li class="drawer-navbar-item flex-center"><a href="/links"><i class="fa-solid fa-link"></i> 友情链接</a></li></ul></div><div class="window-mask"></div></header></div><div class="main-content-body"><div class="main-content"><div class="fade-in-down-animation"><div class="post-page-container"><div class="article-content-container"><div class="article-title"><h1 class="article-title-regular">Go 工程进阶</h1></div><div class="article-header"><div class="avatar"><img src="/images/avatar.webp"></div><div class="info"><div class="author"><span class="name">Entropy</span> <span class="author-label"></span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2023-01-26 18:01:52</span> <span class="mobile">2023-01-26 18:01:52</span> <span class="hover-info">创建</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2023-04-01 07:55:52</span> <span class="mobile">2023-04-01 07:55:52</span> <span class="hover-info">更新</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/%E9%9D%92%E8%AE%AD%E8%90%A5%E8%AE%B0%E5%BD%95/">青训营记录</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>&nbsp;</li><li>| <a href="/tags/golang/">golang</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fa-regular fa-typewriter"></i>&nbsp;<span>7.1k 字</span> </span><span class="article-min2read article-meta-item"><i class="fa-regular fa-clock"></i>&nbsp;<span>27 分钟</span> </span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><p>本文来源于第五届字节跳动青训营活动，已收录到<a class="link" target="_blank" rel="noopener" href="https://juejin.cn/post/7193685237723824187">golang工程进阶 | 青训营笔记 - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，主要记录了对golang工程开发的学习<span id="more"></span></p><h2 id="语言进阶"><a class="markdownIt-Anchor" href="#语言进阶"></a> 语言进阶</h2><h3 id="1并发-vs-并行"><a class="markdownIt-Anchor" href="#1并发-vs-并行"></a> 1.并发 VS 并行</h3><ul><li>并发：多线程程序在一个核的CPU上运行</li><li>并行：多线程程序在多个核的CPU上运行</li></ul><p>go语言可以充分发挥多核优势，高效运行</p><h4 id="11-goroutine"><a class="markdownIt-Anchor" href="#11-goroutine"></a> 1.1 Goroutine</h4><ul><li>线程：用户态，轻量级线程，栈MB级别</li><li>协程：内核态，线程跑多个协程，栈KB级别</li></ul><p><strong>关于用户态和内核态的区别</strong></p><p>用户态和内核态是操作系统的两种运行级别。</p><p>当程序运行在3级特权级上时，就可以称之为运行在用户态，这是最低特权级，是普通用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态。</p><p>当程序运行在0级特权级上时，就可以称之为运行在内核态。</p><p>运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。用户态下的程序在其需要操作系统帮助完成某些它没有权限和能力完成的工作时就会切换到内核态，比如操作硬件。</p><p>这两种状态的主要差别是</p><ul><li>处于用户态执行时，进程所能访问的内存空间和对象受到限制，其处于占用的处理器是可被抢占的</li><li>处于内核态执行时，能够访问使用的内存空间和对象，且所占有的处理器是不允许被抢占的</li></ul><p><strong>快速打印</strong></p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello goroutine: &quot;</span> + fmt.Sprint(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloGoRoutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            hello(j)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="12-csp"><a class="markdownIt-Anchor" href="#12-csp"></a> 1.2 CSP</h4><p>CSP(Communicating Sequential Processes)是一种并发模型。在go语言中提倡通过通信共享内存而不是通过共享内存而实现通信（像Java、C++、Python等都是通过共享内存来实现通信），go语言通过goroutine和channel实现通过通信共享内存，这是go语言的独特优势。</p><h4 id="13-channel"><a class="markdownIt-Anchor" href="#13-channel"></a> 1.3 Channel</h4><p>通道channel是用来传递数据的一个数据结构。通道可用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;-用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。</p><p>创建通道，通道分为无缓冲通道和有缓冲通道，在创建时指定参数即可。</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">//无缓冲通道</span></span><br><span class="line">buf := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>) <span class="comment">//有缓冲通道,缓冲区大小为100</span></span><br></pre></td></tr></table></figure></div><p>通道的基本使用</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">//把v发送到通道ch</span></span><br><span class="line">v := &lt;- ch <span class="comment">//从通道ch接收数据,并赋值给v</span></span><br></pre></td></tr></table></figure></div><p>一个示例</p><ul><li><p>一个子协程发送0~9数字</p></li><li><p>另一个子协程计算输入数字的平方</p></li><li><p>主协程输出结果</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CalSqrt</span><span class="params">()</span></span> &#123;</span><br><span class="line">    src := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    dest := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(src)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            src &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(dest)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> src &#123;</span><br><span class="line">            dest &lt;- i * i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dest &#123;</span><br><span class="line">        <span class="built_in">println</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ul><h4 id="14-并发安全-lock"><a class="markdownIt-Anchor" href="#14-并发安全-lock"></a> 1.4 并发安全 Lock</h4><p>对变量执行大量重复操作，使用多个协程并发执行，利用锁来保证最终结果的正确性</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	x    <span class="type">int64</span></span><br><span class="line">    lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addWithLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++ &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        lock.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> addWithLock()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    <span class="built_in">println</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="15-waitgroup"><a class="markdownIt-Anchor" href="#15-waitgroup"></a> 1.5 WaitGroup</h4><p>waitgroup是go语言应用开发过程中经常使用的并发控制技术。其内部通过一个计数器来统计协程，这个计数器的值需要在启动协程之前用Add方法初始化，在结束一个协程的时候使用Done方法将计数器-1</p><p>当开启一个协程时，计数器+1；当一个协程执行完时，计数器-1；主线程会一直阻塞直到计数器为0。</p><p>改造前面的协程快速打印的示例，使用waitgroup实现协程的同步阻塞。</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoWait</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">5</span>)  <span class="comment">//先初始化计数器再启动协程</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            hello(j) <span class="comment">//hello函数参考前面的例子</span></span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="依赖管理"><a class="markdownIt-Anchor" href="#依赖管理"></a> 依赖管理</h2><p>go语言依赖管理的演进路线和go module实践。</p><p>依赖指各种开发包或者库，利用已经封装好的、经过验证的开发组件或工具，能够大大提升开发效率。</p><p>对于简单的程序来说，只需要依赖原生的SDK即可。对于实际工程来说，更多的是关注业务逻辑的实现，涉及框架、日志、驱动driver以及collection等一系列依赖都会通过sdk的方式引入，因此就需要对依赖包进行管理。</p><p>go依赖管理的演进主要经历了3个阶段，从GOPATH到Go Vendor再到目前被广泛应用的Go Module。主要围绕实现两个目标来迭代发展</p><ul><li>不同环境（项目）依赖的版本不同</li><li>控制依赖库的版本</li></ul><h3 id="gopath"><a class="markdownIt-Anchor" href="#gopath"></a> GOPATH</h3><p>GOPATH是go语言支持的一个环境变量，是go项目的工作区。根目录有以下结构</p><ul><li>src：存放go项目的源码</li><li>pkg：存放编译的中间产物，加快编译速度</li><li>bin：存在go项目编译生成的二进制文件</li></ul><p><strong>GOPATH的弊端</strong></p><p>GOPATH无法实现package的多版本控制。同一个pkg，存在两个版本，有两个项目依赖不同的版本，但是src下只能存放一个版本，那么就无法保证两个版本的项目都能通过编译。就是说在GOPATH管理模式下，如果多个项目依赖同一个库，则该库只能是同一份代码，无法实现多个项目依赖同一个库的不同版本。于是Go Vendor应运而生。</p><h3 id="go-vendor"><a class="markdownIt-Anchor" href="#go-vendor"></a> Go Vendor</h3><p>Go Vendor在GOPATH的基础上增加了vendor目录，用于存放当前项目依赖的副本。在Vendor机制下，如果当前目录存在vendor目录，则会优先使用该目录下的依赖，如果依赖不存在，再从GOPATH中寻找。这样，通过每个项目引入一份依赖副本，解决了多个项目需要同一个package依赖的冲突问题。但是vendor无法很好解决依赖包版本变动问题和一个项目依赖同一个包的不同版本的问题。实质上，vendor并不能很清晰地标识依赖的版本概念，无法控制依赖的版本，更新项目又可能导致依赖冲突、编译出错。于是又诞生了Go Module。</p><h3 id="go-module"><a class="markdownIt-Anchor" href="#go-module"></a> Go Module</h3><p>Go Module是go语言官方推出的依赖管理系统，解决了之前依赖管理系统存在的诸多问题。Go Module在go语言1.11版本开始引入，在go语言1.16版本默认开启。习惯上将Go Module称为go mod。</p><ul><li>通过go.mod文件管理依赖包版本</li><li>通过go get/go mod指令工具管理依赖包</li></ul><p>go mod最终目标是定义版本规则和管理项目依赖关系。（相当于Java中的Maven）</p><h3 id="依赖管理三要素"><a class="markdownIt-Anchor" href="#依赖管理三要素"></a> 依赖管理三要素</h3><table><thead><tr><th style="text-align:center">要素</th><th style="text-align:center">对应工具</th></tr></thead><tbody><tr><td style="text-align:center">配置文件，描述依赖</td><td style="text-align:center">go.mod</td></tr><tr><td style="text-align:center">中心仓库管理依赖库</td><td style="text-align:center">Proxy</td></tr><tr><td style="text-align:center">本地工具</td><td style="text-align:center">go get / go mod</td></tr></tbody></table><h3 id="依赖配置go-mod"><a class="markdownIt-Anchor" href="#依赖配置go-mod"></a> 依赖配置——go mod</h3><p>使用模块路径来标识一个模块，从模块路径找到该模块，如果是github前缀则表示可以从github仓库中找到该模块，依赖包的源代码由github托管，如果项目的子包需要被单独引用，则通过单独的init go.mod文件进行管理。</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module example/project/app <span class="comment">//依赖管理基本单元</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.16</span> <span class="comment">//原生sdk版本</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    <span class="comment">// 单元依赖</span></span><br><span class="line">    <span class="comment">// 依赖标识:模块路径+版本</span></span><br><span class="line">	example/lib1 v1<span class="number">.0</span><span class="number">.2</span></span><br><span class="line">    example/lib2 v1<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h3 id="依赖配置version"><a class="markdownIt-Anchor" href="#依赖配置version"></a> 依赖配置——version</h3><p>GOPATH和Go Vendor都是源码副本形式的依赖，没有版本规则的概念，而go mod为了方便管理定义了版本规则，分为语义化版本和基于commit的伪版本。</p><ul><li><p>语义化版本有三个部分<code>$&#123;MAJOR&#125;.$&#123;MINOR&#125;.$&#123;PATCH&#125;</code>，如v1.3.0，v2.3.0</p><p>不同的MAJOR版本表示是不兼容的API，所以即使是同一个库，MAJOR版本不同也会被认为是不同的模块。</p><p>MINOR版本通常是新增函数或功能，向后兼容。</p><p>PATCH版本一般是修复bug。</p></li><li><p>基于commit的伪版本也有三个部分<code>vX.0.0-yyyymmddhhmmss-abcdefgh1234</code></p><p>基础版本前缀和语义化版本是一样的。</p><p>时间戳，也就是提交commit的时间。</p><p>最后是校验码，包含12位的哈希前缀。每次commit后go都会默认生成一个伪版本号。</p></li></ul><h3 id="依赖配置indirect"><a class="markdownIt-Anchor" href="#依赖配置indirect"></a> 依赖配置——indirect</h3><p>依赖单元中的特殊标识符，indirect后缀，表示go.mod对应的当前模块没有直接导入该依赖模块的包，也就是间接依赖。</p><h3 id="依赖配置incompatible"><a class="markdownIt-Anchor" href="#依赖配置incompatible"></a> 依赖配置——incompatible</h3><p>在主版本为v2及以上的模块后面会有+incompatible后缀，这让go mod能够按照不同的模块来处理同一个项目不同主版本的依赖。由于go mod是在go1.11版本才开始引入，在这个更新之前已经有一些仓库打上了v2或者更高的版本tag。为了兼容这部分仓库，对于没有go.mod文件且MAJOR主版本在v2及以上的依赖，会在版本号后面加上<code>+incompatible</code>的后缀，表示可能存在不兼容的源代码。</p><h3 id="依赖配置依赖图"><a class="markdownIt-Anchor" href="#依赖配置依赖图"></a> 依赖配置——依赖图</h3><p>如果一个主项目依赖A、B两个项目，A、B分别依赖C项目v1.3、v1.4的两个版本，则最终编译时所使用的C项目版本为最低的兼容版本，即v1.4。</p><h3 id="依赖分发回源"><a class="markdownIt-Anchor" href="#依赖分发回源"></a> 依赖分发——回源</h3><p>依赖分发，也就是指go mod从哪里下载，如何下载。</p><p>Go Modules系统中定义的依赖最终可以对应到多版本代码管理系统中某一项目的特定提交或版本，这样的话，对于go.mod中定义的依赖，则直接可以从对应仓库中下载指定软件依赖，从而完成依赖分发。</p><p>但直接使用版本管理仓库下载依赖，存在诸多问题</p><ul><li>无法保证构建确定性，软件作者可以直接在代码平台 增加/修改/删除 软件版本，导致下次构建时使用另外版本的依赖或者找不到依赖版本。</li><li>无法保证依赖可用性，依赖软件作者可以直接在代码平台删除软件，导致依赖不可用。</li><li>增加第三方压力，每次从第三方代码托管平台下载依赖时都会增加第三方代码托管平台的压力。</li></ul><h3 id="依赖分发proxy"><a class="markdownIt-Anchor" href="#依赖分发proxy"></a> 依赖分发——Proxy</h3><p>Go Proxy就是解决上述的依赖分发问题。Go Proxy是一个服务站点，它会缓存源站中的软件内容，缓存的软件版本不会改变，并且在源站软件删除之后依然能够下载，从而实现了immutability（不变性）和available（可用的）的依赖分发。</p><p>使用Go Proxy之后，构建时会直接从Go Proxy站点拉取依赖。</p><h3 id="依赖分发变量-goproxy"><a class="markdownIt-Anchor" href="#依赖分发变量-goproxy"></a> 依赖分发——变量 GOPROXY</h3><p>Go Modules通过GOPROXY环境变量使用Go Proxy服务。GOPROXY是一个Go Proxy站点URL列表，可以使用&quot;direct&quot;表示源站。</p><p>示例配置</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOPROXY=<span class="string">&quot;https://proxy1.cn, https://proxy2.cn, direct&quot;</span></span><br></pre></td></tr></table></figure></div><p>对于以上配置，整体的依赖寻址路径会先从proxy1下载，如果proxy1不存在，再从proxy2寻找，如果proxy2不存在，则回源到源站直接下载依赖，并缓存到proxy站点中。</p><h3 id="工具go-get"><a class="markdownIt-Anchor" href="#工具go-get"></a> 工具——go get</h3><p>go get是Go Module的两个重要工具之一。</p><p>go get使用命令</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get example.org/pkg...</span><br></pre></td></tr></table></figure></div><p>以上命令后面接不同的指令，这些指令具有不同的作用</p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">@update</td><td style="text-align:center">默认</td></tr><tr><td style="text-align:center">@none</td><td style="text-align:center">删除依赖</td></tr><tr><td style="text-align:center">@v1.1.2</td><td style="text-align:center">下载指定tag版本，语义版本</td></tr><tr><td style="text-align:center">@23dfdd5</td><td style="text-align:center">特定的commit</td></tr><tr><td style="text-align:center">@master</td><td style="text-align:center">分支的最新commit</td></tr></tbody></table><h3 id="工具go-mod"><a class="markdownIt-Anchor" href="#工具go-mod"></a> 工具——go mod</h3><p>go mod也是Go Module中的重要工具。</p><p>go mod 使用命令</p><p>初始化，创建go.mod文件</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init</span><br></pre></td></tr></table></figure></div><p>下载模块到本地缓存</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod download</span><br></pre></td></tr></table></figure></div><p>增加需要的依赖，删除不需要的依赖</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure></div><p>在实际开发中，建议在向仓库提交代码之前执行<code>go mod tidy</code>，可以减少构建时无效依赖包的拉取。</p><p><strong>使用go mod前的一些注意事项</strong></p><ul><li>设置GO111MODULE=on，表示只使用Go Module而不会使用GOPATH。具体配置参考<a class="link" target="_blank" rel="noopener" href="https://goproxy.cn/">七牛云 - Goproxy.cn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>清空IDE中的所有的GOPATH。go mod和GOPATH不能并存，开启go mod之后需要在IDE中把项目从GOPATH移除，否则可能会出错。</li><li>在项目中创建go.mod文件，如果已经存在则不需要重新创建。创建完go.mod文件后先执行<code>go mod tidy</code>来增加项目启动所需的最小依赖。</li></ul><h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2><p>在实际工程开发中，除了依赖管理，还有另一个重要概念就是单元测试，包括单元测试规范、Mock测试、基准测试。测试关系着系统的质量，质量决定线上系统的稳定性，一旦出现问题就会引起事故。测试就是为了避免这些事故。</p><p>测试一般分为回归测试，集成测试和单元测试。回归测试一般是手动通过终端回归一些固定的主流场景，集成测试是对系统功能维度做测试验证，而单元测试阶段，开发者对单独的函数、模块做功能验证，层级至上而下，测试成本逐渐降低，测试覆盖率逐步上升。因此单元测试的覆盖率一定程度上决定了代码的质量。</p><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><p>单元测试主要包括输入、测试单元、输出，以及校对。单元的概念比较广泛，包括接口、函数、模块等。最后的校对用于保证代码的功能符合预期。单元测试一方面可以保证质量，在整体覆盖率足够的情况下，一定程度上即保证了新功能本身的正确性，又保护了原有代码的完整性；另一方面可以提升效率，在代码存在bug的情况下，通过单元测试，可以在较短周期内定位和修复问题。</p><h4 id="规则"><a class="markdownIt-Anchor" href="#规则"></a> 规则</h4><p>单元测试的一些基本规范</p><ul><li>所有测试文件名称以_test.go结尾</li><li>所有用于测试的函数声明为<code>func TestXxx(t *testing.T)</code></li><li>初始化逻辑放到TestMain函数中实现</li></ul><p>这样就很好地区分了源代码和测试代码。</p><h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h4><p>源代码</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloTom</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>测试代码</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHelloTom</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    output := HelloTom()</span><br><span class="line">    expectOutput := <span class="string">&quot;Tom&quot;</span></span><br><span class="line">    <span class="keyword">if</span> output != expectOutput &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;Expected %s do not match actual %s&quot;</span>, expectOutput, output)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h4><p>运行查看结果</p><h4 id="assert"><a class="markdownIt-Anchor" href="#assert"></a> assert</h4><p>assert包提供了对代码测试的支持，能够快速方便地进行代码测试</p><p>获取assert包，在当前项目中使用以下命令</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/stretchr/testify/assert</span><br></pre></td></tr></table></figure></div><p>改造原来的测试代码</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHelloTom</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    output := HelloTom()</span><br><span class="line">    expectOutput := <span class="string">&quot;Tom&quot;</span></span><br><span class="line">    assert.Equal(t, expectOutput, output)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行查看结果，使用assert测试能够输出更加详细的信息。</p><h4 id="覆盖率"><a class="markdownIt-Anchor" href="#覆盖率"></a> 覆盖率</h4><p>代码覆盖率用于衡量代码是否经过了足够的测试，评价项目的测试水准，评估项目是否达到了高水准测试等级。</p><p><strong>示例代码</strong></p><p>judgment.go</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JudgePassLine</span><span class="params">(score <span class="type">int16</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> score &gt;= <span class="number">60</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>judgment_test.go</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestJudgePassLineTrue</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    isPass := JudgePassLine(<span class="number">70</span>)</span><br><span class="line">    assert.Equal(t, <span class="literal">true</span>, isPass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>使用以下命令进行测试</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> judgment_test.go judgment.go --cover</span><br></pre></td></tr></table></figure></div><p>通过指定cover参数，可以看到覆盖率，表示执行到的代码行数占实际代码总行数。</p><p><strong>提升覆盖率</strong></p><p>可以在测试代码中增加其他的情况，重新执行所有单元测试，最终使覆盖率达到100%</p><p>新增测试函数</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestJudgePassLineFail</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    isPass := JudgePassLine(<span class="number">50</span>)</span><br><span class="line">    assert.Equal(t, <span class="literal">false</span>, isPass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>重新执行测试命令，指定cover参数，查看测试结果。</p><h4 id="tips"><a class="markdownIt-Anchor" href="#tips"></a> Tips</h4><ul><li>实际项目中，一般要求覆盖率是50%~60%，对于资金型服务，覆盖率要求达到80%以上。</li><li>在进行单元测试时，要求测试分支相互独立、全面覆盖。</li><li>测试单元粒度足够小，函数职责单一，即要求函数体足够小，这样能比较简单地提升覆盖率，也符合函数设计的单一职责。</li></ul><h3 id="mock测试"><a class="markdownIt-Anchor" href="#mock测试"></a> Mock测试</h3><p>工程中复杂的项目一般会依赖File、DB、Cache等外部依赖，而单元测试需要保证稳定性和幂等性。稳定性指相互隔离，能在任何时间、任何环境下运行测试；幂等是指每次测试运行都应该产生与之前一样的结果。而实现这些目的就需要Mock机制。</p><h4 id="文件处理"><a class="markdownIt-Anchor" href="#文件处理"></a> 文件处理</h4><p>将测试文件进行删除，进行单元测试，测试通过，但单元测试需要依赖本地的文件，如果文件被修改或者删除测试就会失败，也就是说删除文件的测试普通情况下只能测试一次。为了保证测试case的稳定性，需要对删除文件函数进行mock，屏蔽对文件的依赖。</p><h4 id="快速mock函数"><a class="markdownIt-Anchor" href="#快速mock函数"></a> 快速Mock函数</h4><p>这里提供了一个开源的mock测试库<a class="link" target="_blank" rel="noopener" href="https://github.com/bouk/monkey">Monkey patching in Go <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，可以对函数或者实例的方法进行mock测试，原理是反射和指针赋值。这里引入了一个打桩的概念，桩或者桩代码就是指用来代替关联代码或者未实现代码的代码，目的主要是隔离、补齐、控制。</p><p>快速Mock函数能为一个函数打桩或为一个方法打桩。Monkey Patch的作用域在Runtime，在运行时通过Go的unsafe包，能够将内存中函数的地址替换为运行时函数的地址，将待打桩函数或方法的实现跳转到运行时。</p><h4 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h4><p>通过patch对ReadFirstLine进行打桩mock，通过defer卸载mock，使整个测试函数脱离了对本地文件的依赖。</p><p>源代码</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFirstLine</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    open, err := os.Open(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> open.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    scanner := bufio.NewScanner(open)</span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        <span class="keyword">return</span> scanner.Text()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessFirstLine</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    line := ReadFirstLine()</span><br><span class="line">    destLine := strings.ReplaceAll(line, <span class="string">&quot;11&quot;</span>, <span class="string">&quot;00&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> destLine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>测试代码</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestProcessFirstLine</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    firstLine := ProcessFirstLine()</span><br><span class="line">    assert.Equal(t, <span class="string">&quot;line00&quot;</span>, firstLine)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>测试文件内容</p><div class="highlight-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">line11</span><br><span class="line">line22</span><br><span class="line">line33</span><br><span class="line">line44</span><br><span class="line">line55</span><br></pre></td></tr></table></figure></div><p>monkey的部分源代码实现，主要通过这些函数实现打桩</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Patch</span><span class="params">(target, replacement <span class="keyword">interface</span>&#123;&#125;)</span></span> *PatchGuard &#123;</span><br><span class="line">    t := reflect.ValueOf(target)</span><br><span class="line">    r := reflect.ValueOf(replacement)</span><br><span class="line">    patchValue(t, r)</span><br><span class="line">    <span class="keyword">return</span> &amp;PatchGuard&#123;t, r&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unpatch</span><span class="params">(target <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unpatchValue(reflect.ValueOf(target))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>改造测试代码增加函数实现打桩，通过patch对ReadFirstLine进行打桩mock，使其默认返回line110</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReadFirstLineWithMock</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	monkey.Patch(ReadFirstLine, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;line110&quot;</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">defer</span> monkey.Unpatch(ReadFirstLine)</span><br><span class="line">	line := ProcessFirstLine()</span><br><span class="line">	assert.Equal(t, <span class="string">&quot;line000&quot;</span>, line)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这样即使没有本地文件，也能够模拟读取、修改或删除文件的测试。</p><h3 id="基准测试"><a class="markdownIt-Anchor" href="#基准测试"></a> 基准测试</h3><p>go语言还提供了基准测试框架，基准测试是指测试一段程序的运行性能及耗费CPU的程度。在实际项目开发中，经常会遇到代码性能瓶颈，为了定位问题经常要对代码做性能分析，这就用到了基准测试。</p><h4 id="示例-3"><a class="markdownIt-Anchor" href="#示例-3"></a> 示例</h4><p>服务器负载均衡问题。</p><p>源代码，假设有10台服务器，每次随机选择其中1台执行。</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitServerIndex</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		ServerIndex[i] = i + <span class="number">100</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Select</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ServerIndex[rand.Intn(<span class="number">10</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>测试代码，基准测试以Benchmark开头，参数类型是testing.B，用b中的N值反复递增循环测试。基准测试对于一个测试用例的默认测试时间是1秒，当测试用例函数返回时还不到1秒，那么testing.B中的N值将按1、2、5、10、20、50…递增，并以递增后的值重新进行用例函数测试。</p><p>ResetTimer重置计时器，在重置之前的初始化或其他准备操作，不属于基准测试的范围，通过选择重置的时间点来跳过不必要的测试。</p><p>RunParallel是多协程并发测试。执行两个基准测试，可以发现代码在并发情况下存在劣化，主要原因是rand包为了保证全局的随机性和并发安全，使用了全局锁。</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSelect</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	InitServerIndex()</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		Select()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSelectParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	InitServerIndex()</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			Select()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="运行-2"><a class="markdownIt-Anchor" href="#运行-2"></a> 运行</h4><p>在IDE中使用<code>gobench benchmark</code>选项进行测试，不要直接运行。</p><h4 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h4><p>为了解决上述的随机性能瓶颈问题，有一个开源的高性能随机数方法fastrand，仓库地址<a class="link" target="_blank" rel="noopener" href="https://github.com/bytedance/gopkg">bytedance/gopkg <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。主要思路是牺牲了一定的数列一致性来换取性能，在大多数场景下适用，相比原始方法的性能有大幅提升。</p><p>引入fastrand</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/bytedance/gopkg</span><br></pre></td></tr></table></figure></div><p>将源代码中的rand替换为fastrand即可。</p><h2 id="项目实战"><a class="markdownIt-Anchor" href="#项目实战"></a> 项目实战</h2><p>在并发编程，依赖管理以及单元测试的基础上，通过项目实践来理解项目开发的思路和流程，主要包括需求设计，代码开发和测试运行。</p><h3 id="需求设计"><a class="markdownIt-Anchor" href="#需求设计"></a> 需求设计</h3><h4 id="需求背景"><a class="markdownIt-Anchor" href="#需求背景"></a> 需求背景</h4><p>开发一个类似掘金社区的服务端小功能。</p><h4 id="需求描述"><a class="markdownIt-Anchor" href="#需求描述"></a> 需求描述</h4><p>社区话题页面</p><ul><li>展示话题（标题、文字描述）和回帖列表</li><li>暂不考虑前端页面实现，仅仅实现一个本地web服务</li><li>话题和回帖数据用文件存储</li></ul><h4 id="需求用例"><a class="markdownIt-Anchor" href="#需求用例"></a> 需求用例</h4><p>主要涉及用户浏览消费，页面的展示，包括话题内容和回帖的列表。可以先抽象出两个实体，话题内容和回帖列表，分析它们所具有的属性以及联系，定义出结构体。</p><h4 id="er-图entity-relationship-diagram"><a class="markdownIt-Anchor" href="#er-图entity-relationship-diagram"></a> ER 图——Entity Relationship Diagram</h4><p>ER图用于描述现实世界的概念模型。有了模型实体、属性以及联系，就能进入下一步，思考代码结构设计。</p><p>参考ER图设计：Topic话题有id、titile、content、create_time四个属性。Post帖子有id、topic_id、content、create_time四个属性，其中id和topic_id和Topic相联系。</p><p>这里采用典型的分层结构设计。</p><h3 id="代码开发"><a class="markdownIt-Anchor" href="#代码开发"></a> 代码开发</h3><h4 id="分层结构"><a class="markdownIt-Anchor" href="#分层结构"></a> 分层结构</h4><p>分层结构整体分为三层，repository数据层，service逻辑层，controller视图层。</p><ul><li>数据层关联底层数据模型，也就是model，封装外部数据的增删改查。这里的数据存储在本地文件，通过文件操作拉取话题，帖子数据。</li><li>数据层面向逻辑层，也就是对service层透明，屏蔽下游数据差异，即逻辑层不需要考虑数据的来源是本地文件、数据库还是微服务等。逻辑层只处理核心业务逻辑，接口模型保持不变，计算打包业务实体Entity，对应需求并上传给视图层。</li><li>视图层controller负责处理与外部交互的逻辑，以view视图的形式返回给客户端。这里只考虑封装为json格式化的请求结果，通过API形式访问即可。</li></ul><h4 id="组件工具"><a class="markdownIt-Anchor" href="#组件工具"></a> 组件工具</h4><p>开发涉及的基础组件工具。Gin：开源的高性能go web框架，源地址<a class="link" target="_blank" rel="noopener" href="https://github.com/gin-gonic/gin">gin-gonic <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。这里基于gin搭建web服务器，本项目主要涉及路由分发的概念，不涉及其他复杂概念。</p><p>使用web框架，需要用Go Module依赖管理。先用go mod init初始化go.mod管理配置文件。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go mod init main</span><br><span class="line">go mod tidy</span><br></pre></td></tr></table></figure></div><p>下载gin依赖</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure></div><p>在框架依赖的基础上，只需要关注业务本身的实现，从repository到service再到controller逐步实现。</p><h4 id="repository"><a class="markdownIt-Anchor" href="#repository"></a> Repository</h4><h5 id="struct"><a class="markdownIt-Anchor" href="#struct"></a> struct</h5><p>根据之前的ER图定义结构体</p><h5 id="index"><a class="markdownIt-Anchor" href="#index"></a> index</h5><p>查询数据可以使用全扫描遍历的方式，但是效率不高，所以这里引入索引的概念。</p><p>索引就像书的目录，可以快速查找定位到需要的结果。这里利用map实现内存索引，在服务对外暴露前，利用文件元数据初始化全局内存索引，实现O(1)时间复杂度的查找操作。</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	topicIndexMap <span class="keyword">map</span>[<span class="type">int64</span>]*Topic</span><br><span class="line">    postIndexMap  <span class="keyword">map</span>[<span class="type">int64</span>][]*Post</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>具体实现，打开文件，基于file初始化scanner，通过迭代器方式遍历数据行，转化为结构体存储至内存map，完成初始化话题内存索引。同理实现帖子的内存索引初始化</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initTopicIndexMap</span><span class="params">(filePath <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    open, err := os.Open(filePath + <span class="string">&quot;topic&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    scanner := bufio.NewScanner(open)</span><br><span class="line">    topicTmpMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]*Topic)</span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        text := scanner.Text()</span><br><span class="line">        <span class="keyword">var</span> topic Topic</span><br><span class="line">        <span class="keyword">if</span> err := json.Unmarshal([]<span class="type">byte</span>(text), &amp;topic); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        topicTmpMap[topic.Id] = &amp;topic</span><br><span class="line">    &#125;</span><br><span class="line">    topicIndexMap = topicTmpMap</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h5><p>实现查询操作，直接查询key获取map中的value。这里使用了sync.Once，主要适用于高并发的情况下只执行一次的场景。基于Once的实现模式就是单例模式，减少存储的浪费。</p><p>topic查询实现，这里的topic结构体自行设计。同理实现post的查询</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TopicDao <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	topicDao  *TopicDao</span><br><span class="line">    topicOnce sync.Once</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTopicDaoInstance</span><span class="params">()</span></span> *TopicDao &#123;</span><br><span class="line">    topicOnce.Do(</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            topicDao = &amp;TopicDao&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">return</span> topicDao</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*TopicDao)</span></span> QueryTopicById(id <span class="type">int64</span>) *Topic &#123;</span><br><span class="line">    <span class="keyword">return</span> topicIndexMap[id]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="service"><a class="markdownIt-Anchor" href="#service"></a> Service</h4><p>实现了repository层之后就是service层。</p><p>定义service层实体</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PageInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Topic *repository.Topic</span><br><span class="line">    PostList []*repository.Post</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>实现流程是参数校验、准备数据、组装实体。</p><p>代码流程编排，通过err控制流程退出，正常的话会返回页面信息。</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *QueryPageInfoFlow)</span></span> Do() (*PageInfo, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> err := f.checkParam(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := f.prepareInfo(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := f.packPageInfo(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f.pageInfo, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>prepareInfo方法实现，由于话题和回帖信息的获取都需要topicId，这就可以考虑并行执行，提高效率。并行可以充分利用多核CPU的资源，降低接口耗时。</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *QueryPageInfoFlow)</span></span> prepareInfo() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;...&#125; <span class="comment">//获取topic信息</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;...&#125; <span class="comment">//获取post列表</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="controller"><a class="markdownIt-Anchor" href="#controller"></a> Controller</h4><p>service层之后是controller层。定义一个view对象，通过code msg打包业务状态信息，用data承载业务实体信息。</p><p>参考代码</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PageData <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code <span class="type">int64</span>       <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">    Msg  <span class="type">string</span>      <span class="string">`json:&quot;msg&quot;`</span></span><br><span class="line">    Data <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QueryPageInfo</span><span class="params">(topicIdStr <span class="type">string</span>)</span></span> *PageData &#123;</span><br><span class="line">    topicId, err := strconv.ParseInt(topicIdStr, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;...&#125;</span><br><span class="line">    pageInfo, err := service.QueryPageInfo(topicId)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;PageData&#123;</span><br><span class="line">        Code: <span class="number">0</span>,</span><br><span class="line">        Msg: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">        Data: <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>&#123;</span><br><span class="line">            <span class="string">&quot;post_id&quot;</span>: postId,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="router"><a class="markdownIt-Anchor" href="#router"></a> Router</h4><p>最后是web服务的引擎配置，包括</p><ul><li>初始化数据索引</li><li>初始化引擎配置</li><li>构建路由</li><li>启动服务</li></ul><p>path映射到具体的controller，通过path变量传递话题id。</p><p>参考写法</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := Init(<span class="string">&quot;./data/&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        os.Exit(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/community/page/get/:id&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        topicId := c.Param(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">        data := controller.QueryPageInfo(topicId)</span><br><span class="line">        c.JSON(<span class="number">200</span>, data)</span><br><span class="line">    &#125;)</span><br><span class="line">    err := r.Run()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="测试运行"><a class="markdownIt-Anchor" href="#测试运行"></a> 测试运行</h3><p>通过go run命令运行本地web服务，main.go是这里main方法所在的go文件，文件名称可以自定义</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure></div><p>通过curl命令请求服务暴露的接口，查看结果。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --location --request GET <span class="string">&quot;http://0.0.0.0:8080/community/get/1&quot;</span> | json</span><br></pre></td></tr></table></figure></div><p>这里的json命令是通过nodejs的npm安装的，用于格式化curl输出的json信息。</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g json</span><br></pre></td></tr></table></figure></div><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a class="link" target="_blank" rel="noopener" href="https://www.cnblogs.com/gizing/p/10925286.html">用户态和内核态的区别 - Gizing - 博客园 (cnblogs.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><a class="link" target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018150987">Go goroutine理解 - golang开发笔记 - SegmentFault 思否 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><a class="link" target="_blank" rel="noopener" href="https://www.runoob.com/go/go-concurrent.html">Go 并发 | 菜鸟教程 (runoob.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><a class="link" target="_blank" rel="noopener" href="https://juejin.cn/post/7181812988461252667">深入理解 go sync.Waitgroup - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/Sihang_Xie/article/details/124851399">【Go语言入门】一文搞懂Go语言的最新依赖管理：go mod的使用 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li><strong>标题:</strong> Go 工程进阶</li><li><strong>作者:</strong> Entropy</li><li><strong>创建于:</strong> 2023-01-26 18:01:52</li><li><strong>更新于:</strong> 2023-04-01 07:55:52</li><li><strong>链接:</strong> https://entropy-tree.top/2023/01/26/golang-day2/</li><li><strong>版权声明:</strong> 本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a> 进行许可。</li></ul></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">#学习笔记</a>&nbsp;</li><li class="tag-item"><a href="/tags/golang/">#golang</a>&nbsp;</li></ul><div class="recommended-article"><div class="recommended-desktop"><div class="recommended-article-header"><i aria-hidden="true"></i><span>推荐阅读</span></div><div class="recommended-article-group"><a class="recommended-article-item" href="/2023/01/26/golang-day1/" title="Go语言基础" rel="bookmark"><img src="/images/wallhaven-wqery6-light.webp" alt="Go语言基础"> <span class="title">Go语言基础</span> </a><a class="recommended-article-item" href="/2023/02/01/golang-day5/" title="Go 框架三件套详解" rel="bookmark"><img src="/images/wallhaven-wqery6-light.webp" alt="Go 框架三件套详解"> <span class="title">Go 框架三件套详解</span> </a><a class="recommended-article-item" href="/2023/01/28/golang-day3/" title="Go 高质量编程与性能调优" rel="bookmark"><img src="/images/wallhaven-wqery6-light.webp" alt="Go 高质量编程与性能调优"> <span class="title">Go 高质量编程与性能调优</span></a></div></div><div class="recommended-mobile"><div class="recommended-article-header"><i aria-hidden="true"></i><span>推荐阅读</span></div><div class="recommended-article-group"><a class="recommended-article-item" href="/2023/01/26/golang-day1/" title="Go语言基础" rel="bookmark"><img src="/images/wallhaven-wqery6-light.webp" alt="Go语言基础"> <span class="title">Go语言基础</span> </a><a class="recommended-article-item" href="/2023/02/01/golang-day5/" title="Go 框架三件套详解" rel="bookmark"><img src="/images/wallhaven-wqery6-light.webp" alt="Go 框架三件套详解"> <span class="title">Go 框架三件套详解</span></a></div></div></div><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2023/01/28/golang-day3/"><span class="left arrow-icon flex-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">Go 高质量编程与性能调优</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2023/01/26/golang-day1/"><span class="title flex-center"><span class="post-nav-title-item">Go语言基础</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comment-anchor"></div><div class="comment-area-title"><i class="fa-solid fa-comments"></i>&nbsp;评论</div><div id="waline"></div><script type="module" data-pjax>import{init}from"https://evan.beee.top/js/waline.mjs";function loadWaline(){init({el:"#waline",serverURL:"https://comment.entropy-tree.top",lang:"zh-CN",dark:'body[class~="dark-mode"]',requiredMeta:["nick","mail"]})}{const e=setTimeout(()=>{loadWaline(),clearTimeout(e)},1e3)}</script></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">此页目录</div><div class="page-title">Go 工程进阶</div><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6"><span class="nav-text">语言进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E5%B9%B6%E5%8F%91-vs-%E5%B9%B6%E8%A1%8C"><span class="nav-text">1.并发 VS 并行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="nav-text">依赖管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gopath"><span class="nav-text">GOPATH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go-vendor"><span class="nav-text">Go Vendor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go-module"><span class="nav-text">Go Module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-text">依赖管理三要素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AEgo-mod"><span class="nav-text">依赖配置——go mod</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AEversion"><span class="nav-text">依赖配置——version</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AEindirect"><span class="nav-text">依赖配置——indirect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AEincompatible"><span class="nav-text">依赖配置——incompatible</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE%E4%BE%9D%E8%B5%96%E5%9B%BE"><span class="nav-text">依赖配置——依赖图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%88%86%E5%8F%91%E5%9B%9E%E6%BA%90"><span class="nav-text">依赖分发——回源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%88%86%E5%8F%91proxy"><span class="nav-text">依赖分发——Proxy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%88%86%E5%8F%91%E5%8F%98%E9%87%8F-goproxy"><span class="nav-text">依赖分发——变量 GOPROXY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7go-get"><span class="nav-text">工具——go get</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7go-mod"><span class="nav-text">工具——go mod</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-text">测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-text">单元测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mock%E6%B5%8B%E8%AF%95"><span class="nav-text">Mock测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="nav-text">基准测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98"><span class="nav-text">项目实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E8%AE%BE%E8%AE%A1"><span class="nav-text">需求设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91"><span class="nav-text">代码开发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E8%BF%90%E8%A1%8C"><span class="nav-text">测试运行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer"><div class="info-container"><div class="copyright-info">&copy; <span>2022</span> - 2023&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">Entropy</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">访问人数&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item"><span class="powered-by-container">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a> 驱动</span><br><span class="theme-version-container">主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.2.2</a></span></div><div>博客已运行 <span class="odometer" id="runtime_days"></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒</div><script async data-pjax>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-expand-width flex-center"><i class="fa-regular fa-expand"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fa-regular fa-rss"></i></a></li><li class="right-bottom-tools tool-scroll-to-top flex-center"><i class="fa-regular fa-arrow-up"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex-center"><i class="fa-regular fa-cog fa-spin"></i></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/layouts/navbarShrink.js"></script><script src="/js/tools/scrollTopBottom.js"></script><script src="/js/tools/lightDarkSwitch.js"></script><script src="/js/tools/localSearch.js"></script><script src="/js/tools/codeBlock.js"></script><script src="/js/layouts/lazyload.js"></script><script src="/js/tools/runtime.js"></script><script src="/js/libs/odometer.min.js"></script><link rel="stylesheet" href="/assets/odometer-theme-minimal.css"><script src="/js/libs/Typed.min.js"></script><script src="/js/plugins/typed.js"></script><div class="post-scripts pjax"><script src="/js/tools/tocToggle.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/layouts/toc.js"></script><script src="/js/plugins/tabs.js"></script></div><script src="/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{Global.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{Global.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),Global.refresh()})})</script><div id="aplayer"></div><script src="/js/libs/APlayer.min.js"></script><script src="/js/plugins/aplayer.js"></script></body></html>