<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Entropy Tree</title>
  
  <subtitle>the truth of life</subtitle>
  <link href="https://s-chance.github.io/atom.xml" rel="self"/>
  
  <link href="https://s-chance.github.io/"/>
  <updated>2023-02-01T09:17:11.657Z</updated>
  <id>https://s-chance.github.io/</id>
  
  <author>
    <name>Entropy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go 语言内存管理详解</title>
    <link href="https://s-chance.github.io/2023/01/30/golang-day4/"/>
    <id>https://s-chance.github.io/2023/01/30/golang-day4/</id>
    <published>2023-01-30T13:23:29.000Z</published>
    <updated>2023-02-01T09:17:11.657Z</updated>
    
    <content type="html"><![CDATA[<p>本文已收录到<a href="https://juejin.cn/post/7194838118955450428">Go 语言内存管理详解 | 青训营笔记 - 掘金 (juejin.cn)</a>，主要记录了对golang内存管理的学习<span id="more"></span></p><h2 id="内存管理详解"><a class="markdownIt-Anchor" href="#内存管理详解"></a> 内存管理详解</h2><h3 id="追求极致性能"><a class="markdownIt-Anchor" href="#追求极致性能"></a> 追求极致性能</h3><p>性能优化：提升软件系统处理能力，减少不必要的消耗，充分发掘计算机算力。</p><p>性能优化的目的</p><ul><li>用户体验：带来用户体验的提升</li><li>资源高效利用：降低成本。提高效率</li></ul><h3 id="性能优化的层面"><a class="markdownIt-Anchor" href="#性能优化的层面"></a> 性能优化的层面</h3><ul><li>业务层优化<ul><li>针对特定场景，具体问题具体分析</li><li>容易获得较大性能收益</li></ul></li><li>语言运行时优化<ul><li>解决更通用的性能问题</li><li>考虑更多场景</li><li>Tradeoffs权衡</li></ul></li><li>数据驱动<ul><li>自动化性能分析工具——pprof</li><li>依靠数据而非猜测</li><li>首先优化最大瓶颈</li></ul></li></ul><h3 id="性能优化与软件质量"><a class="markdownIt-Anchor" href="#性能优化与软件质量"></a> 性能优化与软件质量</h3><ul><li>软件质量至关重要</li><li>在保证接口稳定的前提下改进具体实现</li><li>测试用例：覆盖尽可能多的场景，方便回归</li><li>文档：做了什么，没做什么，能达到怎样的效果</li><li>隔离：通过选项控制是否开启优化</li><li>可观测：必要的日志输出</li></ul><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li>性能优化的基本问题</li><li>性能优化的两个层面</li><li>性能优化的可维护性</li></ul><h3 id="1自动内存管理"><a class="markdownIt-Anchor" href="#1自动内存管理"></a> 1.自动内存管理</h3><h4 id="11-自动内存管理"><a class="markdownIt-Anchor" href="#11-自动内存管理"></a> 1.1 自动内存管理</h4><ul><li>动态内存<ul><li>程序在运行时根据需求动态分配的内存：malloc()</li></ul></li><li>自动内存管理（垃圾回收）：由程序语言的运行时系统管理动态内存<ul><li>避免手动内存管理，专注于实现业务逻辑</li><li>保证内存使用的正确性和安全性：double-free problem，use-after-free problem</li></ul></li><li>三个任务<ul><li>为新对象分配空间</li><li>找到存活对象</li><li>回收死亡对象的内存空间</li></ul></li></ul><p><strong>相关概念</strong></p><ul><li><p>Mutator：业务线程，分配新对象，修改对象的指向关系</p></li><li><p>Collector：GC线程，找到存活对象，回收死亡对象的内存空间</p></li><li><p>Serial GC：只有一个collector</p></li><li><p>Parallel GC：支持多个collector同时回收的GC算法</p></li><li><p>Concurrent GC：mutator(s)和collector(s)可以同时执行</p></li><li><p>Collectors必须感知对象指向关系的改变</p></li><li><p>评价GC算法</p><ul><li>安全性（Safety）：不能回收存活的对象。这是基本要求</li><li>吞吐率（Throughput）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>−</mo><mfrac><mrow><mi>G</mi><mi>C</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi></mrow><mrow><mi mathvariant="normal">程</mi><mi mathvariant="normal">序</mi><mi mathvariant="normal">执</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">总</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">1-\frac {GC时间}{程序执行总时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">程</span><span class="mord cjk_fallback mtight">序</span><span class="mord cjk_fallback mtight">执</span><span class="mord cjk_fallback mtight">行</span><span class="mord cjk_fallback mtight">总</span><span class="mord cjk_fallback mtight">时</span><span class="mord cjk_fallback mtight">间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback mtight">时</span><span class="mord cjk_fallback mtight">间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。花在GC上的时间</li><li>暂停时间（Pause time）：stop the world（STW）。业务是否感知</li><li>内存开销（Space overhead）：GC元数据开销</li></ul></li><li><p>追踪垃圾回收（Tracing garbage collection）</p></li><li><p>引用计数（Reference counting）</p></li></ul><h4 id="12-追踪垃圾回收"><a class="markdownIt-Anchor" href="#12-追踪垃圾回收"></a> 1.2 追踪垃圾回收</h4><ul><li><p>对象被回收的条件：指针指向关系不可达的对象</p></li><li><p>标记根对象</p><ul><li>静态变量、全局变量、常量、线程栈等</li></ul></li><li><p>标记：找到可达对象</p><ul><li>求指针指向关系的传递闭包：从根对象出发，找到所有可达对象</li></ul></li><li><p>清理：所有不可达对象</p><ul><li><p>将存活对象复制到另外的内存空间（Copying GC）</p><p>Copying GC：将对象复制到另外的内存空间</p></li><li><p>将死亡对象的内存标记为“可分配”（Mark-sweep GC）</p><p>Mark-sweep GC：使用free list管理空闲内存</p></li><li><p>移动并整理存活对象（Mark-compact GC）</p><p>Compact GC：原地整理对象</p></li></ul></li><li><p>根据对象的生命周期，使用不同的标记和清理策略</p></li></ul><h4 id="13-分代-gcgenerational-gc"><a class="markdownIt-Anchor" href="#13-分代-gcgenerational-gc"></a> 1.3 分代 GC（Generational GC）</h4><ul><li>分代假说（Generational hypothesis）：most objects die young</li><li>Intuition：很多对象在分配出来后很快就不在使用了</li><li>每个对象都有年龄：经历过GC的次数</li><li>目的：对年轻和年老的对象，制定不同的GC策略，降低整体内存管理的开销</li><li>不同年龄的对象处于heap的不同区域</li><li>年轻代（Young generation）<ul><li>常规的对象分配</li><li>由于存活对象很少，可以采用copying collection</li><li>GC吞吐率很高</li></ul></li><li>老年代（Old generation）<ul><li>对象趋向一直活着，反复复制开销较大</li><li>可以采用mark-sweep collection</li></ul></li></ul><h4 id="14-引用计数"><a class="markdownIt-Anchor" href="#14-引用计数"></a> 1.4 引用计数</h4><ul><li>每个对象都有一个与之关联的引用数目</li><li>对象存活的条件：当且仅当引用数大于0</li><li>优点<ul><li>内存管理的操作被平摊到程序执行过程中</li><li>内存管理不需要了解runtime的实现细节：C++智能指针（smart pointer）</li></ul></li><li>缺点<ul><li>维护引用计数的开销较大：通过原子操作保证对引用计数操作的原子性和可见性</li><li>无法回收环形数据结构——weak reference</li><li>内存开销：每个对象都引入的额外内存空间存储引用数目</li><li>回收内存时依然可能引发暂停</li></ul></li></ul><h4 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h4><ul><li>自动内存管理的背景和意义</li><li>概念和评价方法</li><li>追踪垃圾回收</li><li>引用计数</li><li>分代 GC</li><li>学术界和工业界一直致力于解决自动内存管理技术的不足之处<ul><li>相关信息<a href="https://pldi22.sigplan.org/details/pldi-2022-pldi/15/Low-Latency-High-Throughput-Garbage-Collection">Low-Latency, High-Throughput Garbage Collection (PLDI 2022 - PLDI Research Papers) </a></li><li>相关介绍<a href="https://zhuanlan.zhihu.com/p/525093935">PLDI’22 | June 13-17，编程语言顶级会议</a></li></ul></li></ul><h3 id="2go管理及优化"><a class="markdownIt-Anchor" href="#2go管理及优化"></a> 2.Go管理及优化</h3><h4 id="21-go-内存分配"><a class="markdownIt-Anchor" href="#21-go-内存分配"></a> 2.1 Go 内存分配</h4><p><strong>分块</strong></p><ul><li>目标：为对象在heap上分配内存</li><li>提前将内存分块<ul><li>调用系统调用 mmap() 向OS申请一大块内存，例如 4 MB</li><li>先将内存划分成大块，例如 8 KB，称作 mspan</li><li>再将大块继续划分成特定大小的小块，用于对象分配</li><li>noscan mspan：分配不包含指针的对象——GC 不需要扫描</li><li>scan mspan：分配包含指针的对象——GC 需要扫描</li></ul></li><li>对象分配：根据对象的大小，选择最合适的块返回</li></ul><p><strong>缓存</strong></p><ul><li>TCMalloc：thread caching</li><li>每个 p 包含一个 mcache 用于快速分配，用于为绑定于 p 上的 g 分配对象</li><li>mcache 管理一组 mspan</li><li>当 mcache 中的 mspan 分配完毕，向 mcentral 申请带有未分配块的 mspan</li><li>当 mspan 中没有分配的对象，mspan 会被缓存在 mcentral 中，而不是立刻释放并归还给 OS</li></ul><h4 id="22-go-内存管理优化"><a class="markdownIt-Anchor" href="#22-go-内存管理优化"></a> 2.2 Go 内存管理优化</h4><ul><li>对象分配是非常高频的操作：每秒分配 GB 级别的内存</li><li>小对象占比较高</li><li>Go 内存分配比较耗时<ul><li>分配路径长：g -&gt; m -&gt; p -&gt; mcache -&gt; mspan -&gt; memory block -&gt; return pointer</li><li>pprof：对象分配的函数是最频繁调用的函数之一</li></ul></li></ul><h4 id="23-优化方案balanced-gc"><a class="markdownIt-Anchor" href="#23-优化方案balanced-gc"></a> 2.3 优化方案：Balanced GC</h4><ul><li><p>每个 g 都绑定一大块内存（1KB），称作 goroutine allocation buffer（GAB）</p></li><li><p>GAB 用于 noscan 类型的小对象分配：&lt; 128 B</p></li><li><p>使用三个指针维护 GAB：base，end，top</p></li><li><p>Bump pointer（指针碰撞）风格对象分配</p><ul><li>无须和其他分配请求互斥</li><li>分配动作简单高效</li></ul></li><li><p>GAB 对于 Go 内存管理来说是一个大对象</p></li><li><p>本质：将多个小对象的分配合并成一次大对象的分配</p></li><li><p>问题：GAB的对象分配方式会导致内存被延迟释放</p></li><li><p>方案：移动 GAB 中存活的对象</p><ul><li>当 GAB 总大小超过一定阈值时，将 GAB 中存活的对象复制到另外分配的 GAB 中</li><li>原先的 GAB 可以释放，避免内存泄漏</li><li>本质：用 copying GC 的算法管理小对象。根据对象的生命周期，使用不同的标记和清理策略。</li></ul></li></ul><p><strong>性能收益</strong>（数据仅供参考）</p><ul><li>高峰期 CPU usage 降低 4.6%，核心接口时延下降 4.5%~7.7%</li></ul><h4 id="总结-3"><a class="markdownIt-Anchor" href="#总结-3"></a> 总结</h4><ul><li>Go 内存管理 — 分块</li><li>Go 内存管理 — 缓存</li><li>Go 对象分配的性能问题<ul><li>分配路径过长</li><li>小对象居多</li></ul></li><li>Balanced GC<ul><li>指针碰撞风格的对象分配</li><li>实现了 copying GC</li><li>性能收益</li></ul></li></ul><h3 id="3编译器和静态分析"><a class="markdownIt-Anchor" href="#3编译器和静态分析"></a> 3.编译器和静态分析</h3><h4 id="31-编译器的结构"><a class="markdownIt-Anchor" href="#31-编译器的结构"></a> 3.1 编译器的结构</h4><ul><li>重要的软件系统<ul><li>识别符号语法和非法的程序</li><li>生成正确且高效的代码</li></ul></li><li>分析部分（前端 front end）<ul><li>词法分析，生成词素（lexeme）</li><li>语法分析，生成语法树</li><li>语义分析，收集类型信息，进行语义检查</li><li>中间代码生成，生成intermediate representation（IR）</li></ul></li><li>综合部分（后端 back end）<ul><li>代码优化，机器无关优化，生成优化后的 IR</li><li>代码生成，生成目标代码</li></ul></li></ul><p>后端是优化重点，同时控制流和数据流分析是优化的基础。</p><h4 id="32-静态分析"><a class="markdownIt-Anchor" href="#32-静态分析"></a> 3.2 静态分析</h4><ul><li>静态分析：不执行程序代码，推导程序的行为，分析程序的性质。</li><li>控制流（Control flow）：程序执行的流程</li><li>数据流（Data flow）：数据在控制流上的传递</li><li>通过分析控制流和数据流，可以知道更多关于程序的性质（properties）</li><li>根据这些性质优化代码</li></ul><h4 id="33-过程内分析和过程间分析"><a class="markdownIt-Anchor" href="#33-过程内分析和过程间分析"></a> 3.3 过程内分析和过程间分析</h4><ul><li>过程内分析（Intra-procedural analysis）<ul><li>仅在函数内部进行分析</li></ul></li><li>过程间分析<ul><li>考虑函数调用时参数传递和返回值的数据流和控制流</li></ul></li><li>过程间分析是个问题<ul><li>需要通过数据流分析得知接口 i 的具体类型，才能知道有多个同名方法（比如<code>func (a *A) foo()</code>和<code>func (b *B) foo()</code>）存在时，接口 i 调用的是哪个<code>foo()</code></li><li>根据接口的具体类型，产生了新的控制流，<code>i.foo()</code>，分析继续</li><li>过程间分析需要同时分析控制流和数据流——联合求解，比较复杂</li></ul></li></ul><h4 id="总结-4"><a class="markdownIt-Anchor" href="#总结-4"></a> 总结</h4><ul><li>编译器的结构与编译的流程</li><li>编译器后端优化</li><li>数据流分析和控制流分析</li><li>过程内分析和过程间分析</li></ul><h3 id="4go编译器优化"><a class="markdownIt-Anchor" href="#4go编译器优化"></a> 4.Go编译器优化</h3><ul><li>为什么做编译器优化<ul><li>用户无感知，重新编译即可获得性能收益</li><li>通用性优化</li></ul></li><li>现状<ul><li>采用的优化少</li><li>编译时间较短，没有进行复杂的代码分析和优化</li></ul></li><li>编译优化的思路<ul><li>场景：面向后端长期执行任务</li><li>Tradeoff：用编译时间换取更高效的机器码</li></ul></li><li>Beast mode<ul><li>函数内联分析</li><li>逃逸分析</li><li>默认栈大小调整</li><li>边界检查消除</li><li>循环展开</li><li>…</li></ul></li></ul><h4 id="41-函数内联inlining"><a class="markdownIt-Anchor" href="#41-函数内联inlining"></a> 4.1 函数内联（Inlining）</h4><ul><li><p>内联：将被调用函数的函数体（callee）的副本替换到调用位置（caller）上，同时重写代码以反映参数的绑定</p></li><li><p>优点</p><ul><li>消除函数调用开销，例如传递函数、保存寄存器等</li><li>将过程间分析转化为过程内分析，帮助其他优化，例如逃逸分析</li></ul></li><li><p>函数内联对性能的影响程度——使用 micro-benchmark验证</p><p>示例</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkInline</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">x := genInteger()</span><br><span class="line">y := genInteger()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">addInline(x, y)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addInline</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkInlineDisabled</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">x := genInteger()</span><br><span class="line">y := genInteger()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">addNoInline(x, y)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addNoInline</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genInteger</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"><span class="keyword">return</span> rand.Intn(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的<code>//go:noinline</code>是一种编译指示，<code>noinline</code>表示不要内联，固定写法。这种编译指示类似于C语言中的<code>#include</code>。</p></li><li><p>使用 micro-benchmark快速验证和对比性能优化结果</p><p>使用以下命令进行性能测试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench .</span><br></pre></td></tr></table></figure></li><li><p>缺点</p><ul><li>函数体变大，instruction cache（icache）不友好</li><li>编译生成的 Go 镜像变大</li></ul></li><li><p>函数内联在大多数情况下是正向优化</p></li><li><p>内联策略</p><ul><li>调用和被函数的规模</li><li>…</li></ul></li></ul><h4 id="42-beast-mode"><a class="markdownIt-Anchor" href="#42-beast-mode"></a> 4.2 Beast Mode</h4><ul><li>Go 函数内联受到的限制较多<ul><li>语言特性，例如 interface，defer等，限制了函数内联</li><li>内联策略非常保守</li></ul></li><li>Beast Mode：调整函数内联的策略，使更多函数被内联<ul><li>降低函数调用的开销</li><li>增加了其他优化的机会：逃逸分析</li></ul></li><li>开销<ul><li>Go 镜像增加约 10%</li><li>编译时间增加</li></ul></li></ul><p><strong>性能收益</strong>（数据仅供参考）</p><ul><li>高峰期 CPU usage 降低 9%，时延降低 10%</li><li>内存使用降低 3%</li></ul><h4 id="43-逃逸分析"><a class="markdownIt-Anchor" href="#43-逃逸分析"></a> 4.3 逃逸分析</h4><p>逃逸分析：分析代码中指针的动态作用域，即指针在何处可以被访问</p><ul><li>大致思路<ul><li>从对象分配处出发，沿着控制流，观察对象的数据流</li><li>若发现指针 p 在当前作用域 s<ul><li>作为参数传递给其他函数</li><li>传递给全局变量</li><li>传递给其他的 goroutine</li><li>传递给已逃逸的指针指向的对象</li></ul></li><li>则指针 p 指向的对象逃逸出 s，反之则没有逃逸出 s</li></ul></li><li>Beast Mode：函数内联拓展了函数边界，更多对象不逃逸</li><li>优化：未逃逸的对象可以在栈上分配<ul><li>对象在栈上分配和回收很快：移动 sp</li><li>减少在 heap 上的分配，降低 GC 负担</li></ul></li></ul><h4 id="总结-5"><a class="markdownIt-Anchor" href="#总结-5"></a> 总结</h4><ul><li>Go 编译器优化问题</li><li>Beast Mode</li><li>函数内联</li><li>逃逸分析</li><li>通过 micro-benchmark 快速验证性能优化</li><li>性能收益</li></ul><h3 id="归纳"><a class="markdownIt-Anchor" href="#归纳"></a> 归纳</h3><ul><li>性能优化<ul><li>自动内存管理</li><li>Go 内存管理</li><li>编译器与静态分析</li><li>编译器优化</li></ul></li><li>实践<ul><li>Balanced GC 优化对象分配</li><li>Beast Mode 提升代码性能</li></ul></li><li>分析问题的方法与解决问题的思路，不仅适用于Go 语言，也适用于其他语言的优化</li></ul><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><p><a href="https://juejin.cn/post/7189525739836801085/">【后端专场 学习资料二】第五届字节跳动青训营 - 掘金 (juejin.cn)</a></p><p><a href="https://segmentfault.com/a/1190000016743220">Go 语言编译器的 “//go:” 详解 - Golang 攻略 - SegmentFault 思否</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文已收录到&lt;a href=&quot;https://juejin.cn/post/7194838118955450428&quot;&gt;Go 语言内存管理详解 | 青训营笔记 - 掘金 (juejin.cn)&lt;/a&gt;，主要记录了对golang内存管理的学习</summary>
    
    
    
    <category term="golang" scheme="https://s-chance.github.io/categories/golang/"/>
    
    
    <category term="学习笔记" scheme="https://s-chance.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="青训营" scheme="https://s-chance.github.io/tags/%E9%9D%92%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>Go 高质量编程与性能调优</title>
    <link href="https://s-chance.github.io/2023/01/28/golang-day3/"/>
    <id>https://s-chance.github.io/2023/01/28/golang-day3/</id>
    <published>2023-01-28T15:23:13.000Z</published>
    <updated>2023-02-01T07:04:35.846Z</updated>
    
    <content type="html"><![CDATA[<p>本文已收录到<a href="https://juejin.cn/post/7194132732492906551">golang高质量编程与性能调优 | 青训营笔记 - 掘金 (juejin.cn)</a>，主要记录了对golang高质量编程与性能调优的学习<span id="more"></span></p><h2 id="高质量编程与性能调优实战"><a class="markdownIt-Anchor" href="#高质量编程与性能调优实战"></a> 高质量编程与性能调优实战</h2><p>主要内容</p><ul><li>如何编写更简洁清晰的代码</li><li>常用Go语言程序的优化手段</li><li>熟悉Go程序性能分析工具</li><li>了解工程中性能优化的原则和流程</li></ul><h3 id="1高质量编程"><a class="markdownIt-Anchor" href="#1高质量编程"></a> 1.高质量编程</h3><h4 id="11-简介"><a class="markdownIt-Anchor" href="#11-简介"></a> 1.1 简介</h4><p>高质量代码：编写的代码能够达到正确可靠、简洁清晰的目标。</p><ul><li><p>正确性：考虑各种边界条件，能够处理错误的调用。</p></li><li><p>可靠性：异常情况或者错误处理的策略明确，依赖的服务出现异常能够及时处理。</p></li><li><p>简单：逻辑简单，后续调整功能或新增功能能够快速支持。</p></li><li><p>清晰：其他人在阅读代码时容易理解，重构或者修改功能不会出现无法预料的问题。</p></li></ul><p>编程的原则</p><p><strong>简单性</strong></p><p>消除“多余的复杂性”，以简单清晰的逻辑编写代码。复杂的逻辑难以重构和优化，无法明确预知其调整造成的影响范围，也难以在排查问题时定位。</p><p><strong>可读性</strong></p><p>从后期来看，大部分工作是对已有功能的完善和扩展，对应功能的代码会存在很长时间。维护是一个项目最漫长的周期，好的可读性可以降低维护的时间成本。</p><p><strong>生产力</strong></p><p>Go语言有特定的代码格式限制，甚至有专门的工具强制统一所有代码格式。遵循代码规范，能够避免常见的缺陷代码，降低后续联调、测试、验证、上线等各个节点出现问题的概率以及快速排查定位问题。</p><h3 id="12-编码规范"><a class="markdownIt-Anchor" href="#12-编码规范"></a> 1.2 编码规范</h3><h4 id="121-代码格式"><a class="markdownIt-Anchor" href="#121-代码格式"></a> 1.2.1 代码格式</h4><p>推荐使用gofmt自动格式化代码，gofmt是Go语言官方提供的工具，能够自动格式化GO语言代码为官方统一风格，常见的IDE都支持配置。</p><p>另外的，goimports会对依赖包进行管理，自动增删依赖包引用，按字母排序分类。</p><h4 id="122-注释"><a class="markdownIt-Anchor" href="#122-注释"></a> 1.2.2 注释</h4><p>注释有以下四种使用方式</p><ul><li><p>解释代码作用。</p><p>适合说明公共符号，比如对外提供的函数用注释描述它的功能和用途，除非函数的功能简单而明显时，才可省略注释。</p><p>对于显而易见的内容不需要注释。</p></li><li><p>解释代码如何实现</p><p>适合说明逻辑实现过程，解释复杂的不明显的逻辑。</p><p>不要解释显而易见的流程，避免增加冗余信息和造成误解。</p></li><li><p>解释代码实现的原因</p><p>适合解释代码的外部因素，为什么需要实现这个代码，提供上下文信息，说明这段代码在上下文中的意义。</p></li><li><p>解释代码出错的可能情况</p><p>适合解释代码的限制条件，一些潜在的限制条件或者无法处理的情况，例如性能隐患，输入的限制条件，可能出现的错误情况等。使阅读者在不需要了解代码实现细节的情况下弄清限制条件。</p></li></ul><p><strong>公共符号始终要注释</strong></p><ul><li>包中声明的每个公共符号：变量、常量函数以及结构都需要添加注释</li><li>任何既不明显又不简短的公共功能必须予以注释</li><li>无论长度或复杂程度如何，对库中的函数都必须进行注释</li><li>例外情况，不需要注释实现接口的方法。</li></ul><p>更多规范的注释可以参考golang的官方仓库源码<a href="https://github.com/golang/go/tree/master/src">golang/go</a></p><p><strong>小结</strong></p><ul><li>代码本身应该是最好的注释</li><li>注释应该提供代码未表达出的上下文信息</li></ul><h4 id="123-命名规范"><a class="markdownIt-Anchor" href="#123-命名规范"></a> 1.2.3 命名规范</h4><p>命名是代码编写中最常见的规范。</p><p><strong>variable</strong></p><ul><li><p>简洁胜于冗长</p></li><li><p>缩略词全大写，但当其位于变量开头且不需要对外提供时，使用全小写</p><p>例如，使用SeverHTTP而不是ServerHttp。使用XMLHTTPRequest或者xmlHTTPRequest。</p></li><li><p>变量距离其被使用的地方越远，则需要携带更多的上下文信息。</p><p>全局变量在其名字中需要更多的上下文信息，使得在不同的地方可以轻易辨认出其含义</p></li><li><p>几乎不影响理解的变量名变动，选择最简介的名称即可。</p></li><li><p>具有特定含义的变量名变动，选择意义最贴切的名称即可。</p></li></ul><p><strong>function</strong></p><ul><li><p>函数名不携带包名的上下文信息，因为包名和函数名总是成对出现</p><p>例如，使用time.Now()而不是time.NowTime()。</p></li><li><p>函数名尽量简短</p></li><li><p>当名为foo的包某个函数返回类型为Foo时，可以省略类型信息避免歧义</p></li><li><p>当名为foo的包某个函数返回类型为T时（T不是Foo），可以在函数名中加入类型信息</p><p>例如，parseInt</p></li></ul><p><strong>package</strong></p><ul><li>只由小写字母组成，不能包含大写字母和下划线等字符</li><li>简短并包含一定的上下文信息。例如schema</li><li>不要与标准库同名。例如不要使用sync或者strings</li></ul><p>以标准库包名为例</p><ul><li>不使用常用的变量名作为包名。例如使用bufio而不是buf</li><li>使用单数而不是复数。例如使用encoding而不是encodings</li><li>谨慎地使用缩写。例如使用fmt在不破坏上下文的情况下比format更加简短</li></ul><p><strong>小结</strong></p><ul><li>核心目标是降低阅读理解代码的成本</li><li>重点考虑上下文信息，设计简洁清晰的名称</li></ul><h4 id="124-控制流程"><a class="markdownIt-Anchor" href="#124-控制流程"></a> 1.2.4 控制流程</h4><p>流程控制经常用到的就是if else这种条件控制语句。</p><p><strong>避免嵌套，保持正常流程清晰</strong></p><p>一个简单的if else，如果两个分支都包含return语句，则可以去除冗余的else，方便后续维护。else一般就是表示正常流程，如果需要在正常流程中新增判断逻辑，则去除else可以避免分支嵌套。</p><p><strong>尽量保持正常代码路径为最小缩进</strong></p><ul><li><p>优先处理错误情况或特殊情况，尽早返回或继续循环来减少嵌套。</p><p>例如，使用<code>err != nil</code>而不是<code>err == nil</code>就是为了优先处理错误情况。</p></li></ul><p><strong>小结</strong></p><ul><li>线性原理，处理逻辑尽量走直线，避免复杂的嵌套分支</li><li>正常流程代码沿着屏幕向下移动</li><li>提升代码的可维护性和可读性</li><li>故障问题大多出现在复杂的条件语句和循环语句中</li></ul><h4 id="125-错误和异常处理"><a class="markdownIt-Anchor" href="#125-错误和异常处理"></a> 1.2.5 错误和异常处理</h4><p><strong>简单错误</strong></p><ul><li>简单的错误指的是仅出现一次的错误，且在其他地方不需要捕获该错误</li><li>优先使用errors.New来创建匿名变量直接表示简单错误</li><li>如果需要格式化错误信息，使用fmt.Errorf</li></ul><p><strong>错误的Wrap和Unwarp</strong></p><ul><li>错误的Wrap实际上是提供了一个error嵌套另一个error的能力，从而形成一个error的跟踪链</li><li>在fmt.Errorf中使用%w占位符来将一个错误关联至错误跟踪链中</li></ul><p><strong>错误判定</strong></p><ul><li>判断一个错误是否为特定错误，<a href="http://xn--errors-vt9i248w.Is">使用errors.Is</a></li><li>不同于使用==，使用该方法可以判断错误链上的所有错误中是否含有特定的错误</li><li>在错误链上获取特定种类的错误，<a href="http://xn--errors-vt9i248w.As">使用errors.As</a>。与errors.Is不同的是As会取出调用链中指定类型的错误，并将错误赋值给定义好的变量，方便后续处理</li></ul><p><strong>panic</strong></p><p>panic比错误更加严重，它的出现表示程序无法正常工作。</p><ul><li>不建议在业务代码中使用panic</li><li>panic发生后会向上传播至调用栈顶，如果当前goroutine中所有deferred函数都不包含recover就会造成整个程序崩溃</li><li>若问题可以被屏蔽或解决，建议使用error代替panic</li><li>特殊地，当程序启动阶段发生不可逆的错误时，可以在init或main函数中使用panic</li></ul><p><strong>recover</strong></p><p>panic的产生并不只在程序运行阶段。如果是引入其他库时产生的bug而导致的panic就需要使用recover。</p><p>注意recover的生效条件</p><ul><li>recover只能在被defer的函数中使用</li><li>在嵌套中无法生效</li><li>只在当前goroutine生效</li><li>defer的语句是先进后出</li></ul><p>如果需要更多的上下文信息，可以在recover后用log记录当前调用的栈，方便分析定位。</p><p><strong>小结</strong></p><ul><li>error尽可能提供简明的上下文信息链，方便定位问题</li><li>panic用于真正异常的情况，无法规避</li><li>recover生效范围，在当前goroutine的deferred函数中生效</li></ul><h3 id="13-性能优化建议"><a class="markdownIt-Anchor" href="#13-性能优化建议"></a> 1.3 性能优化建议</h3><p><strong>简介</strong></p><ul><li>性能优化的前提是满足正确可靠、简洁清晰等质量因素</li><li>性能优化是综合评估，时间效率和空间效率可能在某些情况下不能兼得</li><li>针对Go语言特性来介绍Go相关的性能优化建议</li></ul><h4 id="131-benchmark"><a class="markdownIt-Anchor" href="#131-benchmark"></a> 1.3.1 Benchmark</h4><p><strong>如何使用</strong></p><ul><li>性能表现需要实际数据衡量</li><li>Go语言提供了支持基准性能测试的benchmark工具</li></ul><p>通过以下命令进行性能测试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench=. -benchmem</span><br></pre></td></tr></table></figure><p><strong>结果说明</strong></p><ul><li>第一个参数如BenchmarkFib10-8对应被测试函数的名称，-8表示GOMAXPROCS的值为8</li><li>第二个参数如1855870表示一共执行1855870次，即b.N的值</li><li>第三个参数如602.5ns/op表示每次执行花费602.5ns</li><li>第四个参数如0B/op表示每次执行时申请的内存空间大小</li><li>第五个参数如0allocs/op表示每次执行时申请内存的次数</li></ul><h4 id="132-slice"><a class="markdownIt-Anchor" href="#132-slice"></a> 1.3.2 Slice</h4><p><strong>slice预分配内存</strong></p><ul><li><p>尽可能在使用make()初始化切片时提供容量信息</p></li><li><p>切片本质是一个数组片段的描述，包括数组指针、片段的长度、片段的容量（不改变内存分配情况下的最大长度）</p></li><li><p>切片操作并不复制切片指向的元素</p></li><li><p>而是创建一个新的切片复用原来切片的底层数组</p><p>以切片的append为例，append时有两种场景：</p><p>当append之后的长度小于等于容量，将会直接利用原底层数组剩余的空间。</p><p>当append之后的长度大于容量，则会分配一块更大的区域来容纳新的底层数组。</p></li></ul><p>因此，为了避免内存发生拷贝，如果能够明确最终的切片的大小，预先设置容量的值能够避免额外的内存分配，获得更好的性能。</p><p><strong>大内存未释放问题</strong></p><p>原切片由大量的元素构成，在原切片的基础上创建切片只使用了很小一段，但底层数组在内存中仍占据着大量空间，无法释放。</p><ul><li>在已有切片的基础上创建切片，不会创建新的底层数组</li><li>可以使用copy代替re-slice，因为通过copy会指向一个新的底层数组，原来的底层数组不再被引用之后，内存就会被回收。</li></ul><h4 id="133-map"><a class="markdownIt-Anchor" href="#133-map"></a> 1.3.3 Map</h4><p><strong>map预分配内存</strong></p><p>原理</p><ul><li>不断向map中添加元素的操作会触发map的扩容</li><li>提前分配好空间可以减少内存拷贝和Rehash的消耗</li><li>建议根据实际需求提前预估好需要的空间</li></ul><h4 id="134-字符串处理"><a class="markdownIt-Anchor" href="#134-字符串处理"></a> 1.3.4 字符串处理</h4><p><strong>使用strings.Builder</strong></p><ul><li><p>常见的字符串拼接方式就是使用+号直接拼接或者使用strings.Builder的方法拼接以及bytes.Buffer的方法拼接</p></li><li><p>使用+号拼接性能最差，strings.Builder和bytes.Buffer性能相近，strings.Builder更快。</p><p>当使用+拼接两个字符串时，生成一个新的字符串，那么就需要开辟一段新的空间，新空间的大小是原来两个字符串的大小之和。拼接第三个字符串时，再开辟一段新空间，新空间大小是三个字符串大小之和，以此类推。</p></li><li><p>分析</p><ul><li>字符串在Go语言中是不可变类型，占用内存大小是固定的</li><li>使用+每次都会重新分配内存</li><li>strings.Builder和bytes.Buffer底层都是[]byte数组</li><li>Builder和Buffer的内存扩容策略，不需要每次拼接重新分配内存</li></ul></li><li><p>Builder比Buffer快的原因</p><ul><li>bytes.Buffer转化为字符串时重新申请了一块空间</li><li>strings.Builder直接将底层的[]byte转换成了字符串类型返回</li></ul></li><li><p>在已知字符串长度的情况下，进一步提升Builder的拼接性能，使用预分配减少分配次数。优化后的Builder只需要一次内存分配，而优化后的Buffer有两次。</p></li></ul><h4 id="135-空结构体"><a class="markdownIt-Anchor" href="#135-空结构体"></a> 1.3.5 空结构体</h4><p><strong>使用空结构体节省内存</strong></p><ul><li><p>空结构体struct{}实例不占据任何内存空间</p></li><li><p>可做为各种场景下的占位符使用</p><ul><li>节省资源</li><li>空结构体本身具备很强的语义，不需要任何值就能作为占位符</li></ul></li><li><p>Set方法的实现，可以考虑用map来代替</p></li><li><p>对于这个场景，只需要用到map的键，不需要值</p></li><li><p>即使是将map的值设置为bool类型，也会多占据1个字节空</p><p>一个开源实现<a href="https://github.com/deckarep/golang-set/blob/main/threadunsafe.go">golang-set/threadunsafe.go</a>。</p></li></ul><h4 id="136-atomic包"><a class="markdownIt-Anchor" href="#136-atomic包"></a> 1.3.6 atomic包</h4><p>多线程编程场景下性能优化，保证线程安全。</p><p><strong>如何使用atomic包</strong></p><ul><li>锁的实现是通过操作系统来实现，属于系统调用</li><li>atomic操作是通过硬件实现，效率比锁高</li><li>sync.Mutex应该用来保护一段逻辑，不仅仅用于保护一个变量</li><li>对于非数值操作，可以使用atomic.Value，能承载一个interface{}</li></ul><h4 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h4><ul><li>避免常见的性能陷阱可以保证大部分程序的性能</li><li>普通应用代码，不要一味地追求程序的性能</li><li>越高级的性能优化手段越容易出现问题</li><li>在满足正确可靠、简洁清晰的质量要求的前提下提高程序性能</li></ul><h3 id="2性能调优实战"><a class="markdownIt-Anchor" href="#2性能调优实战"></a> 2.性能调优实战</h3><h3 id="21-简介"><a class="markdownIt-Anchor" href="#21-简介"></a> 2.1 简介</h3><p><strong>性能调优原则</strong></p><ul><li>要依靠数据而不是猜测</li><li>要定位最大瓶颈而不是细枝末节</li><li>不要过早优化</li><li>不要过度优化</li></ul><h3 id="22-性能分析工具-pprof"><a class="markdownIt-Anchor" href="#22-性能分析工具-pprof"></a> 2.2 性能分析工具 pprof</h3><p><strong>说明</strong></p><p>如果想知道应用在什么地方耗费了多少CPU、Memory。对于go程序有一个很方便的工具——pprof</p><h4 id="221-功能简介"><a class="markdownIt-Anchor" href="#221-功能简介"></a> 2.2.1 功能简介</h4><p>pprof是用于可视化和分析性能分析数据的工具</p><ul><li>分析-Profile：网页、可视化终端</li><li>工具-Tool：runtime/pprof、net/http/pprof</li><li>采样-Sample：CPU、堆内存-Heap、协程-Goroutine、锁-Mutex、阻塞-Block、线程创建-ThreadCreate</li><li>展示-View：Top、调用图-Graph、火焰图-FlameGraph、Peek、源码-Source、反汇编-Disassemble</li></ul><h4 id="222-排查实战"><a class="markdownIt-Anchor" href="#222-排查实战"></a> 2.2.2 排查实战</h4><p><strong>搭建pprof实践项目</strong></p><ul><li><p>项目地址<a href="https://github.com/wolfogre/go-pprof-practice">wolfogre/go-pprof-practice: go pprof practice.</a></p></li><li><p>该项目提前埋入了炸弹代码，能产生可观测的性能问题。windows可用任务管理器查看内存占用情况，启动项目前确保内存足够。</p></li><li><p>项目中引入了net/http/pprof包，在启动项目后可以通过浏览器访问pprof工具</p><p>main函数部分代码说明</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">runtime.GOMAXPROCS(<span class="number">1</span>)              <span class="comment">//限制CPU使用数</span></span><br><span class="line">runtime.SetMutexProfileFraction(<span class="number">1</span>) <span class="comment">//开启锁调用跟踪</span></span><br><span class="line">runtime.SetBlockProfileRate(<span class="number">1</span>)     <span class="comment">//开启阻塞调用跟踪</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 启动 http server</span></span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:6060&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></li></ul><p><strong>浏览器查看指标</strong></p><p>在项目启动成功后，访问http://localhost:6060/debug/pprof，可以看到pprof的计数页面。</p><p>页面上展示了可用的程序运行采样数据，分别是</p><ul><li>allocs:内存分配情况</li><li>blocks:阻塞操作情况</li><li>cmdline:程序启动命令及其参数</li><li>goroutine:当前所有协程的堆栈信息</li><li>heap:堆上内存使用情况</li><li>mutex:锁竞争操作情况</li><li>profile:CPU占用情况</li><li>threadcreate:当前所有常见的系统线程的堆栈信息</li><li>trace:程序运行跟踪情况</li></ul><p>cmdline可以显式运行进程的命令，找到问题来源的程序。threadcreate比较复杂，不透明。trace需要配合另外的工具解析，这里暂不深入。</p><p>炸弹主要在CPU、堆内存、goroutine、锁竞争和阻塞操作上，可以通过pprof工具分析</p><p><strong>CPU</strong></p><p>使用操作系统自带的工具查看CPU占用，发现该项目程序的异常占用。</p><p>pprof的采样结果是将一段时间内的信息汇总输出到文件中，所以需要获取这个profile文件。可以直接使用暴露的接口链接下载文件后使用，也可以直接用pprof工具连接这个接口下载需要的数据。</p><p>使用go tool pprof + 采样链接的命令来启动采样，例如</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof <span class="string">&quot;http://localhost:6060/debug/pprof/profile?seconds=10&quot;</span></span><br></pre></td></tr></table></figure><p>链接就是刚刚炸弹程序暴露出来的接口，链接结尾的profile代表采样的对象是CPU使用。如果在浏览器里直接打开链接会启动一个60秒的采样并在采样结束后下载文件到本地。这里加上seconds=10的参数，指定采样时间为10秒。文件下载保存的路径会在pprof终端展示。</p><p>pprof终端命令</p><ul><li><p>top命令用于查看占用资源最多的函数。top有以下参数指标</p><ul><li><p>flat:当前函数本身的执行耗时</p></li><li><p>flat%:flat占CPU总时间的比例</p></li><li><p>sum%:上面每一行flat%的总和</p></li><li><p>cum:指当前函数本身加上其调用函数的总耗时</p></li><li><p>cum%:cum占CPU总时间的比例</p></li></ul><p>默认展示资源占用最高的10个函数，如果只需要查看占用最高的N个函数，在top命令后加上一个数字N即可。</p><p>flat=cum的函数说明该函数没有调用其他函数</p><p>flat=0的函数说明该函数只有其他函数的调用</p><hr /></li><li><p>list命令会根据给出的正则表达式查找代码，并按行展示出每一行的占用</p><p>例如，在pprof终端输入list Eat，就能查看Eat函数每行的占用情况。这样就能定位到具体的代码。</p><hr /></li><li><p>web命令可以生成一张调用关系图，默认通过浏览器打开。该命令需要提前安装Graphviz并配置环境变量才能使用。官网下载<a href="https://graphviz.org/download/">Download | Graphviz</a></p><p>图中除了每个节点的资源占用以外，还会将它们的调用关系描述出来。资源占用最高的函数会比较明显地展示出来。</p></li></ul><p>退出pprof终端，输入q回车即可。将炸弹程序直接注释。</p><p><strong>Heap-堆内存</strong></p><p>注释问题代码后，重新启动项目。用系统工具（windows是任务管理器）查看CPU占用，可以发现进程的占用已经降下来了。但还有内存占用问题，接下来排查内存问题。</p><p>上面排查CPU问题时使用的是pprof终端，这里使用另一种展示方式，通过<code>-http=:8080</code>参数，开启pprof自带的web UI，以网页的形式来呈现性能指标。注意链接结尾是heap</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof -http=:8080 <span class="string">&quot;http://localhost:6060/debug/pprof/heap&quot;</span></span><br></pre></td></tr></table></figure><p>通过上面的命令启动pprof工具后，在采样完成后会自动打开浏览器，展示出web视图，同时展示的资源使用从CPU时间变成了内存占用。</p><p>通过页面顶端的View菜单可以切换不同的视图，初始默认是Graph视图。Top视图就类似于终端top命令的展示效果，Source视图就类似于终端list命令的展示效果。通过这些视图可以快速定位问题，注释掉问题代码，拆除第二个炸弹。</p><p>重新运行项目，查看内存占用，发现内存占用也大幅下降。但实际上前面解决的内存问题只是堆内存采样的四种指标之一的inuse_space。四种指标如下</p><ul><li>alloc_objects:程序累计申请的对象数</li><li>alloc_space:程序累计申请的内存大小</li><li>inuse_objects:程序当前持有的对象数</li><li>inuse_space:程序当前占用的内存大小</li></ul><p>默认展示视图就是inuse_space视图，只展示当前持有的内存，但对于已经释放的内存，inuse采样不会进行展示。通过页面顶端的Sample菜单切换到alloc_space指标，分析alloc的内存问题。定位到问题代码，注释掉。至此，内存部分炸弹已经被全部清理。</p><p><strong>goroutine协程</strong></p><p>Golang是一门自带垃圾回收的语言，一般情况下内存泄露是没那么容易发生的。但是有一种例外，goroutine是很容易泄露的，进而导致内存泄露。接下来运行项目，分析goroutine使用情况。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof -http=:8080 <span class="string">&quot;http://localhost:6060/debug/pprof/goroutine&quot;</span></span><br></pre></td></tr></table></figure><p>goroutine使用默认视图不方便分析，可以切换到Flame Graph火焰图更加直观。</p><p>火焰图的展示</p><ul><li>由上到下表示调用顺序，展示了各个函数调用之间的层级关系</li><li>每一行代表一个函数，条形越长代表占用的资源越多</li><li>火焰图是动态的，支持点击块进行分析</li></ul><p>火焰图是非常常用的性能分析工具，在程序逻辑复杂的情况下很有用。</p><p>切换到Source视图，在该视图下搜索火焰图中占用最高的函数名称。定位到问题代码，注释掉。重新启动访问pprof可以发现goroutine已下降到正常水平。</p><p><strong>mutex-锁</strong></p><p>启动pprof工具</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof -http=:8080 <span class="string">&quot;http://localhost:6060/debug/pprof/mutex&quot;</span></span><br></pre></td></tr></table></figure><p>观察web视图，分析锁操作，切换到Source视图定位到具体代码，注释掉。</p><p><strong>block-阻塞</strong></p><p>在程序中，除了锁的竞争会导致阻塞以外，还有很多逻辑(例如读取一个channel)也会导致阻塞。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof -http=:8080 <span class="string">&quot;http://localhost:6060/debug/pprof/block&quot;</span></span><br></pre></td></tr></table></figure><p>同理在Graph视图中定位到问题函数后，切换到Source视图定位到问题代码，注释掉。</p><p>但实际上，该示例项目在之前的计数页面上存在两个阻塞，上面只解决了其中一个阻塞。只展示了一个阻塞，是因为另一个阻塞操作的节点总用时小于总时长的千分之五而被省略掉。这是pprof的过滤策略，能够更加有效地突出重点问题信息，而省略相对没有问题的信息。如果没有过滤策略的话，对于一个复杂的程序，大量无关紧要的内容都会展示出来，不利于定位问题。</p><p>第二个阻塞操作，尽管不会在pprof工具中展示出来，但也会被pprof记录下来，可以通过暴露出来的接口地址http://localhost:6060/debug/pprof中的block链接直接访问。通过访问可以得知这个阻塞操作是符合预期的正常操作。</p><p><strong>小结</strong></p><ul><li>五种使用pprof采集的常用性能指标: CPU、堆内存、Goroutine、 锁竞争和阻塞;</li><li>两种展示方式:交互式终端和网页;</li><li>四种视图: Top、 Graph、 源码和火焰图。</li><li>pprof除了http的获取方式之外，也可以直接在运行时调用runtime/pprof包将指标数据输出到本地文件。</li><li>视图中还有一个更底层的「反汇编」视图。感兴趣的话可自行尝试。</li></ul><h4 id="223-pprof的采样过程和原理"><a class="markdownIt-Anchor" href="#223-pprof的采样过程和原理"></a> 2.2.3 pprof的采样过程和原理</h4><p><strong>CPU</strong></p><ul><li>采样对象：所有函数调用栈和它们的占用时间</li><li>采样率：100次/秒，固定值</li><li>采样时间：从手动启动到手动结束</li></ul><p>这个定时机制在unix或类unix系统上是依赖信号机制实现的。每次暂停都会接收到一个信号，通过系统计时器来保证这个信息是固定频率发送的。</p><p>开始采样——&gt;设定信号处理函数——&gt;开启定时器</p><p>停止采样——&gt;取消信号处理函数——&gt;关闭定时器</p><p>一共有三个相关角色：进程本身、操作系统和写缓冲。启动采样时，进程向OS注册一个定时器</p><ul><li><p>操作系统每10ms向进程发送一次SIGPROF信号</p></li><li><p>进程每次接收到SIGPROF信号后就会对当前的调用堆栈进行记录</p></li><li><p>与此同时，进程会启动一个写缓冲的goroutine，每隔100ms从进程中读取已经记录的堆栈信息，并写入到输出流。</p></li></ul><p>当采样停止时，进程向OS取消定时器，不再接收信号，写缓冲读取不到新的堆栈时，结束输出。</p><p><strong>Heap-堆内存</strong></p><p>pprof的内存采样是有局限性的，内存采样在实现上依赖了内存分配器的记录，所以只能记录在堆上分配且参与GC的内存，一些其他的内存分配，例如调用结束就会回收的栈内存、一些更底层使用cgo调用分配的内存，是不会被内存采样记录的。</p><ul><li>采样程序通过内存分配器记录在堆上分配和释放的内存，记录分配和释放的大小和数量</li><li>采样率：每分配512KB记录一次，可在运行开头修改，设置为1则表示每次分配都会记录</li><li>采样时间：从程序运行开始到获取采样结果时</li><li>采样指标：alloc_space, alloc_objects, inuse_space, inuse_objects。</li><li>计算方式：inuse = alloc - free</li></ul><p><strong>Goroutine-协程和ThreadCreate-线程创建</strong></p><p>goroutine和threadcreate这两个采样指标在概念上和实现上都比较相似。</p><ul><li><p>Goroutine</p><p>记录所有用户发起且在运行中的goroutine（即入口非runtime开头的）以及runtime.main函数中的调用栈信息</p><p>Stop The World——&gt;遍历allg切片——&gt;输出创建g的堆栈——&gt;Start The World</p></li><li><p>ThreadCreate</p><p>记录程序创建的所有系统线程的信息</p><p>Stop The World——&gt;遍历allm切片——&gt;输出创建m的堆栈——&gt;Start The World</p></li><li><p>它们在实现上非常相似，都是在Stop The World之后遍历所有goroutine/所有线程的列表(上面的m就是 GMP模型中的m,在golang中和线程一一对应）并输出堆栈，最后Start The World继续运行。这个采样是立刻触发的全量记录，可以通过比较两个时间点的差值来得到某一时间段的指标。</p></li></ul><p><strong>Block-阻塞和Mutex-锁</strong></p><p>阻塞和锁竞争这两种采样指标在流程和原理上也非常相似，这两个采样记录的都是对应操作发生的调用栈、次数和耗时，不过这两个指标的采样率含义并不相同。</p><ul><li>阻塞操作<ul><li>采样阻塞操作的次数和耗时</li><li>采样率：阻塞耗时超过阈值时间的阻塞操作才会被记录，设置运行参数为1表示每次操作都会记录。</li></ul></li><li>锁竞争<ul><li>采样争抢锁的次数和耗时</li><li>采样率：只记录固定比例的锁操作，设置运行参数为1表示每次加锁都会记录。</li></ul></li><li>它们在实现上也是基本相同的，都是一个「主动上报」的过程<ul><li>在阻塞操作或锁操作发生时，会计算出消耗的时间，连同调用栈一起主动上报给采样器，采样器会根据采样率可能会丢弃一些记录。 例如时间未达阈值或者比例未命中。</li><li>在采样时，采样器会遍历已经记录的信息，统计出具体操作的次数、调用栈和总耗时。和堆内存一样， 可以对比两个时间点的差值计算出这段时间内的操作指标。</li></ul></li></ul><h4 id="小结-2"><a class="markdownIt-Anchor" href="#小结-2"></a> 小结</h4><ul><li>掌握常用pprof工具功能</li><li>灵活运用pprof工具分析解决性能问题</li><li>了解pprof的采样过程和工作原理</li></ul><h3 id="23-性能调优案例"><a class="markdownIt-Anchor" href="#23-性能调优案例"></a> 2.3 性能调优案例</h3><p><strong>简介</strong></p><p>介绍实际业务服务性能优化的案例。对逻辑相对复杂的程序进行性能调优。</p><ul><li><p>业务服务优化</p><p>业务服务一般指直接提供功能的服务，比如用户评论系统</p></li><li><p>基础库优化</p><p>基础库一般指提供通用功能的程序，主要是针对业务服务提供功能，比如监控组件，用于收集业务服务的运行指标</p></li><li><p>Go语言优化</p><p>对Go语言本身进行的优化项</p></li></ul><h4 id="231-业务服务优化"><a class="markdownIt-Anchor" href="#231-业务服务优化"></a> 2.3.1 业务服务优化</h4><p><strong>基本概念</strong></p><ul><li>服务：能单独部署，承载一定功能的程序</li><li>依赖：Service A的功能实现依赖Service B的响应结果，称为Service A依赖Service B</li><li>调用链路：能支持一个接口请求的相关服务集合及其相互之间的依赖关系</li><li>基础库：公共的工具包、中间件</li></ul><p><strong>流程</strong></p><ul><li>建立服务性能评估手段。</li><li>分析性能数据，定位性能瓶颈。用pprof采样性能数据、分析服务。</li><li>重点优化项改造。重构代码、使用更高效的组件等。</li><li>优化效果验证。通过压测对比和正确性验证之后，上线服务进行实际收益评估。</li></ul><p><strong>建立服务性能评估手段</strong></p><ul><li>服务性能评估方式<ul><li>单独的benchmark无法满足复杂逻辑分析</li><li>不同负载情况下性能表现有所差异</li></ul></li><li>请求流量构造<ul><li>不同请求参数覆盖逻辑不同</li><li>线上真实流量情况</li></ul></li><li>压测范围<ul><li>单机压测</li><li>集群压测</li></ul></li><li>性能数据采集<ul><li>单机性能数据</li><li>集群性能数据</li></ul></li></ul><p>最后表现为一个服务的性能指标分析报告</p><p><strong>分析性能数据，定位性能瓶颈</strong></p><p>常见性能问题</p><ul><li><p>使用库不规范</p><ul><li>基础组件不规范，一般是代码编写逻辑问题，比如提供了缓存机制，但是代码中没有开启。</li><li>日志使用不规范，一般是线上服务环境导致某一调用链路数据量剧增，日志量随之剧增，影响性能。</li></ul></li><li><p>高并发场景优化不足</p><p>例如同步请求造成的性能瓶颈，影响到了业务逻辑处理，后续可改造成异步请求提升性能。</p></li></ul><p><strong>重点优化项改造</strong></p><ul><li><p>性能优化的前提是保证正确性，在变动较大的性能优化上线之前，还需要进行正确性验证。由于线上的场景和流程太多，所以一般会借助自动化手段来保证优化后程序的正确性。</p></li><li><p>响应数据diff</p><ul><li><p>线上请求数据录制回放</p><p>不仅包含请求参数录制，还有线上的返回内容录制</p></li><li><p>新旧逻辑接口数据diff</p><p>重放时对比线上的返回内容和优化后服务的返回内容进行正确性验证</p></li></ul></li></ul><p><strong>优化效果验证</strong></p><ul><li>重复压测验证</li><li>上线评估优化效果<ul><li>关注服务监控</li><li>逐步放量</li><li>收集性能数据</li></ul></li></ul><p>压测并不能保证和线上表现完全一致，有时还要通过线上的表现再进行分析改进，是个长期的过程。</p><p><strong>进一步优化，服务整体链路分析</strong></p><ul><li>规范上游服务调用接口，明确场景需求</li><li>分析链路，通过业务流程优化提升服务性能</li></ul><h4 id="232-基础库优化"><a class="markdownIt-Anchor" href="#232-基础库优化"></a> 2.3.2 基础库优化</h4><p><strong>AB实验SDK的优化</strong></p><blockquote><p>A/B测试（也称为<strong>分割测试</strong>或<strong>桶测试</strong>）是一种将网页或应用程序的两个版本相互比较以确定哪个版本的性能更好的方法。AB测试本质上是一个实验，其中页面的两个或多个变体随机显示给用户，统计分析确定哪个变体对于给定的转换目标（指标如CTR）效果更好。</p></blockquote><ul><li>分析基础库核心逻辑和性能瓶颈<ul><li>设计完善改造方案</li><li>数据按需获取</li><li>数据序列化协议优化</li></ul></li><li>内部压测验证</li><li>推广业务服务落地验证</li></ul><h4 id="233-go语言优化"><a class="markdownIt-Anchor" href="#233-go语言优化"></a> 2.3.3 Go语言优化</h4><p><strong>编译器和运行时优化</strong></p><ul><li>优化内存分配策略</li><li>优化代码编译流程，生成更高效的程序</li><li>内部压测验证</li><li>推广业务服务落地验证</li></ul><p>优点</p><ul><li>接入简单，只需要调整编译配置</li><li>通用性强</li></ul><h3 id="24-总结"><a class="markdownIt-Anchor" href="#24-总结"></a> 2.4 总结</h3><ul><li>性能调优原则<ul><li>要依靠数据而不是猜测</li></ul></li><li>性能分析工具pprof<ul><li>熟练使用pprof工具排查性能问题并了解其基本原理</li></ul></li><li>性能调优<ul><li>保证正确性</li><li>定位主要瓶颈</li></ul></li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://go.dev/doc/tutorial/add-a-test">Add a test - The Go Programming Language</a></p><p><a href="https://pkg.go.dev/testing#hdr-Benchmarks">testing package - testing - Go Packages</a></p><p><a href="https://geektutu.com/post/hpg-slice.html">切片(slice)性能及陷阱 | Go 语言高性能编程 | 极客兔兔 </a></p><p><a href="https://cloud.tencent.com/developer/article/1496302">什么是A/B test？有哪些流程？有什么用？ - 腾讯云开发者社区-腾讯云</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文已收录到&lt;a href=&quot;https://juejin.cn/post/7194132732492906551&quot;&gt;golang高质量编程与性能调优 | 青训营笔记 - 掘金 (juejin.cn)&lt;/a&gt;，主要记录了对golang高质量编程与性能调优的学习</summary>
    
    
    
    <category term="golang" scheme="https://s-chance.github.io/categories/golang/"/>
    
    
    <category term="学习笔记" scheme="https://s-chance.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="青训营" scheme="https://s-chance.github.io/tags/%E9%9D%92%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>Go 工程进阶</title>
    <link href="https://s-chance.github.io/2023/01/26/golang-day2/"/>
    <id>https://s-chance.github.io/2023/01/26/golang-day2/</id>
    <published>2023-01-26T10:01:52.000Z</published>
    <updated>2023-01-30T13:29:21.864Z</updated>
    
    <content type="html"><![CDATA[<p>本文已收录到<a href="https://juejin.cn/post/7193685237723824187">golang工程进阶 | 青训营笔记 - 掘金 (juejin.cn)</a>，主要记录了对golang工程开发的学习<span id="more"></span></p><h2 id="语言进阶"><a class="markdownIt-Anchor" href="#语言进阶"></a> 语言进阶</h2><h3 id="1并发-vs-并行"><a class="markdownIt-Anchor" href="#1并发-vs-并行"></a> 1.并发 VS 并行</h3><ul><li>并发：多线程程序在一个核的CPU上运行</li><li>并行：多线程程序在多个核的CPU上运行</li></ul><p>go语言可以充分发挥多核优势，高效运行</p><h4 id="11-goroutine"><a class="markdownIt-Anchor" href="#11-goroutine"></a> 1.1 Goroutine</h4><ul><li>线程：用户态，轻量级线程，栈MB级别</li><li>协程：内核态，线程跑多个协程，栈KB级别</li></ul><p><strong>关于用户态和内核态的区别</strong></p><p>用户态和内核态是操作系统的两种运行级别。</p><p>当程序运行在3级特权级上时，就可以称之为运行在用户态，这是最低特权级，是普通用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态。</p><p>当程序运行在0级特权级上时，就可以称之为运行在内核态。</p><p>运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。用户态下的程序在其需要操作系统帮助完成某些它没有权限和能力完成的工作时就会切换到内核态，比如操作硬件。</p><p>这两种状态的主要差别是</p><ul><li>处于用户态执行时，进程所能访问的内存空间和对象受到限制，其处于占用的处理器是可被抢占的</li><li>处于内核态执行时，能够访问使用的内存空间和对象，且所占有的处理器是不允许被抢占的</li></ul><p><strong>快速打印</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello goroutine: &quot;</span> + fmt.Sprint(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloGoRoutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            hello(j)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-csp"><a class="markdownIt-Anchor" href="#12-csp"></a> 1.2 CSP</h4><p>CSP(Communicating Sequential Processes)是一种并发模型。在go语言中提倡通过通信共享内存而不是通过共享内存而实现通信（像Java、C++、Python等都是通过共享内存来实现通信），go语言通过goroutine和channel实现通过通信共享内存，这是go语言的独特优势。</p><h4 id="13-channel"><a class="markdownIt-Anchor" href="#13-channel"></a> 1.3 Channel</h4><p>通道channel是用来传递数据的一个数据结构。通道可用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;-用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。</p><p>创建通道，通道分为无缓冲通道和有缓冲通道，在创建时指定参数即可。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">//无缓冲通道</span></span><br><span class="line">buf := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>) <span class="comment">//有缓冲通道,缓冲区大小为100</span></span><br></pre></td></tr></table></figure><p>通道的基本使用</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">//把v发送到通道ch</span></span><br><span class="line">v := &lt;- ch <span class="comment">//从通道ch接收数据,并赋值给v</span></span><br></pre></td></tr></table></figure><p>一个示例</p><ul><li><p>一个子协程发送0~9数字</p></li><li><p>另一个子协程计算输入数字的平方</p></li><li><p>主协程输出结果</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CalSqrt</span><span class="params">()</span></span> &#123;</span><br><span class="line">    src := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    dest := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(src)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            src &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(dest)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> src &#123;</span><br><span class="line">            dest &lt;- i * i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dest &#123;</span><br><span class="line">        <span class="built_in">println</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="14-并发安全-lock"><a class="markdownIt-Anchor" href="#14-并发安全-lock"></a> 1.4 并发安全 Lock</h4><p>对变量执行大量重复操作，使用多个协程并发执行，利用锁来保证最终结果的正确性</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">x    <span class="type">int64</span></span><br><span class="line">    lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addWithLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++ &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        lock.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> addWithLock()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    <span class="built_in">println</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-waitgroup"><a class="markdownIt-Anchor" href="#15-waitgroup"></a> 1.5 WaitGroup</h4><p>waitgroup是go语言应用开发过程中经常使用的并发控制技术。其内部通过一个计数器来统计协程，这个计数器的值需要在启动协程之前用Add方法初始化，在结束一个协程的时候使用Done方法将计数器-1</p><p>当开启一个协程时，计数器+1；当一个协程执行完时，计数器-1；主线程会一直阻塞直到计数器为0。</p><p>改造前面的协程快速打印的示例，使用waitgroup实现协程的同步阻塞。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoWait</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">5</span>)  <span class="comment">//先初始化计数器再启动协程</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            hello(j) <span class="comment">//hello函数参考前面的例子</span></span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖管理"><a class="markdownIt-Anchor" href="#依赖管理"></a> 依赖管理</h2><p>go语言依赖管理的演进路线和go module实践。</p><p>依赖指各种开发包或者库，利用已经封装好的、经过验证的开发组件或工具，能够大大提升开发效率。</p><p>对于简单的程序来说，只需要依赖原生的SDK即可。对于实际工程来说，更多的是关注业务逻辑的实现，涉及框架、日志、驱动driver以及collection等一系列依赖都会通过sdk的方式引入，因此就需要对依赖包进行管理。</p><p>go依赖管理的演进主要经历了3个阶段，从GOPATH到Go Vendor再到目前被广泛应用的Go Module。主要围绕实现两个目标来迭代发展</p><ul><li>不同环境（项目）依赖的版本不同</li><li>控制依赖库的版本</li></ul><h3 id="gopath"><a class="markdownIt-Anchor" href="#gopath"></a> GOPATH</h3><p>GOPATH是go语言支持的一个环境变量，是go项目的工作区。根目录有以下结构</p><ul><li>src：存放go项目的源码</li><li>pkg：存放编译的中间产物，加快编译速度</li><li>bin：存在go项目编译生成的二进制文件</li></ul><p><strong>GOPATH的弊端</strong></p><p>GOPATH无法实现package的多版本控制。同一个pkg，存在两个版本，有两个项目依赖不同的版本，但是src下只能存放一个版本，那么就无法保证两个版本的项目都能通过编译。就是说在GOPATH管理模式下，如果多个项目依赖同一个库，则该库只能是同一份代码，无法实现多个项目依赖同一个库的不同版本。于是Go Vendor应运而生。</p><h3 id="go-vendor"><a class="markdownIt-Anchor" href="#go-vendor"></a> Go Vendor</h3><p>Go Vendor在GOPATH的基础上增加了vendor目录，用于存放当前项目依赖的副本。在Vendor机制下，如果当前目录存在vendor目录，则会优先使用该目录下的依赖，如果依赖不存在，再从GOPATH中寻找。这样，通过每个项目引入一份依赖副本，解决了多个项目需要同一个package依赖的冲突问题。但是vendor无法很好解决依赖包版本变动问题和一个项目依赖同一个包的不同版本的问题。实质上，vendor并不能很清晰地标识依赖的版本概念，无法控制依赖的版本，更新项目又可能导致依赖冲突、编译出错。于是又诞生了Go Module。</p><h3 id="go-module"><a class="markdownIt-Anchor" href="#go-module"></a> Go Module</h3><p>Go Module是go语言官方推出的依赖管理系统，解决了之前依赖管理系统存在的诸多问题。Go Module在go语言1.11版本开始引入，在go语言1.16版本默认开启。习惯上将Go Module称为go mod。</p><ul><li>通过go.mod文件管理依赖包版本</li><li>通过go get/go mod指令工具管理依赖包</li></ul><p>go mod最终目标是定义版本规则和管理项目依赖关系。（相当于Java中的Maven）</p><h3 id="依赖管理三要素"><a class="markdownIt-Anchor" href="#依赖管理三要素"></a> 依赖管理三要素</h3><table><thead><tr><th style="text-align:center">要素</th><th style="text-align:center">对应工具</th></tr></thead><tbody><tr><td style="text-align:center">配置文件，描述依赖</td><td style="text-align:center">go.mod</td></tr><tr><td style="text-align:center">中心仓库管理依赖库</td><td style="text-align:center">Proxy</td></tr><tr><td style="text-align:center">本地工具</td><td style="text-align:center">go get / go mod</td></tr></tbody></table><h3 id="依赖配置go-mod"><a class="markdownIt-Anchor" href="#依赖配置go-mod"></a> 依赖配置——go mod</h3><p>使用模块路径来标识一个模块，从模块路径找到该模块，如果是github前缀则表示可以从github仓库中找到该模块，依赖包的源代码由github托管，如果项目的子包需要被单独引用，则通过单独的init go.mod文件进行管理。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">module example/project/app <span class="comment">//依赖管理基本单元</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.16</span> <span class="comment">//原生sdk版本</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    <span class="comment">// 单元依赖</span></span><br><span class="line">    <span class="comment">// 依赖标识:模块路径+版本</span></span><br><span class="line">example/lib1 v1<span class="number">.0</span><span class="number">.2</span></span><br><span class="line">    example/lib2 v1<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="依赖配置version"><a class="markdownIt-Anchor" href="#依赖配置version"></a> 依赖配置——version</h3><p>GOPATH和Go Vendor都是源码副本形式的依赖，没有版本规则的概念，而go mod为了方便管理定义了版本规则，分为语义化版本和基于commit的伪版本。</p><ul><li><p>语义化版本有三个部分<code>$&#123;MAJOR&#125;.$&#123;MINOR&#125;.$&#123;PATCH&#125;</code>，如v1.3.0，v2.3.0</p><p>不同的MAJOR版本表示是不兼容的API，所以即使是同一个库，MAJOR版本不同也会被认为是不同的模块。</p><p>MINOR版本通常是新增函数或功能，向后兼容。</p><p>PATCH版本一般是修复bug。</p></li><li><p>基于commit的伪版本也有三个部分<code>vX.0.0-yyyymmddhhmmss-abcdefgh1234</code></p><p>基础版本前缀和语义化版本是一样的。</p><p>时间戳，也就是提交commit的时间。</p><p>最后是校验码，包含12位的哈希前缀。每次commit后go都会默认生成一个伪版本号。</p></li></ul><h3 id="依赖配置indirect"><a class="markdownIt-Anchor" href="#依赖配置indirect"></a> 依赖配置——indirect</h3><p>依赖单元中的特殊标识符，indirect后缀，表示go.mod对应的当前模块没有直接导入该依赖模块的包，也就是间接依赖。</p><h3 id="依赖配置incompatible"><a class="markdownIt-Anchor" href="#依赖配置incompatible"></a> 依赖配置——incompatible</h3><p>在主版本为v2及以上的模块后面会有+incompatible后缀，这让go mod能够按照不同的模块来处理同一个项目不同主版本的依赖。由于go mod是在go1.11版本才开始引入，在这个更新之前已经有一些仓库打上了v2或者更高的版本tag。为了兼容这部分仓库，对于没有go.mod文件且MAJOR主版本在v2及以上的依赖，会在版本号后面加上<code>+incompatible</code>的后缀，表示可能存在不兼容的源代码。</p><h3 id="依赖配置依赖图"><a class="markdownIt-Anchor" href="#依赖配置依赖图"></a> 依赖配置——依赖图</h3><p>如果一个主项目依赖A、B两个项目，A、B分别依赖C项目v1.3、v1.4的两个版本，则最终编译时所使用的C项目版本为最低的兼容版本，即v1.4。</p><h3 id="依赖分发回源"><a class="markdownIt-Anchor" href="#依赖分发回源"></a> 依赖分发——回源</h3><p>依赖分发，也就是指go mod从哪里下载，如何下载。</p><p>Go Modules系统中定义的依赖最终可以对应到多版本代码管理系统中某一项目的特定提交或版本，这样的话，对于go.mod中定义的依赖，则直接可以从对应仓库中下载指定软件依赖，从而完成依赖分发。</p><p>但直接使用版本管理仓库下载依赖，存在诸多问题</p><ul><li>无法保证构建确定性，软件作者可以直接在代码平台 增加/修改/删除 软件版本，导致下次构建时使用另外版本的依赖或者找不到依赖版本。</li><li>无法保证依赖可用性，依赖软件作者可以直接在代码平台删除软件，导致依赖不可用。</li><li>增加第三方压力，每次从第三方代码托管平台下载依赖时都会增加第三方代码托管平台的压力。</li></ul><h3 id="依赖分发proxy"><a class="markdownIt-Anchor" href="#依赖分发proxy"></a> 依赖分发——Proxy</h3><p>Go Proxy就是解决上述的依赖分发问题。Go Proxy是一个服务站点，它会缓存源站中的软件内容，缓存的软件版本不会改变，并且在源站软件删除之后依然能够下载，从而实现了immutability（不变性）和available（可用的）的依赖分发。</p><p>使用Go Proxy之后，构建时会直接从Go Proxy站点拉取依赖。</p><h3 id="依赖分发变量-goproxy"><a class="markdownIt-Anchor" href="#依赖分发变量-goproxy"></a> 依赖分发——变量 GOPROXY</h3><p>Go Modules通过GOPROXY环境变量使用Go Proxy服务。GOPROXY是一个Go Proxy站点URL列表，可以使用&quot;direct&quot;表示源站。</p><p>示例配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GOPROXY=<span class="string">&quot;https://proxy1.cn, https://proxy2.cn, direct&quot;</span></span><br></pre></td></tr></table></figure><p>对于以上配置，整体的依赖寻址路径会先从proxy1下载，如果proxy1不存在，再从proxy2寻找，如果proxy2不存在，则回源到源站直接下载依赖，并缓存到proxy站点中。</p><h3 id="工具go-get"><a class="markdownIt-Anchor" href="#工具go-get"></a> 工具——go get</h3><p>go get是Go Module的两个重要工具之一。</p><p>go get使用命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get example.org/pkg...</span><br></pre></td></tr></table></figure><p>以上命令后面接不同的指令，这些指令具有不同的作用</p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">@update</td><td style="text-align:center">默认</td></tr><tr><td style="text-align:center">@none</td><td style="text-align:center">删除依赖</td></tr><tr><td style="text-align:center">@v1.1.2</td><td style="text-align:center">下载指定tag版本，语义版本</td></tr><tr><td style="text-align:center">@23dfdd5</td><td style="text-align:center">特定的commit</td></tr><tr><td style="text-align:center">@master</td><td style="text-align:center">分支的最新commit</td></tr></tbody></table><h3 id="工具go-mod"><a class="markdownIt-Anchor" href="#工具go-mod"></a> 工具——go mod</h3><p>go mod也是Go Module中的重要工具。</p><p>go mod 使用命令</p><p>初始化，创建go.mod文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod init</span><br></pre></td></tr></table></figure><p>下载模块到本地缓存</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod download</span><br></pre></td></tr></table></figure><p>增加需要的依赖，删除不需要的依赖</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><p>在实际开发中，建议在向仓库提交代码之前执行<code>go mod tidy</code>，可以减少构建时无效依赖包的拉取。</p><p><strong>使用go mod前的一些注意事项</strong></p><ul><li>设置GO111MODULE=on，表示只使用Go Module而不会使用GOPATH。具体配置参考<a href="https://goproxy.cn/">七牛云 - Goproxy.cn</a></li><li>清空IDE中的所有的GOPATH。go mod和GOPATH不能并存，开启go mod之后需要在IDE中把项目从GOPATH移除，否则可能会出错。</li><li>在项目中创建go.mod文件，如果已经存在则不需要重新创建。创建完go.mod文件后先执行<code>go mod tidy</code>来增加项目启动所需的最小依赖。</li></ul><h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2><p>在实际工程开发中，除了依赖管理，还有另一个重要概念就是单元测试，包括单元测试规范、Mock测试、基准测试。测试关系着系统的质量，质量决定线上系统的稳定性，一旦出现问题就会引起事故。测试就是为了避免这些事故。</p><p>测试一般分为回归测试，集成测试和单元测试。回归测试一般是手动通过终端回归一些固定的主流场景，集成测试是对系统功能维度做测试验证，而单元测试阶段，开发者对单独的函数、模块做功能验证，层级至上而下，测试成本逐渐降低，测试覆盖率逐步上升。因此单元测试的覆盖率一定程度上决定了代码的质量。</p><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><p>单元测试主要包括输入、测试单元、输出，以及校对。单元的概念比较广泛，包括接口、函数、模块等。最后的校对用于保证代码的功能符合预期。单元测试一方面可以保证质量，在整体覆盖率足够的情况下，一定程度上即保证了新功能本身的正确性，又保护了原有代码的完整性；另一方面可以提升效率，在代码存在bug的情况下，通过单元测试，可以在较短周期内定位和修复问题。</p><h4 id="规则"><a class="markdownIt-Anchor" href="#规则"></a> 规则</h4><p>单元测试的一些基本规范</p><ul><li>所有测试文件名称以_test.go结尾</li><li>所有用于测试的函数声明为<code>func TestXxx(t *testing.T)</code></li><li>初始化逻辑放到TestMain函数中实现</li></ul><p>这样就很好地区分了源代码和测试代码。</p><h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h4><p>源代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloTom</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHelloTom</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    output := HelloTom()</span><br><span class="line">    expectOutput := <span class="string">&quot;Tom&quot;</span></span><br><span class="line">    <span class="keyword">if</span> output != expectOutput &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;Expected %s do not match actual %s&quot;</span>, expectOutput, output)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h4><p>运行查看结果</p><h4 id="assert"><a class="markdownIt-Anchor" href="#assert"></a> assert</h4><p>assert包提供了对代码测试的支持，能够快速方便地进行代码测试</p><p>获取assert包，在当前项目中使用以下命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/stretchr/testify/assert</span><br></pre></td></tr></table></figure><p>改造原来的测试代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHelloTom</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    output := HelloTom()</span><br><span class="line">    expectOutput := <span class="string">&quot;Tom&quot;</span></span><br><span class="line">    assert.Equal(t, expectOutput, output)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行查看结果，使用assert测试能够输出更加详细的信息。</p><h4 id="覆盖率"><a class="markdownIt-Anchor" href="#覆盖率"></a> 覆盖率</h4><p>代码覆盖率用于衡量代码是否经过了足够的测试，评价项目的测试水准，评估项目是否达到了高水准测试等级。</p><p><strong>示例代码</strong></p><p>judgment.go</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JudgePassLine</span><span class="params">(score <span class="type">int16</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> score &gt;= <span class="number">60</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>judgment_test.go</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestJudgePassLineTrue</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    isPass := JudgePassLine(<span class="number">70</span>)</span><br><span class="line">    assert.Equal(t, <span class="literal">true</span>, isPass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用以下命令进行测试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> judgment_test.go judgment.go --cover</span><br></pre></td></tr></table></figure><p>通过指定cover参数，可以看到覆盖率，表示执行到的代码行数占实际代码总行数。</p><p><strong>提升覆盖率</strong></p><p>可以在测试代码中增加其他的情况，重新执行所有单元测试，最终使覆盖率达到100%</p><p>新增测试函数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestJudgePassLineFail</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    isPass := JudgePassLine(<span class="number">50</span>)</span><br><span class="line">    assert.Equal(t, <span class="literal">false</span>, isPass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新执行测试命令，指定cover参数，查看测试结果。</p><h4 id="tips"><a class="markdownIt-Anchor" href="#tips"></a> Tips</h4><ul><li>实际项目中，一般要求覆盖率是50%~60%，对于资金型服务，覆盖率要求达到80%以上。</li><li>在进行单元测试时，要求测试分支相互独立、全面覆盖。</li><li>测试单元粒度足够小，函数职责单一，即要求函数体足够小，这样能比较简单地提升覆盖率，也符合函数设计的单一职责。</li></ul><h3 id="mock测试"><a class="markdownIt-Anchor" href="#mock测试"></a> Mock测试</h3><p>工程中复杂的项目一般会依赖File、DB、Cache等外部依赖，而单元测试需要保证稳定性和幂等性。稳定性指相互隔离，能在任何时间、任何环境下运行测试；幂等是指每次测试运行都应该产生与之前一样的结果。而实现这些目的就需要Mock机制。</p><h4 id="文件处理"><a class="markdownIt-Anchor" href="#文件处理"></a> 文件处理</h4><p>将测试文件进行删除，进行单元测试，测试通过，但单元测试需要依赖本地的文件，如果文件被修改或者删除测试就会失败，也就是说删除文件的测试普通情况下只能测试一次。为了保证测试case的稳定性，需要对删除文件函数进行mock，屏蔽对文件的依赖。</p><h4 id="快速mock函数"><a class="markdownIt-Anchor" href="#快速mock函数"></a> 快速Mock函数</h4><p>这里提供了一个开源的mock测试库<a href="https://github.com/bouk/monkey">Monkey patching in Go</a>，可以对函数或者实例的方法进行mock测试，原理是反射和指针赋值。这里引入了一个打桩的概念，桩或者桩代码就是指用来代替关联代码或者未实现代码的代码，目的主要是隔离、补齐、控制。</p><p>快速Mock函数能为一个函数打桩或为一个方法打桩。Monkey Patch的作用域在Runtime，在运行时通过Go的unsafe包，能够将内存中函数的地址替换为运行时函数的地址，将待打桩函数或方法的实现跳转到运行时。</p><h4 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h4><p>通过patch对ReadFirstLine进行打桩mock，通过defer卸载mock，使整个测试函数脱离了对本地文件的依赖。</p><p>源代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFirstLine</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    open, err := os.Open(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> open.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    scanner := bufio.NewScanner(open)</span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        <span class="keyword">return</span> scanner.Text()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessFirstLine</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    line := ReadFirstLine()</span><br><span class="line">    destLine := strings.ReplaceAll(line, <span class="string">&quot;11&quot;</span>, <span class="string">&quot;00&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> destLine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestProcessFirstLine</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    firstLine := ProcessFirstLine()</span><br><span class="line">    assert.Equal(t, <span class="string">&quot;line00&quot;</span>, firstLine)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试文件内容</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">line11</span><br><span class="line">line22</span><br><span class="line">line33</span><br><span class="line">line44</span><br><span class="line">line55</span><br></pre></td></tr></table></figure><p>monkey的部分源代码实现，主要通过这些函数实现打桩</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Patch</span><span class="params">(target, replacement <span class="keyword">interface</span>&#123;&#125;)</span></span> *PatchGuard &#123;</span><br><span class="line">    t := reflect.ValueOf(target)</span><br><span class="line">    r := reflect.ValueOf(replacement)</span><br><span class="line">    patchValue(t, r)</span><br><span class="line">    <span class="keyword">return</span> &amp;PatchGuard&#123;t, r&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unpatch</span><span class="params">(target <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unpatchValue(reflect.ValueOf(target))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造测试代码增加函数实现打桩，通过patch对ReadFirstLine进行打桩mock，使其默认返回line110</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReadFirstLineWithMock</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">monkey.Patch(ReadFirstLine, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;line110&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">defer</span> monkey.Unpatch(ReadFirstLine)</span><br><span class="line">line := ProcessFirstLine()</span><br><span class="line">assert.Equal(t, <span class="string">&quot;line000&quot;</span>, line)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样即使没有本地文件，也能够模拟读取、修改或删除文件的测试。</p><h3 id="基准测试"><a class="markdownIt-Anchor" href="#基准测试"></a> 基准测试</h3><p>go语言还提供了基准测试框架，基准测试是指测试一段程序的运行性能及耗费CPU的程度。在实际项目开发中，经常会遇到代码性能瓶颈，为了定位问题经常要对代码做性能分析，这就用到了基准测试。</p><h4 id="示例-3"><a class="markdownIt-Anchor" href="#示例-3"></a> 示例</h4><p>服务器负载均衡问题。</p><p>源代码，假设有10台服务器，每次随机选择其中1台执行。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitServerIndex</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">ServerIndex[i] = i + <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Select</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ServerIndex[rand.Intn(<span class="number">10</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码，基准测试以Benchmark开头，参数类型是testing.B，用b中的N值反复递增循环测试。基准测试对于一个测试用例的默认测试时间是1秒，当测试用例函数返回时还不到1秒，那么testing.B中的N值将按1、2、5、10、20、50…递增，并以递增后的值重新进行用例函数测试。</p><p>ResetTimer重置计时器，在重置之前的初始化或其他准备操作，不属于基准测试的范围，通过选择重置的时间点来跳过不必要的测试。</p><p>RunParallel是多协程并发测试。执行两个基准测试，可以发现代码在并发情况下存在劣化，主要原因是rand包为了保证全局的随机性和并发安全，使用了全局锁。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSelect</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">InitServerIndex()</span><br><span class="line">b.ResetTimer()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">Select()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSelectParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">InitServerIndex()</span><br><span class="line">b.ResetTimer()</span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">Select()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行-2"><a class="markdownIt-Anchor" href="#运行-2"></a> 运行</h4><p>在IDE中使用<code>gobench benchmark</code>选项进行测试，不要直接运行。</p><h4 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h4><p>为了解决上述的随机性能瓶颈问题，有一个开源的高性能随机数方法fastrand，仓库地址<a href="https://github.com/bytedance/gopkg">bytedance/gopkg</a>。主要思路是牺牲了一定的数列一致性来换取性能，在大多数场景下适用，相比原始方法的性能有大幅提升。</p><p>引入fastrand</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/bytedance/gopkg</span><br></pre></td></tr></table></figure><p>将源代码中的rand替换为fastrand即可。</p><h2 id="项目实战"><a class="markdownIt-Anchor" href="#项目实战"></a> 项目实战</h2><p>在并发编程，依赖管理以及单元测试的基础上，通过项目实践来理解项目开发的思路和流程，主要包括需求设计，代码开发和测试运行。</p><h3 id="需求设计"><a class="markdownIt-Anchor" href="#需求设计"></a> 需求设计</h3><h4 id="需求背景"><a class="markdownIt-Anchor" href="#需求背景"></a> 需求背景</h4><p>开发一个类似掘金社区的服务端小功能。</p><h4 id="需求描述"><a class="markdownIt-Anchor" href="#需求描述"></a> 需求描述</h4><p>社区话题页面</p><ul><li>展示话题（标题、文字描述）和回帖列表</li><li>暂不考虑前端页面实现，仅仅实现一个本地web服务</li><li>话题和回帖数据用文件存储</li></ul><h4 id="需求用例"><a class="markdownIt-Anchor" href="#需求用例"></a> 需求用例</h4><p>主要涉及用户浏览消费，页面的展示，包括话题内容和回帖的列表。可以先抽象出两个实体，话题内容和回帖列表，分析它们所具有的属性以及联系，定义出结构体。</p><h4 id="er-图entity-relationship-diagram"><a class="markdownIt-Anchor" href="#er-图entity-relationship-diagram"></a> ER 图——Entity Relationship Diagram</h4><p>ER图用于描述现实世界的概念模型。有了模型实体、属性以及联系，就能进入下一步，思考代码结构设计。</p><p>参考ER图设计：Topic话题有id、titile、content、create_time四个属性。Post帖子有id、topic_id、content、create_time四个属性，其中id和topic_id和Topic相联系。</p><p>这里采用典型的分层结构设计。</p><h3 id="代码开发"><a class="markdownIt-Anchor" href="#代码开发"></a> 代码开发</h3><h4 id="分层结构"><a class="markdownIt-Anchor" href="#分层结构"></a> 分层结构</h4><p>分层结构整体分为三层，repository数据层，service逻辑层，controller视图层。</p><ul><li>数据层关联底层数据模型，也就是model，封装外部数据的增删改查。这里的数据存储在本地文件，通过文件操作拉取话题，帖子数据。</li><li>数据层面向逻辑层，也就是对service层透明，屏蔽下游数据差异，即逻辑层不需要考虑数据的来源是本地文件、数据库还是微服务等。逻辑层只处理核心业务逻辑，接口模型保持不变，计算打包业务实体Entity，对应需求并上传给视图层。</li><li>视图层controller负责处理与外部交互的逻辑，以view视图的形式返回给客户端。这里只考虑封装为json格式化的请求结果，通过API形式访问即可。</li></ul><h4 id="组件工具"><a class="markdownIt-Anchor" href="#组件工具"></a> 组件工具</h4><p>开发涉及的基础组件工具。Gin：开源的高性能go web框架，源地址<a href="https://github.com/gin-gonic/gin">gin-gonic</a>。这里基于gin搭建web服务器，本项目主要涉及路由分发的概念，不涉及其他复杂概念。</p><p>使用web框架，需要用Go Module依赖管理。先用go mod init初始化go.mod管理配置文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod init main</span><br><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><p>下载gin依赖</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><p>在框架依赖的基础上，只需要关注业务本身的实现，从repository到service再到controller逐步实现。</p><h4 id="repository"><a class="markdownIt-Anchor" href="#repository"></a> Repository</h4><h5 id="struct"><a class="markdownIt-Anchor" href="#struct"></a> struct</h5><p>根据之前的ER图定义结构体</p><h5 id="index"><a class="markdownIt-Anchor" href="#index"></a> index</h5><p>查询数据可以使用全扫描遍历的方式，但是效率不高，所以这里引入索引的概念。</p><p>索引就像书的目录，可以快速查找定位到需要的结果。这里利用map实现内存索引，在服务对外暴露前，利用文件元数据初始化全局内存索引，实现O(1)时间复杂度的查找操作。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">topicIndexMap <span class="keyword">map</span>[<span class="type">int64</span>]*Topic</span><br><span class="line">    postIndexMap  <span class="keyword">map</span>[<span class="type">int64</span>][]*Post</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>具体实现，打开文件，基于file初始化scanner，通过迭代器方式遍历数据行，转化为结构体存储至内存map，完成初始化话题内存索引。同理实现帖子的内存索引初始化</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initTopicIndexMap</span><span class="params">(filePath <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    open, err := os.Open(filePath + <span class="string">&quot;topic&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    scanner := bufio.NewScanner(open)</span><br><span class="line">    topicTmpMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]*Topic)</span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        text := scanner.Text()</span><br><span class="line">        <span class="keyword">var</span> topic Topic</span><br><span class="line">        <span class="keyword">if</span> err := json.Unmarshal([]<span class="type">byte</span>(text), &amp;topic); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        topicTmpMap[topic.Id] = &amp;topic</span><br><span class="line">    &#125;</span><br><span class="line">    topicIndexMap = topicTmpMap</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h5><p>实现查询操作，直接查询key获取map中的value。这里使用了sync.Once，主要适用于高并发的情况下只执行一次的场景。基于Once的实现模式就是单例模式，减少存储的浪费。</p><p>topic查询实现，这里的topic结构体自行设计。同理实现post的查询</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TopicDao <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">topicDao  *TopicDao</span><br><span class="line">    topicOnce sync.Once</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTopicDaoInstance</span><span class="params">()</span></span> *TopicDao &#123;</span><br><span class="line">    topicOnce.Do(</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            topicDao = &amp;TopicDao&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">return</span> topicDao</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*TopicDao)</span></span> QueryTopicById(id <span class="type">int64</span>) *Topic &#123;</span><br><span class="line">    <span class="keyword">return</span> topicIndexMap[id]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="service"><a class="markdownIt-Anchor" href="#service"></a> Service</h4><p>实现了repository层之后就是service层。</p><p>定义service层实体</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PageInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Topic *repository.Topic</span><br><span class="line">    PostList []*repository.Post</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现流程是参数校验、准备数据、组装实体。</p><p>代码流程编排，通过err控制流程退出，正常的话会返回页面信息。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *QueryPageInfoFlow)</span></span> Do() (*PageInfo, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> err := f.checkParam(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := f.prepareInfo(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := f.packPageInfo(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f.pageInfo, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prepareInfo方法实现，由于话题和回帖信息的获取都需要topicId，这就可以考虑并行执行，提高效率。并行可以充分利用多核CPU的资源，降低接口耗时。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *QueryPageInfoFlow)</span></span> prepareInfo() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;...&#125; <span class="comment">//获取topic信息</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;...&#125; <span class="comment">//获取post列表</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="controller"><a class="markdownIt-Anchor" href="#controller"></a> Controller</h4><p>service层之后是controller层。定义一个view对象，通过code msg打包业务状态信息，用data承载业务实体信息。</p><p>参考代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PageData <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code <span class="type">int64</span>       <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">    Msg  <span class="type">string</span>      <span class="string">`json:&quot;msg&quot;`</span></span><br><span class="line">    Data <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QueryPageInfo</span><span class="params">(topicIdStr <span class="type">string</span>)</span></span> *PageData &#123;</span><br><span class="line">    topicId, err := strconv.ParseInt(topicIdStr, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;...&#125;</span><br><span class="line">    pageInfo, err := service.QueryPageInfo(topicId)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;PageData&#123;</span><br><span class="line">        Code: <span class="number">0</span>,</span><br><span class="line">        Msg: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">        Data: <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>&#123;</span><br><span class="line">            <span class="string">&quot;post_id&quot;</span>: postId,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="router"><a class="markdownIt-Anchor" href="#router"></a> Router</h4><p>最后是web服务的引擎配置，包括</p><ul><li>初始化数据索引</li><li>初始化引擎配置</li><li>构建路由</li><li>启动服务</li></ul><p>path映射到具体的controller，通过path变量传递话题id。</p><p>参考写法</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := Init(<span class="string">&quot;./data/&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        os.Exit(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/community/page/get/:id&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        topicId := c.Param(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">        data := controller.QueryPageInfo(topicId)</span><br><span class="line">        c.JSON(<span class="number">200</span>, data)</span><br><span class="line">    &#125;)</span><br><span class="line">    err := r.Run()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试运行"><a class="markdownIt-Anchor" href="#测试运行"></a> 测试运行</h3><p>通过go run命令运行本地web服务，main.go是这里main方法所在的go文件，文件名称可以自定义</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure><p>通过curl命令请求服务暴露的接口，查看结果。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --location --request GET <span class="string">&quot;http://0.0.0.0:8080/community/get/1&quot;</span> | json</span><br></pre></td></tr></table></figure><p>这里的json命令是通过nodejs的npm安装的，用于格式化curl输出的json信息。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g json</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://www.cnblogs.com/gizing/p/10925286.html">用户态和内核态的区别 - Gizing - 博客园 (cnblogs.com)</a></p><p><a href="https://segmentfault.com/a/1190000018150987">Go goroutine理解 - golang开发笔记 - SegmentFault 思否</a></p><p><a href="https://www.runoob.com/go/go-concurrent.html">Go 并发 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://juejin.cn/post/7181812988461252667">深入理解 go sync.Waitgroup - 掘金 (juejin.cn)</a></p><p><a href="https://blog.csdn.net/Sihang_Xie/article/details/124851399">【Go语言入门】一文搞懂Go语言的最新依赖管理：go mod的使用</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文已收录到&lt;a href=&quot;https://juejin.cn/post/7193685237723824187&quot;&gt;golang工程进阶 | 青训营笔记 - 掘金 (juejin.cn)&lt;/a&gt;，主要记录了对golang工程开发的学习</summary>
    
    
    
    <category term="golang" scheme="https://s-chance.github.io/categories/golang/"/>
    
    
    <category term="学习笔记" scheme="https://s-chance.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="青训营" scheme="https://s-chance.github.io/tags/%E9%9D%92%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>Go语言基础</title>
    <link href="https://s-chance.github.io/2023/01/26/golang-day1/"/>
    <id>https://s-chance.github.io/2023/01/26/golang-day1/</id>
    <published>2023-01-25T18:24:18.000Z</published>
    <updated>2023-01-30T13:28:53.275Z</updated>
    
    <content type="html"><![CDATA[<p>本文已收录到<a href="https://juejin.cn/post/7192662401240531004">golang基础学习 | 青训营笔记 - 掘金 (juejin.cn)</a>，主要记录了对golang的初步学习<span id="more"></span></p><h2 id="11-什么是go语言"><a class="markdownIt-Anchor" href="#11-什么是go语言"></a> 1.1 什么是Go语言</h2><h3 id="1高性能-高并发"><a class="markdownIt-Anchor" href="#1高性能-高并发"></a> 1.高性能、高并发</h3><p>拥有和C++、Java媲美的性能，拥有对高并发的支持，不需要额外的第三方库，只需要使用标准库或者基于标准库的第三方库就能进行高并发开发</p><h3 id="2语法简单-学习曲线平缓"><a class="markdownIt-Anchor" href="#2语法简单-学习曲线平缓"></a> 2.语法简单、学习曲线平缓</h3><p>语法风格类似C语言，且在C语言的基础上进行了大幅度简化，例如去掉了不必要的表达式括号，循环只有for循环一种方式就能实现各种数值、键值遍历</p><p>一个基于Go的简单的Http服务器demo</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(http.Dir(<span class="string">&quot;.&quot;</span>)))</span><br><span class="line">    http.ListenAndServer(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3丰富的标准库"><a class="markdownIt-Anchor" href="#3丰富的标准库"></a> 3.丰富的标准库</h3><p>拥有及其丰富、功能完善、质量可靠的标准库。在很多情况下，不需要借助第三方库就可以完成大部分基础功能的开发，大大降低了学习和使用成本。最关键的是，标准库具有很高的稳定性和兼容性保障，还能持续享受语言迭代所带来的性能优化。这是第三方库所不具备的</p><h3 id="4完善的工具链"><a class="markdownIt-Anchor" href="#4完善的工具链"></a> 4.完善的工具链</h3><p>拥有丰富的工具链，编译、代码格式化、错误检查、帮助文档、包管理以及代码补全提示。Go还内置了完整的单元测试框架，支持单元测试、性能测试、代码覆盖率、数据键增检测、性能优化，保障代码能够正确稳定运行</p><h3 id="5静态链接"><a class="markdownIt-Anchor" href="#5静态链接"></a> 5.静态链接</h3><p>在Go语言中所有的编译结构默认为静态链接，只需要编译后的唯一一个可执行文件不需要附加任何其它东西，即可部署运行。在线上的容器环境中运行，镜像体积可以控制得非常小，部署非常方便快捷。不同于C++，需要一堆动态链接库（linux下表现为.so文件，win下是.dll文件以及由.dll生成的.lib文件）才可以正确运行，文本不正确的话就会崩溃。Java则需要附加一个庞大的JRE才能运行</p><h3 id="6快速编译"><a class="markdownIt-Anchor" href="#6快速编译"></a> 6.快速编译</h3><p>Go语言拥有静态语言中几乎最快的编译速度，增量编译完成。这个速度对C++开发来说不可想象</p><h3 id="7跨平台"><a class="markdownIt-Anchor" href="#7跨平台"></a> 7.跨平台</h3><p>Go语言能在常见的linux、windows、macos，也能够开发android、ios软件，还能在一些硬件设备上运行，例如路由器、树莓派。Go还拥有很方便的交叉编译特性，能够轻松在笔记本上编译出二进制文件拷贝到路由器中运行，而无需配置交叉编译环境</p><h3 id="8垃圾回收"><a class="markdownIt-Anchor" href="#8垃圾回收"></a> 8.垃圾回收</h3><p>Go语言自带垃圾回收机制，和Java类似，在开发的时候无需考虑内存的分配和释放，可以专注于业务逻辑</p><h2 id="12-哪些公司在使用go语言"><a class="markdownIt-Anchor" href="#12-哪些公司在使用go语言"></a> 1.2 哪些公司在使用Go语言</h2><p>ByteDance字节跳动、Google谷歌、Tencent腾讯、facebook脸书、bilibili哔哩哔哩等</p><p>在云计算、微服务、大数据、区块链、物联网等领域广泛发展，尤其在云计算、微服务领域产出了大量的云原生组件</p><h2 id="13-为什么选择go语言"><a class="markdownIt-Anchor" href="#13-为什么选择go语言"></a> 1.3 为什么选择Go语言</h2><ol><li>随着业务体量的不断增长，Python对于Web业务存在性能瓶颈</li><li>C++的特性使其不太适合在线Web业务</li><li>Go的学习难度低于Java</li><li>Go的性能比较好</li><li>Go的部署简单，学习成本低（没有Python的依赖库版本问题）</li><li>基于Go研发的内部RPC框架和HTTP框架，推动了业务重构</li></ol><h2 id="21-开发环境"><a class="markdownIt-Anchor" href="#21-开发环境"></a> 2.1 开发环境</h2><h3 id="安装golang"><a class="markdownIt-Anchor" href="#安装golang"></a> 安装Golang</h3><p><a href="https://go.dev/">Golang官网</a></p><p><a href="https://studygolang.com/dl">Golang镜像</a></p><p><a href="https://goproxy.cn/">Golang第三方包代理加速下载</a></p><h3 id="配置集成开发环境"><a class="markdownIt-Anchor" href="#配置集成开发环境"></a> 配置集成开发环境</h3><p>以下三种方案选其一即可</p><ol><li><p><a href="https://code.visualstudio.com/">Visual Studio Code</a></p></li><li><p><a href="https://www.jetbrains.com.cn/go/promo">Goland</a></p><p>关于Goland控制台输出#gosetup的多余信息，影响观察。快捷键Ctrl+Alt+shift+/，打开Registry，取消勾选go.run.processes.with.pty。之后#gosetup的信息会被折叠，方便直接观察程序输出结果</p></li><li><p><a href="https://www.gitpod.io/">云开发环境Gitpod</a></p></li></ol><h2 id="22-基础语法"><a class="markdownIt-Anchor" href="#22-基础语法"></a> 2.2 基础语法</h2><h3 id="1hello-world"><a class="markdownIt-Anchor" href="#1hello-world"></a> 1.Hello World</h3><p>main.go文件</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>package main代表这个文件属于main包，main包是程序的入口包</p></li><li><p>fmt包是标准库里的包，主要用于输入输出字符串，格式化字符串</p></li><li><p>func main就是go语言main函数的声明，需要注意的是 <strong>花括号{</strong> 必须和func main写在同一行，否则会报错</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">.\test.go:6:1: syntax error: unexpected semicolon or newline before &#123;</span><br></pre></td></tr></table></figure></li><li><p>在main函数里用fmt.Println调用了fmt包中的Println函数，需要注意的是import的包必须要在程序中使用到，不能只是import这个包而不去使用，会报错</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">.\test.go:3:8: imported and not used: <span class="string">&quot;fmt&quot;</span></span><br></pre></td></tr></table></figure></li></ul><p>编译运行命令（在文件的同级目录下run或者build后执行）</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line">go build main.go</span><br><span class="line">./main</span><br></pre></td></tr></table></figure><ul><li>go run 直接运行go文件</li><li>go build会生成一个exe文件，运行exe文件得到结果</li></ul><h3 id="2变量"><a class="markdownIt-Anchor" href="#2变量"></a> 2.变量</h3><p>go语言是一门强类型语言，每个变量都有各自的变量类型。</p><p>常见的变量类型：字符串、整型、浮点型、布尔型等。</p><p>go语言的字符串是内置类型，可以直接通过+号拼接，也能够直接使用==去比较两个字符串（不同于Java需要使用equals方法去比较）。</p><p>go语言大部分运算符的使用和优先级和C/C++类似。</p><h4 id="变量声明"><a class="markdownIt-Anchor" href="#变量声明"></a> 变量声明</h4><p>在go语言中变量的声明方式有两种</p><p>一种是通过var name string = &quot;&quot;这种方式来声明变量，声明变量的时候一般会自动推导变量的类型，有需要也可以显式写明变量类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;hello&quot;</span>  <span class="comment">//自动推导变量类型</span></span><br><span class="line"><span class="keyword">var</span> t1,t2 <span class="type">int</span>  <span class="comment">//可以声明多个相同类型的变量</span></span><br></pre></td></tr></table></figure><p>另一种变量声明是短声明，使用 变量 := 值 的格式。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">name := <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>需要注意的是使用var声明过的变量名，不能用短声明重复声明。</p><p>go语言的常量，就是用const关键字替代var关键字声明。需要注意的是，go语言中的常量没有一个确定的类型，它会根据上下文来自动确定类型。</p><h3 id="3if-else"><a class="markdownIt-Anchor" href="#3if-else"></a> 3.if else</h3><p>go语言中的if else不同于其他语言</p><p>go语言中if后面没有小括号()</p><p>go语言中if后面必须要有大括号{}，没有C/C++那种缺省大括号写在同一行的写法</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if-else</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">7</span>%<span class="number">22</span>==<span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;7 is even&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;7 is odd&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if后可以加上短声明和判断</span></span><br><span class="line"><span class="keyword">if</span> num := <span class="number">9</span>; num &lt; <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(num, <span class="string">&quot;is negative&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> num &lt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(num, has <span class="number">1</span> digit)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(num, <span class="string">&quot;has multiple digits&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4循环"><a class="markdownIt-Anchor" href="#4循环"></a> 4.循环</h3><p>go语言中没有while循环、do while循环，只有唯一的一种for循环。</p><p>最简单的for循环就是只有for没有循环条件，代表死循环。</p><p>循环中途可以用break跳出，也可以使用经典的循环（初值，阈值，步长），这三段中的任何一段都可以省略。</p><p>在循环里面还可以用continue直接进入下一个循环（在满足循环条件的情况下）</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无条件循环(死循环),使用break跳出循环</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;loop&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 经典循环写法</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">7</span>; j &lt; <span class="number">9</span>; j++ &#123;</span><br><span class="line">    fmt.Println(j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// continue跳过本轮循环,直接进入下一轮循环</span></span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">5</span>; n++ &#123;</span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赋值、判断、增值分开写</span></span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5switch"><a class="markdownIt-Anchor" href="#5switch"></a> 5.switch</h3><p>go语言中的switch分支结构，也类似于C/C++。同样地，go语言的switch后面不需要小括号。</p><p>但是和C/C<ins>的switch不同，在C</ins>里面，switch case后面如果不显式加break会继续执行后面的case；go语言则不需要break，如果要执行后面的case还需要显式加fallthrough关键字。</p><p>相比C/C++，go语言的switch功能更加强大，可以使用任意的变量类型，甚至可以取代任意的if else语句。不在switch后面加任何的变量，在case里面写条件分支，相比多个if else语句，代码逻辑更加清晰</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// switch</span></span><br><span class="line">a := <span class="number">2</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;one&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;two&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;three&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>,<span class="number">5</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;four or five&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6数组"><a class="markdownIt-Anchor" href="#6数组"></a> 6.数组</h3><p>数组是一个具有编号且长度固定的元素序列。</p><p>对于一个数组，可以很方便地取特定索引的值或者在特定索引存储值，但实际开发中，很少直接使用数组，因为其长度是固定的，使用更多的是切片。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组声明,未初始化默认值为0(对于int类型数组)</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line"><span class="comment">// 对索引为4的元素赋值</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(<span class="string">&quot;get:&quot;</span>, a[<span class="number">2</span>]) <span class="comment">//a[2]未初始化,默认是0</span></span><br><span class="line">fmt.Println(<span class="string">&quot;len:&quot;</span>, <span class="built_in">len</span>(a)) <span class="comment">//获取数组a的长度5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 短声明,直接赋值</span></span><br><span class="line">b := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组,可直接赋值,也可以用嵌套循环赋值</span></span><br><span class="line"><span class="keyword">var</span> twoD [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure><h3 id="7切片"><a class="markdownIt-Anchor" href="#7切片"></a> 7.切片</h3><p>切片slice不同于数组array，可以任意更改长度，拥有更多数组不具备的操作。可以使用make来创建切片，使用append来追加元素（注意append的用法，需要把结果返回给原数组）。</p><p>slice的原理是存储了一个长度和一个容量，以及一根指向一个数组的指针。</p><p>在执行append操作时，如果容量不够，就会扩容并返回新的slice。</p><p>slice拥有类似python的切片操作，但不支持负数索引。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 短声明一个string类型的切片,初始化长度为3,容量默认和长度相等</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">3</span>)</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&quot;a&quot;</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="comment">// append追加元素,需要把结果返回给原数组</span></span><br><span class="line"><span class="comment">// 如果容量不够的话,会进行扩容</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>)</span><br><span class="line"><span class="comment">// 复制切片</span></span><br><span class="line">c := <span class="built_in">make</span>([]<span class="type">string</span>,<span class="built_in">len</span>(s))</span><br><span class="line"><span class="built_in">copy</span>(c,s) <span class="comment">//[a b c d e f]</span></span><br><span class="line"><span class="comment">// 切片索引操作</span></span><br><span class="line">fmt.Println(s[<span class="number">2</span>:<span class="number">5</span>]) <span class="comment">// [c d e]</span></span><br><span class="line">fmt.Println(s[:<span class="number">5</span>]) <span class="comment">// [a b c d e]</span></span><br><span class="line">fmt.Println(s[<span class="number">2</span>:]) <span class="comment">// [c d e f]</span></span><br><span class="line"><span class="comment">// 其他初始化方式</span></span><br><span class="line">str := []<span class="type">string</span>&#123;<span class="string">&quot;s&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;r&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="8map"><a class="markdownIt-Anchor" href="#8map"></a> 8.map</h3><p>map在其他语言里又可能被称为哈希或者字典，是实际开发中使用最频繁的数据结构。</p><p>map也可以使用make来创建，创建时需要提供两个类型，key的类型和value的类型。</p><p>map可以存储键值对形式的数据，可以通过delete删除键值对。</p><p>go语言的map是完全无序的，遍历的时候是随机顺序。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 短声明一个key为string类型,value为int类型的map</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">m[<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br><span class="line"><span class="comment">// 删除键值对</span></span><br><span class="line"><span class="built_in">delete</span>(m,<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment">// 其他初始化方式</span></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> m3 = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="9range"><a class="markdownIt-Anchor" href="#9range"></a> 9.range</h3><p>range能够用于快速遍历slice和map，并且代码简洁。</p><p>range遍历数组时会返回两个字，第一个是索引，第二个是对应的值。如果不需要索引可以用下划线来忽略。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">2</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;index:&quot;</span>, i, <span class="string">&quot;num:&quot;</span>, num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;B&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10函数"><a class="markdownIt-Anchor" href="#10函数"></a> 10.函数</h3><p>go语言其他语言不同的是，go语言中函数的变量类型是后置的，且go函数原生支持多个返回值。实际开发中，几乎所有的函数都返回两个值，第一个是真正的返回结果，第二个是错误信息。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断map的值是否存在,返回值和错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exists</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, k <span class="type">string</span>)</span></span> (v <span class="type">string</span>, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    v, ok = m[k]</span><br><span class="line">    <span class="keyword">return</span> v, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11指针"><a class="markdownIt-Anchor" href="#11指针"></a> 11.指针</h3><p>go语言也支持指针，但指针操作相对于C/C++的指针比较局限。指针主要的用途就是对传入参数进行修改。</p><p>使用指针传参和不使用指针传参，主要区别就是有无拷贝的所带来开销以及能否直接修改数据。对于大型结构体来说，开销更大。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span> <span class="params">(n *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *n += <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := <span class="number">5</span></span><br><span class="line">    add(&amp;n)</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12结构体"><a class="markdownIt-Anchor" href="#12结构体"></a> 12.结构体</h3><p>结构体是带类型的字段的集合。可以用结构体的名称作为结构体类型去初始化一个结构体变量，构造的时候需要传入每个字段的初始值。也可以用这种键值对的方式只对一部分字段进行初始化。</p><p>结构体也支持指针，并且使用指针修改结构体能避免结构体的拷贝开销。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name    <span class="type">string</span></span><br><span class="line">    passwd  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化结构体的几种方式</span></span><br><span class="line">    a := user&#123;name: <span class="string">&quot;a&quot;</span>, passwd: <span class="string">&quot;123&quot;</span>&#125;</span><br><span class="line">    b := user&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;123&quot;</span>&#125;</span><br><span class="line">    c := user&#123;name: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">    c.passwd = <span class="string">&quot;123&quot;</span></span><br><span class="line">    <span class="keyword">var</span> d user</span><br><span class="line">    d.name = <span class="string">&quot;a&quot;</span></span><br><span class="line">    d.passwd = <span class="string">&quot;123&quot;</span></span><br><span class="line">    fmt.Println(check(&amp;a, <span class="string">&quot;456&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(u *user, passwd <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> u.passwd == passwd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13结构体方法"><a class="markdownIt-Anchor" href="#13结构体方法"></a> 13.结构体方法</h3><p>结构体方法类似于其他语言中的类成员函数。结构体方法可以选择带指针或不带指针，带指针的话，就是能够去修改结构体，不带指针的话，就是只能获取结构体数据不能修改数据。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对照上面12的user结构体和check函数</span></span><br><span class="line"><span class="comment">// 结构体方法不同于函数,在一开始就指明了结构体类型</span></span><br><span class="line"><span class="comment">// 不需要改动数据时,不带指针操作即可</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span></span> checkPasswd(passwd <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> u.passwd == passwd</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要改动数据时,带指针操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span></span> reset(passwd <span class="type">string</span>) &#123;</span><br><span class="line">    u.passwd = passwd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14错误处理"><a class="markdownIt-Anchor" href="#14错误处理"></a> 14.错误处理</h3><p>错误处理在go语言中的语言习惯做法就是使用一个单独的返回值来传递错误信息。</p><p>不同于Java的异常处理，go语言的处理方式能够很清晰地知道哪个函数返回了错误，并且能用简单的if else来处理错误。</p><p>在函数的返回值类型里面加上error，就代表这个函数可能返回错误。在函数实现的时候，如果出错的话，就可以返回一个nil和error，如果没有出错，就返回原本的结果和nil。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以12的user结构体为例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUser</span><span class="params">(users []user, name <span class="type">string</span>)</span></span> (v *user, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> _, u := <span class="keyword">range</span> users &#123;</span><br><span class="line">        <span class="keyword">if</span> u.name == name  &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;u, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;not found&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15字符串操作"><a class="markdownIt-Anchor" href="#15字符串操作"></a> 15.字符串操作</h3><p>在标准库strings包里面有很多常用的字符串工具函数。</p><ul><li>contains：判断一个字符串里面是否包含另一个字符串</li><li>count：统计字符串中某个字符或字符子串出现的次数</li><li>index：查找某个字符串第一次出现的位置</li><li>join：连接多个字符串，将两个字符串用字符连接起来</li><li>repeat：重复多个字符串</li><li>replace：替换字符串</li></ul><h3 id="16字符串格式化"><a class="markdownIt-Anchor" href="#16字符串格式化"></a> 16.字符串格式化</h3><p>在标准库的fmt包里面有很多字符串格式相关的方法。</p><p>go语言的printf类似C语言的printf，不同的是，在go语言中，可以用%v占位符来打印任意类型的变量，而不需要区分数字、字符串，可以用%+v打印详细结果，也可以用%#v打印得更详细。</p><h3 id="17json处理"><a class="markdownIt-Anchor" href="#17json处理"></a> 17.JSON处理</h3><p>go语言的JSON操作非常简单，对于一个结构体，只要保证每个字段的首字母大写（公开字段，相当于Java中的public），那么这个结构体就能用JSON.marshal序列化成JSON字符串。</p><p>序列化之后的字符串也可以用JSON.unmarshal反序列化到一个空变量中。</p><p>默认序列化的字符串风格是大写字母开头，不是下划线，可以用json tag等语法来修改输出结果的字段名。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> userInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name   <span class="type">string</span></span><br><span class="line">    Age    <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">    Hobby  []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := userInfo&#123;Name: <span class="string">&quot;a&quot;</span>, Age: <span class="number">11</span>, Hobby: []<span class="type">string</span>&#123;<span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Typescript&quot;</span>&#125;&#125;</span><br><span class="line">    buf, err := json.Marshal(a) <span class="comment">// 序列化</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="type">string</span>(buf))</span><br><span class="line">    </span><br><span class="line">    buf, err = json.MarshalIndent(a, <span class="string">&quot;&quot;</span>, <span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="type">string</span>(buf))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b userInfo</span><br><span class="line">    err = json.Unmarshal(buf, &amp;b) <span class="comment">// 反序列化到空变量中</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18时间处理"><a class="markdownIt-Anchor" href="#18时间处理"></a> 18.时间处理</h3><p>go语言时间处理最常用的就是用time.now()来获取当前时间，也可以用time.date去构造一个带时区的时间。</p><p>使用sub对两个时间进行减法得到时间差，可以查看它们具体相差多少小时、多少分钟、多少秒。</p><p>在系统交互时，经常会使用到时间戳，可以使用UNIX方法生成时间戳。</p><p>需要注意的是使用format或者parse来处理时间时，都需要使用<code>2006-01-02 15:04:05</code>这个固定参数才能得到正确的时间。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    now := time.Now()</span><br><span class="line">    t := time.Date(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">    t2 := time.Date(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">13</span>, <span class="number">45</span>, <span class="number">30</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">    fmt.Println(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute())</span><br><span class="line">    fmt.Println(t.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">    diff := t2.Sub(t)</span><br><span class="line">    fmt.Println(diff)</span><br><span class="line">    fmt.Println(diff.Minutes(), diff.Seconds())</span><br><span class="line">    t3, err := time.Parse(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2023-01-20 12:30:30&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(now.Unix())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19数字解析"><a class="markdownIt-Anchor" href="#19数字解析"></a> 19.数字解析</h3><p>在go语言中可以通过strconv这个包来进行字符串和数字类型之间的转换。</p><p>可以使用parseInt或parseFloat来解析一个数字字符串，使用atoi将一个十进制字符串转换为数字，使用itoa将数字转换为字符串。如果转换的数据不合法就会返回error。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, _ := strconv.ParseFloat(<span class="string">&quot;1.234&quot;</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(f)</span><br><span class="line">    </span><br><span class="line">    n, _ := strconv.ParseInt(<span class="string">&quot;111&quot;</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    </span><br><span class="line">    n, _ = strconv.ParseInt(<span class="string">&quot;0x1000&quot;</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    </span><br><span class="line">    n2, _ := strconv.Atoi(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">    fmt.Println(n2)</span><br><span class="line">    </span><br><span class="line">    n2, err := strconv.Atoi(<span class="string">&quot;AAA&quot;</span>)</span><br><span class="line">    fmt.Println(n2, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20进程信息"><a class="markdownIt-Anchor" href="#20进程信息"></a> 20.进程信息</h3><p>在go语言中能够通过os.args来获取程序执行时指定的命令行参数。可以用os.getenv获取环境变量。exec.command用于执行系统的命令。</p><p>以下部分代码在windows系统下可能会报错，需要在linux系统运行才能获取正确信息。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(os.Args)</span><br><span class="line">    fmt.Println(os.Getenv(<span class="string">&quot;PATH&quot;</span>))</span><br><span class="line">    fmt.Println(os.Setenv(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    buf, err := exec.Command(<span class="string">&quot;grep&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;/etc/hosts&quot;</span>).CombineOutput()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="type">string</span>(buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用go run加参数运行，例如<code>go run main.go a b c d</code></p><h2 id="31-猜谜游戏"><a class="markdownIt-Anchor" href="#31-猜谜游戏"></a> 3.1 猜谜游戏</h2><h3 id="1生成随机数"><a class="markdownIt-Anchor" href="#1生成随机数"></a> 1.生成随机数</h3><p>需要math/rand包用于生成随机数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">maxNum := <span class="number">100</span> <span class="comment">//最大范围</span></span><br><span class="line">random := rand.Intn(maxNum) <span class="comment">//生成0-100之间的随机整数</span></span><br></pre></td></tr></table></figure><p>注意到以上代码多次生成的数都是同一个数。查看这个包的官方文档可得知使用之前需要设置随机数种子用于生成随机数序列，否则每次生成的随机数序列都是相同的。习惯上用时间戳来初始化随机数种子。</p><p>在生成随机数之前用时间戳初始化随机数种子即可</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rand.Seed(time.Now().UnixNano())</span><br></pre></td></tr></table></figure><h3 id="2读取用户输入"><a class="markdownIt-Anchor" href="#2读取用户输入"></a> 2.读取用户输入</h3><p>每个程序执行时都会打开几个文件，stdin、stdou、stderr等。stdin可通过os.Stdin获取，但直接操作文件很不方便。</p><p>go语言中的bufio包提供了读取用户输入的方法，newReader方法能够将一个文件转换成一个reader变量，reader变量上拥有很多流的操作。使用ReadString方法读取一行，返回结果中包含结尾的换行符。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line">input, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">//读取</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;An error occured while reading input. Please try again&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 去掉换行符</span></span><br><span class="line">input = strings.Trim(input, <span class="string">&quot;\n&quot;</span>) <span class="comment">//这里根据不同的操作系统可能需要换成\r\n或其他参数</span></span><br><span class="line"><span class="comment">// 转换为数字</span></span><br><span class="line">guess, err := strconv.Atoi(input)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Invalid input. Please enter an integer value&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3实现判断逻辑"><a class="markdownIt-Anchor" href="#3实现判断逻辑"></a> 3.实现判断逻辑</h3><p>正常情况下，只有三种结果，过大、过小以及相等。使用简单的if else即可。</p><h3 id="4实现游戏循环"><a class="markdownIt-Anchor" href="#4实现游戏循环"></a> 4.实现游戏循环</h3><p>由于无法确定固定的循环次数，使用for循环配合continue和break，在读取和转换字符串失败用continue继续循环，在猜中数字时用break退出循环即可。</p><h2 id="32-在线词典"><a class="markdownIt-Anchor" href="#32-在线词典"></a> 3.2 在线词典</h2><p>通过调用第三方API查询单词的翻译并打印出来。</p><p>学会如何使用go语言来发送HTTP请求，解析json数据以及学习如何使用代码生成来提高开发效率。</p><h3 id="1抓包"><a class="markdownIt-Anchor" href="#1抓包"></a> 1.抓包</h3><p>以彩云APIhttps://fanyi.caiyunapp.com/为例，在在线翻译页面打开浏览器的开发者工具。</p><p>使用一次翻译，同时捕获查询单词的post请求，在预览里面找到具体的查询结果。</p><h3 id="2代码生成"><a class="markdownIt-Anchor" href="#2代码生成"></a> 2.代码生成</h3><p>在go语言里构造一个请求用于请求API，由于请求比较复杂，用代码构造麻烦。可以直接在浏览器中复制为cURL（bash）在linux终端或复制为powershell在windows的powershell下测试，成功的话就会返回一大堆json字符串。</p><p>在一个在线代码生成网站<a href="https://curlconverter.com/go/">Convert curl to Go</a>里粘贴cURL，就可以看到生成的go语言代码。直接将代码粘贴到编辑器里即可。</p><p><strong>部分代码解读</strong></p><p>创建HTTP client，可以指定很多参数进行创建，如请求超时时间以及是否使用cookie等。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">client := &amp;http.Client&#123;&#125;</span><br></pre></td></tr></table></figure><p>创建请求，使用http包中的NewRequest方法创建一个post请求，第一个参数指定请求类型，第二个参数指定URL，第三个参数指定请求体。其中请求体可能很大，为了支持流式发送，使用strings.NewReader将字符串转换为一个只读流存放在data变量中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">req, err := http.NewRequest(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;https://api.interpreter.caiyunai.com/v1/dict&quot;</span>, data)</span><br></pre></td></tr></table></figure><p>设置请求头，往往需要设置很多个参数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">req.Header.Set(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>) <span class="comment">//填写请求体的各种参数</span></span><br></pre></td></tr></table></figure><p>发起请求，使用HTTP client发起请求，获取结果。如果请求失败便会打印错误信息并退出进程。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resp, err := client.Do(req)</span><br></pre></td></tr></table></figure><p>读取响应，body同样是一个流，为了避免资源泄露，需要使用defer来手动关闭流，defer会在函数运行结束后执行。使用ioutil.ReadAll读取流，获取整个body的信息。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">bodyText, err := ioutil.ReadAll(resp.Body)</span><br></pre></td></tr></table></figure><p>目前已经能够成功发送请求，但是上面生成的代码是固定输入的。需要使用JSON序列化来实现手动输入请求参数。</p><h3 id="3生成request-body"><a class="markdownIt-Anchor" href="#3生成request-body"></a> 3.生成request body</h3><p>在go语言中，要生成一段JSON，常用的方式就是先构造一个对应json结构的结构体。注意结构体字段首字母一定要大写，否则无法访问该字段。</p><p>结构体中的字段对应了请求负载中的字段</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DictRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    TransType <span class="type">string</span> <span class="string">`json:&quot;trans_type&quot;`</span></span><br><span class="line">    Source    <span class="type">string</span> <span class="string">`json:&quot;source&quot;`</span></span><br><span class="line">    UserID    <span class="type">string</span> <span class="string">`json:&quot;user_id&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>json反序列化为字节数组，使用byte.NewReader来构造request body</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    request := DictRequest&#123;TransType: <span class="string">&quot;en2zh&quot;</span>, Source: <span class="string">&quot;good&quot;</span>&#125;</span><br><span class="line">    buf, err := json.Marshal(request)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> data = bytes.NewReader(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以此实现通过一个变量来发送HTTP请求。</p><h3 id="4解析response-body"><a class="markdownIt-Anchor" href="#4解析response-body"></a> 4.解析response body</h3><p>在js/python这些脚本语言中，body是一个字典或者map的结构，可以直接取值。但go语言是一个强类型语言，不适合这种直接取值的做法。常用的方式就是通过结构体，将json反序列化到结构体中。但是API返回的结构也比较复杂，可以借助代码生成工具<a href="https://oktools.net/json2go">JSON转Golang Struct - 在线工具 - OKTools</a>用于快速生成对应的代码，将响应的json数据通过代码生成工具生成对应的结构体。如果不需要对返回结果进行精细处理，转换为嵌套结构体即可。</p><p>得到response结构体后，使用json.Unmarshal把body反序列化到结构体中，再打印出来。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dictResponse DictResponse <span class="comment">//DictResponse是生成的结构体的名称</span></span><br><span class="line">err = json.Unmarshal(bodyText, &amp;dictResponse) <span class="comment">//bodyText存储了body原始信息,反序列化到空变量中</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, dictResponse)</span><br></pre></td></tr></table></figure><p>之后就是打印特定字段的信息。</p><h3 id="5打印结果"><a class="markdownIt-Anchor" href="#5打印结果"></a> 5.打印结果</h3><p>在以上的API响应例子中，需要用到的信息是在<code>Dictionary.explanations</code>里面。</p><p>可以使用for range迭代并打印信息</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> dictResponse.Dictionary.Explanations &#123;</span><br><span class="line">    fmt.Println(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6完善代码"><a class="markdownIt-Anchor" href="#6完善代码"></a> 6.完善代码</h3><p>将代码主体改造成一个query函数，把需要查询的单词作为参数传递。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">`usage: simpleDict WORD</span></span><br><span class="line"><span class="string">        example: simpleDict hello`</span>)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    word := os.Args[<span class="number">1</span>]</span><br><span class="line">    query(word)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过命令行输入参数运行，使用<code>go run main.go</code>接需要查询的单词即可。</p><h2 id="33-socks5代理"><a class="markdownIt-Anchor" href="#33-socks5代理"></a> 3.3 SOCKS5代理</h2><p>编写一个socks5代理服务器。socks5协议都是明文传输，这个协议历史久远，诞生于互联网早期。它的用途就是在防火墙保证数据安全性时提供socks5协议的端口给授权的用户以便访问内部资源。</p><h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3><p>正常浏览器访问一个网站，如果不经过代理服务器，就是先和目标网站的服务器建立TCP连接，完成三次握手后发起HTTP请求，然后服务器返回HTTP响应。</p><p>如果设置了代理服务器，那么流程会变得复杂一些。首先是浏览器和sock5代理建立TCP连接，代理再和真正的服务器建立TCP连接。可以分成四个阶段，握手阶段、认证阶段、请求阶段、relay阶段。</p><p>第一个握手阶段，浏览器会向socks5代理发送请求，数据包的内容包括一个协议的版本号、支持认证的种类，socks5服务器会选择一个认证方式，返回给浏览器。如果返回的是00则代表不需要认证，返回其他结果则开始认证流程。</p><p>第二个认证阶段参考https://wiyi.org/socks5-protocol-in-deep.html</p><p>第三个请求阶段，认证通过之后浏览器会向socks5发起请求。主要信息包括版本号，请求的类型（一般是connection请求，表示代理服务器要和某个域名或者某个IP地址的某个端口建立TCP连接）。代理服务器收到响应后会真正和后端服务器建立连接，然后返回一个响应。</p><p>第四个relay阶段，此时浏览器会正常发送请求，然后代理服务器接收到请求之后直接转发给真正的服务器，真正的服务器返回的响应也经过代理服务器转发到浏览器这边。socks5代理服务器实际上并不关系流量的细节，可以是HTTP流量也可以是其他的TCP流量。</p><h3 id="1tcp-echo-server"><a class="markdownIt-Anchor" href="#1tcp-echo-server"></a> 1.TCP echo server</h3><p>在go语言中实现一个简单的TCP echo server。使用简单的逻辑，发送什么就返回什么，方便测试。</p><p>在main函数中使用net.listen监听一个端口，返回一个server。然后在一个死循环中反复accept请求，成功之后就会返回一个连接。接下来在一个process函数里处理这个连接。</p><p>process函数的实现，先添加一个defer connection.close防止资源泄露，接下来使用bufio.NewReader来创建一个带缓冲的只读流，带缓冲的流可以减少底层系统的调用次数，且具有更多的工具函数可以读取数据，可以使用readbyte来读取单个字节，再写进去连接。</p><p>main函数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    server, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:1080&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        client, err := server.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Accept failed %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> process(client) <span class="comment">//go关键字代表启动一个goroutine,这里的goroutine可暂时类比为一个子线程,但是开销比子线程小很多,能够轻松处理上万的并发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>process函数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    reader := bufio.NewReader(conn)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        b, err := reader.ReadByte()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        _, err = conn.Write([]<span class="type">byte</span>&#123;b&#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行nc命令测试服务器，nc是linux系统下的命令，windows系统需要额外安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc 127.0.0.1 1080</span><br></pre></td></tr></table></figure><p>输入什么服务器就会返回什么。</p><h3 id="2auth"><a class="markdownIt-Anchor" href="#2auth"></a> 2.auth</h3><p>认证阶段，这一部分会比较复杂。实现一个空的auth函数，在process函数里调用。</p><p>认证阶段的逻辑，第一步，浏览器会向代理服务器发送一个包。这个包有三个字段</p><p>第一个字段version，协议版本号，固定是5。</p><p>第二个字段methods，认证的方法数目。</p><p>第三个字段，每个method的编码，0表示不需要认证，2表示用户名密码认证。</p><p>使用readbyte读取版本号，不是socks5直接返回报错，再读取method size（同样是一个字节）。创建一个相应长度的slice，用io.ReadFull填充信息。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> socks5Ver = <span class="number">0x05</span> <span class="comment">//socks5的版本号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">auth</span><span class="params">(reader *bufio.Reader, conn net.Conn)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">    ver, err := reader.ReadByte()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read ver failed:%w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ver != socks5Ver &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;not supported ver:%v&quot;</span>, ver)</span><br><span class="line">    &#125;</span><br><span class="line">    methodSize, err := reader.ReadByte()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read methodSize failed:%w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    method := <span class="built_in">make</span>([]<span class="type">byte</span>, methodSize)</span><br><span class="line">    _, err = io.ReadFull(reader, method)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read method failed:%w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">&quot;ver&quot;</span>, ver, <span class="string">&quot;method&quot;</span>, method)</span><br><span class="line">    _, err = conn.Write([]<span class="type">byte</span>&#123;socks5Ver, <span class="number">0x00</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;write failed:%w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，代理服务器还需要返回一个response，返回包有两个字段，一个是version，一个是method，也就是鉴传方式。当前只考虑实现不需要鉴传的方式，即00。可以使用curl命令测试效果。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --socks5 127.0.0.1:1080 -v http://www.baidu.com</span><br></pre></td></tr></table></figure><p>curl命令还不能成功，因为协议还没有完善。查看日志，version和method可以正常打印，说明目前协议实现正确。</p><h3 id="3请求阶段"><a class="markdownIt-Anchor" href="#3请求阶段"></a> 3.请求阶段</h3><p>请求阶段，读取携带URL或者IP地址+端口的包。实现一个和auth函数类似的connect函数，同样在process中调用。</p><p>请求阶段的逻辑，浏览器会发送一个包，包里有如下6个字段</p><p>version版本号，是5。command请求类型，这边只支持connection请求，也就是让代理服务器建立新的TCP连接。RSV保留字段，不需要理会。atype目标地址类型，可能是IPv4 IPv6或者域名。addr地址，这个地址的长度受atype的类型的影响会有不同。port端口号，两个字节，需要逐个读取。</p><p>前四个字段共四个字节，可以一次性读取，定义一个长度为4的buffer。读取完后，第0个就是version，判断是否为socks5，第1个就是cmd，判断是否为1（1表示connection请求），第3个就是atype，如果是IPv4，则再次读取到buffer，将buffer的字节逐个以IP地址的格式保存到addr变量中。如果是host，需要先读取长度，再创建一个相应长度的buf进行填充，转换成字符串保存到addr变量。IPv6目前不考虑支持。</p><p>最后的port有两个字节，读取后按协议规定的大端字节序转换成数字。前面的buffer不会再被其他变量使用，可以直接复用内存，创建一个临时slice，长度为2。接下来把IP地址和端口号打印出来。</p><p>收到浏览器的请求包之后，需要返回一个包。这个包里有很多字段，但大部分不会使用。</p><p>第一个是版本号socks5，第二个是返回类型，成功的话就返回0，第三个是保留字段，填0即可，第四个字段是atype地址类型，填1。第五、六个字段暂时用不到，都填0。一共是4+4+2个字节。</p><p>编写完connect函数后，使用curl重新测试，看到IP地址和端口信息被打印出来，说明当前协议实现正确。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --socks5 127.0.0.1:1080 -v http://www.baidu.com</span><br></pre></td></tr></table></figure><p>最后一步就是和端口建立连接，实现双向转发数据。</p><h3 id="4relay阶段"><a class="markdownIt-Anchor" href="#4relay阶段"></a> 4.relay阶段</h3><p>直接使用net.dial建立一个TCP连接。建立连接之后，不要忘记使用defer来关闭连接。</p><p>实现浏览器和下游服务器的双向数据转发。标准库的io.copy可以实现一个单向数据转发，那么可以使用两个goroutine实现双向转发。</p><p>此时存在一个问题，connect函数会立即返回并关闭连接，需要等待任意一个方向copy出错后再返回connect函数。可以使用标准库的context机制，用contextWithCancel来创建一个context，在最后等待ctx.Done，只要cancel被调用，ctx.Done就会立即返回，然后在两个goroutine里各调用一次cancal即可。</p><p>在connect函数中添加</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dest, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;%v:%v&quot;</span>, addr, port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Errorf(<span class="string">&quot;dial dst failed:%w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> dest.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在写入数据完成之后</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Backgrond())</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _, _ = io.Copy(dest, reader)</span><br><span class="line">    cancel()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _, _ = io.Copy(conn, dest)</span><br><span class="line">    cancel()</span><br><span class="line">&#125;()</span><br><span class="line">&lt;-ctx.Done()</span><br></pre></td></tr></table></figure><p>执行curl测试，返回成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --socks5 127.0.0.1:1080 -v http://www.baidu.com</span><br></pre></td></tr></table></figure><p>还可以在浏览器中测试代理，需要安装switchyomega插件。新建情景模式，代理服务器socks5，端口1080，保存并启用。访问网站，可以在代理服务器这边看到浏览器版本的域名和端口。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://github.com/wangkechun/go-by-example/">源代码</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文已收录到&lt;a href=&quot;https://juejin.cn/post/7192662401240531004&quot;&gt;golang基础学习 | 青训营笔记 - 掘金 (juejin.cn)&lt;/a&gt;，主要记录了对golang的初步学习</summary>
    
    
    
    <category term="golang" scheme="https://s-chance.github.io/categories/golang/"/>
    
    
    <category term="学习笔记" scheme="https://s-chance.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="青训营" scheme="https://s-chance.github.io/tags/%E9%9D%92%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>关于个人Hexo博客的搭建历史</title>
    <link href="https://s-chance.github.io/2023/01/17/blog-by-https/"/>
    <id>https://s-chance.github.io/2023/01/17/blog-by-https/</id>
    <published>2023-01-17T06:06:17.000Z</published>
    <updated>2023-01-18T06:32:47.351Z</updated>
    
    <content type="html"><![CDATA[<p>仅以此文回顾过去搭建Hexo博客的历程<span id="more"></span></p><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>在早期笔者一直是通过github pages服务来运行博客网站，从而省略了对<strong>域名解析</strong>、<strong>nginx反向代理</strong>以及<strong>SSL证书的申请与HTTPS服务的开启</strong>这些配置</p><p>于是后期，笔者租赁了一台纯净Ubutun20.04LTS系统的轻量应用服务器，从零开始基于命令行配置hexo博客以及HTTPS服务的开启</p><h2 id="hexo博客的搭建"><a class="markdownIt-Anchor" href="#hexo博客的搭建"></a> Hexo博客的搭建</h2><h3 id="本地环境搭建"><a class="markdownIt-Anchor" href="#本地环境搭建"></a> 本地环境搭建</h3><h4 id="git环境"><a class="markdownIt-Anchor" href="#git环境"></a> Git环境</h4><ol><li><p>访问git官网<a href="https://git-scm.com/download">Git - Downloads (git-scm.com)</a>或寻找镜像站<a href="https://mirrors.tuna.tsinghua.edu.cn/github-release/git-for-windows/git/">清华大学开源软件镜像站 | git for windows</a>下载对应系统的版本</p></li><li><p>安装Git，除了安装路径可选择C盘或D盘，其它均可直接下一步</p></li><li><p>配置环境变量，在系统环境变量的<strong>Path变量下</strong>增加变量值</p><p>参考变量值：D:\Program Files\Git\cmd</p></li><li><p>win+r输入powershell打开查看git版本信息</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git <span class="literal">-v</span></span><br></pre></td></tr></table></figure><p>显示出了版本号，则说明git配置完成</p></li></ol><h4 id="nodejs环境"><a class="markdownIt-Anchor" href="#nodejs环境"></a> Nodejs环境</h4><ol><li><p>访问nodejs官网<a href="https://nodejs.org/en/download/">Download | Node.js (nodejs.org)</a>下载对应系统的nodejs版本。（linux系统可直接使用命令行下载而不需要手动配置，使用其它方式则需要手动添加环境变量或者软链接）</p></li><li><p>windows下载完nodejs后需要配置环境变量（注意不要使用中文路径和带有空格的路径，默认路径中的<code>Program Files</code>中的空格会导致命令无法识别）</p><p>windows参考配置</p><ol><li><p>执行下载的nodejs的msi文件，选择安装路径<code>D:\nodejs</code></p></li><li><p>配置<strong>系统环境变量</strong>，在<strong>Path变量</strong>下添加 D:\nodejs\ （这一步nodejs可能会自动配置好）</p></li><li><p>应用配置，保存关闭。win+r输入powershell打开命令提示符，输入</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看nodejs版本</span></span><br><span class="line">node <span class="literal">-v</span></span><br><span class="line"><span class="comment"># 查看包管理器npm的版本(npm是nodejs默认安装的包管理器)</span></span><br><span class="line">npm <span class="literal">-v</span></span><br></pre></td></tr></table></figure><p>以上命令检测到两个版本号后说明配置完成</p></li><li><p>完成以上步骤后基本就能够使用nodejs来搭建hexo。后续为<strong>非必须步骤</strong>，如果使用过程中存在一些问题可参考以下步骤解决</p></li><li><p>如果npm下载失败或下载速度缓慢，可能是由于默认服务器在海外的缘故，可指定国内镜像源下载或配置npm的国内镜像源</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定镜像源下载,下载时加上--registry的参数,每次下载需要指定</span></span><br><span class="line">npm install <span class="literal">-g</span> 包名 <span class="literal">--registry</span>=https://registry.npm.taobao.org</span><br><span class="line"><span class="comment"># 设置镜像源,将npm的默认源更换为镜像源</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line"><span class="comment"># 检测镜像站是否可用</span></span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure></li><li><p>按以上步骤nodejs安装在了D盘，但下载的包仍在C盘，这里的配置是将包从C盘迁移到D盘以减少C盘的占用</p><p>在nodejs的根目录下，创建两个文件夹命名为node_global和node_cache，在文件夹的属性——安全里更改所有组或用户的权限为完全控制（防止权限不足而无法下载的问题）</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置全局安装路径(路径根据实际情况填写)</span></span><br><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">&quot;D:\nodejs\node_global&quot;</span></span><br><span class="line"><span class="comment"># 设置全局缓存路径(路径根据实际情况填写)</span></span><br><span class="line">npm config <span class="built_in">set</span> cache <span class="string">&quot;D:\nodejs\node_cache&quot;</span></span><br><span class="line"><span class="comment"># 以上命令会在C盘用户文件夹下产生一个.npmrc配置文件由于保存上面的配置信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加系统环境变量,在Path变量下新增变量值,变量值就是全局安装路径,否则新安装的命令工具无法执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测全局安装路径</span></span><br><span class="line">npm root <span class="literal">-g</span></span><br><span class="line"><span class="comment"># 查看配置信息</span></span><br><span class="line">npm config list</span><br></pre></td></tr></table></figure><p>以上配置完成后，之后下载的包都会放到<strong>node_global/node_modules</strong>下</p></li></ol></li><li><p>nodejs环境搭建完成</p></li></ol><h4 id="hexo环境"><a class="markdownIt-Anchor" href="#hexo环境"></a> Hexo环境</h4><ol><li><p>在完成了搭建git和nodejs的环境的基础上，就能够快速使用Hexo</p></li><li><p>在powershell中执行以下命令</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局安装Hexo命令行工具</span></span><br><span class="line">npm install <span class="literal">-g</span> hexo<span class="literal">-cli</span></span><br><span class="line"><span class="comment"># 查看Hexo版本信息</span></span><br><span class="line">hexo version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个合适的文件夹作为Hexo框架的存放目录(这里假设使用一个demo的空文件夹)</span></span><br><span class="line"><span class="comment"># 执行以下3条命令就搭建好了基本的框架</span></span><br><span class="line">hexo init demo</span><br><span class="line"><span class="built_in">cd</span> demo</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在本地运行Hexo</span></span><br><span class="line">hexo server <span class="comment"># 或简写为hexo s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些常用的Hexo命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一篇文章(文章内包含了Hexo的一些格式信息)</span></span><br><span class="line">hexo new <span class="string">&quot;first blog&quot;</span> <span class="comment"># 会在_posts目录下生成一个markdown初始文件,标题为first blog</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一篇草稿(草稿不会在网站上展示)</span></span><br><span class="line">hexo new draft <span class="string">&quot;my draft&quot;</span> <span class="comment"># 会在_drafts目录下生成相应的初始文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建导航页(导航页主要是展示文章分类、标签、作者简介、友情链接等信息)</span></span><br><span class="line">hexo new page <span class="literal">--path</span> about/me <span class="string">&quot;About me&quot;</span> <span class="comment"># 个人简介,这里是固定写法。默认情况下还需要修改配置文件才能生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态文件(一般是在新建文章并完成写作后使用或者在修改了文章的内容后使用)</span></span><br><span class="line">hexo generate <span class="comment"># 可简写为hexo g</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务器(用于预览网页效果)</span></span><br><span class="line">hexo server <span class="comment"># 可简写为hexo s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署网站(需要配置远程服务器地址,部署之前需要先生成静态文件)</span></span><br><span class="line">hexo deploy <span class="comment"># 可简写为hexo d</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除缓存文件(一般是更换Hexo主题未生效时使用)</span></span><br><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>更详细的介绍请移步官网<a href="https://hexo.io/zh-cn/">Hexo</a></p></li></ol><h3 id="远程环境搭建"><a class="markdownIt-Anchor" href="#远程环境搭建"></a> 远程环境搭建</h3><h4 id="创建git仓库"><a class="markdownIt-Anchor" href="#创建git仓库"></a> 创建Git仓库</h4><p>先安装openssh，之后就可以通过ssh客户端远程连接服务器而不需要在浏览器上操作</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装SSH服务端</span></span><br><span class="line">sudo apt install openssh-server</span><br><span class="line"><span class="comment"># 查看SSH服务是否启动</span></span><br><span class="line">ps -e | grep ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个blog用户管理Hexo(默认的root用户权限过高,容易影响到系统)</span></span><br><span class="line">adduser blog</span><br><span class="line"><span class="comment"># 给予blog用户权限</span></span><br><span class="line">vim /etc/sudoers</span><br><span class="line"><span class="comment"># 找到User privilege specification这一段,在下面添加以下内容</span></span><br><span class="line">blog    ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到blog用户(密码可在网页服务器控制台那边重置密码获得)</span></span><br><span class="line">su blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装git</span></span><br><span class="line">sudo apt install git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入根目录,在/var/repo目录下创建一个名为hexo_static的裸仓库</span></span><br><span class="line"><span class="built_in">cd</span> /</span><br><span class="line">sudo <span class="built_in">mkdir</span> /var/repo/</span><br><span class="line">sudo <span class="built_in">chown</span> -R <span class="variable">$USER</span>:<span class="variable">$USER</span> /var/repo/</span><br><span class="line">sudo <span class="built_in">chmod</span> -R 755 /var/repo/</span><br><span class="line"><span class="built_in">cd</span> /var/repo/</span><br><span class="line"><span class="comment"># 创建裸仓库</span></span><br><span class="line">git init --bare hexo_static.git</span><br><span class="line"><span class="comment"># 裸仓库不同于普通仓库,裸仓库是专门的共享仓库,不会存储文件,只保存历史提交的版本信息</span></span><br><span class="line"><span class="comment"># 实际上裸仓库就相当于普通仓库中隐藏的.git文件夹</span></span><br></pre></td></tr></table></figure><h4 id="配置nginx反向代理"><a class="markdownIt-Anchor" href="#配置nginx反向代理"></a> 配置Nginx反向代理</h4><h5 id="安装nginx及可能遇到的问题"><a class="markdownIt-Anchor" href="#安装nginx及可能遇到的问题"></a> 安装Nginx及可能遇到的问题</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装nginx</span></span><br><span class="line">sudo apt install nginx</span><br><span class="line"><span class="comment"># 查看版本信息,注意大小写</span></span><br><span class="line">nginx -V</span><br><span class="line"><span class="comment"># 注意这一步如果没有看到with-http_ssl_module字样的参数信息(如果有就跳过后续步骤),则需要从源码编译安装(已经安装了也没有关系,停止服务后替换配置文件即可)</span></span><br><span class="line"><span class="comment"># 如果想卸载也可以执行以下命令</span></span><br><span class="line">sudo apt --purge autoremove nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># Nginx 官网 https://nginx.org/en/download.html</span></span><br><span class="line"><span class="comment"># /usr/local/src目录通常用于存放用户手动编译程序的源码包</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/</span><br><span class="line"><span class="comment"># 这里使用wget下载nginx的源码包</span></span><br><span class="line"><span class="comment"># 如果已经安装并配置了nginx,又不想重新配置,使用nginx -v命令查看已安装的nginx版本并替换掉以下命令中的版本号</span></span><br><span class="line">wget https://nginx.org/download/nginx-1.22.1.tar.gz</span><br><span class="line"><span class="comment"># 解压提取包并进入解压目录</span></span><br><span class="line">tar -zxvf nginx-1.22.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> nginx-1.22.1</span><br><span class="line"><span class="comment"># 查看原有的nginx安装目录</span></span><br><span class="line"><span class="built_in">which</span> nginx</span><br><span class="line"><span class="comment"># 停止nginx的运行</span></span><br><span class="line">nginx -s stop</span><br><span class="line"><span class="comment"># 查看原有nginx的配置参数,注意大小写</span></span><br><span class="line">nginx -V</span><br><span class="line"><span class="comment"># 在原有参数的基础上附加--with-http_ssl_module的参数配置SSL模块(下面只给出了一部分参数,完整参数由nginx -V显示的参数拼接SSL模块的参数而成)</span></span><br><span class="line">sudo ./configure --prefix=/usr/local/nginx --with-http_ssl_module</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这一步可能会缺少一些库,使用以下命令下载到相关库后重新编译</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺少PCRE的相关库,如果不缺这个库就跳过</span></span><br><span class="line">sudo apt install libpcre3 libpcre3-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺少zlib的库,如果不缺这个库就跳过</span></span><br><span class="line"><span class="comment"># 访问zlib官网http://zlib.net/下载zlib,这里直接用wget下载到当前的src目录</span></span><br><span class="line">wget http://zlib.net/zlib-1.2.13.tar.gz</span><br><span class="line">./configure --prefix=/usr/local/zlib</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺少openssl的相关库,如果不缺这个库就跳过</span></span><br><span class="line">sudo apt install openssl libssl-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新编译nginx</span></span><br><span class="line">sudo make</span><br><span class="line"><span class="comment"># 如果没有安装过nginx或者已经卸载了nginx则执行以下2条命令覆盖安装后即可跳过后续步骤</span></span><br><span class="line">sudo make install</span><br><span class="line"><span class="comment"># 配置软链接使得在任意目录下能通过nginx的名称直接运行nginx的命令</span></span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/local/nginx/sbin/nginx /usr/sbin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换原有nginx的文件</span></span><br><span class="line"><span class="comment"># 备份原有nginx安装目录下的文件(这里以安装文件位于/usr/sbin/目录下为例)</span></span><br><span class="line"><span class="built_in">cp</span> /usr/sbin/nginx /usr/sbin/nginx.bak</span><br><span class="line"><span class="comment"># 将编译好的nginx文件覆盖掉原有的nginx</span></span><br><span class="line"><span class="built_in">cp</span> ./objs/nginx /usr/sbin/</span><br><span class="line"><span class="comment"># 重新查看nginx参数信息</span></span><br><span class="line">nginx -V</span><br><span class="line"><span class="comment"># 看到了--with-http_ssl_module的参数,SSL模块配置完成</span></span><br></pre></td></tr></table></figure><h5 id="配置nginx托管文件目录"><a class="markdownIt-Anchor" href="#配置nginx托管文件目录"></a> 配置Nginx托管文件目录</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建/var/www/hexo目录用于存放Hexo生成的静态文件,修改目录所有权</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /var/www/hexo</span><br><span class="line">sudo <span class="built_in">chown</span> -R <span class="variable">$USER</span>:<span class="variable">$USER</span> /var/www/hexo</span><br><span class="line">sudo <span class="built_in">chmod</span> -R 755 /var/www/hexo</span><br><span class="line"><span class="comment"># 修改/etc/nginx/sites-enabled/default,使nginx的root目录指向hexo目录</span></span><br><span class="line"><span class="comment"># 在server里面添加以下配置</span></span><br><span class="line">root /var/www/hexo;</span><br><span class="line"><span class="comment"># 重启nginx服务</span></span><br><span class="line">sudo systemctl restart nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置git钩子,用于实现本地Hexo生成的静态文件推送到指定目录</span></span><br><span class="line">vim /var/repo/hexo_static.git/hooks/post-receive</span><br><span class="line"><span class="comment"># 添加以下配置内容并保存退出</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">git --work-tree=/var/www/hexo --git-dir=/var/repo/hexo_static.git checkout -f</span><br><span class="line"><span class="comment"># 给予可执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x /var/repo/hexo_static.git/hooks/post-receive</span><br></pre></td></tr></table></figure><h3 id="ssh远程连接配置"><a class="markdownIt-Anchor" href="#ssh远程连接配置"></a> SSH远程连接配置</h3><p>在windows上搭建SSH客户端</p><ol><li><p>使用powershell运行以下命令在用户文件夹的.ssh文件夹下生成密钥</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ssh<span class="literal">-keygen</span> <span class="literal">-t</span> rsa</span><br></pre></td></tr></table></figure></li><li><p>将生成的公钥id_rsa.pub中的内容拷贝到服务器的/home/blog/.ssh/authorized_keys文件上</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> .ssh</span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line">sudo <span class="built_in">touch</span> authorized_keys</span><br><span class="line">sudo vim .ssh/authorized_keys</span><br></pre></td></tr></table></figure></li></ol><h3 id="hexo部署到服务器"><a class="markdownIt-Anchor" href="#hexo部署到服务器"></a> Hexo部署到服务器</h3><ol><li><p>编辑hexo根目录中的config.yml文件，在deploy处配置参数</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="comment"># server_ip为服务器的公网ip</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">blog@server_ip:/var/repo/hexo_static.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li><li><p>执行以下命令部署Hexo</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li><li><p>查看服务器的/var/www/hexo目录，能够看到上传的静态文件</p></li><li><p>访问服务器IP地址查看页面，如果访问失败则检查服务器内部是否开放了80端口并去浏览器控制台查看服务器厂商提供的安全组规则或外部防火墙是否开放了80端口。确认都开放之后重新访问</p></li></ol><h3 id="域名解析配置"><a class="markdownIt-Anchor" href="#域名解析配置"></a> 域名解析配置</h3><p>域名的购买很简单，到这里笔者已经提前购买好了一年期域名，重点就是配置域名解析。如果租赁域名的地方和租赁服务器的地方不是同一个地方，则域名解析需要在租赁域名的地方进行配置</p><p>参考配置</p><p>主机记录一般就是填<strong>www</strong>，记录类型为A，记录值为公网IP地址，其它的参数默认即可</p><p>之后就可以通过www.域名来访问页面，如果想直接通过一级域名访问，也可以再添加一条主机记录为@，记录类型为A，记录值为公网IP地址的解析</p><h3 id="ssl证书申请"><a class="markdownIt-Anchor" href="#ssl证书申请"></a> SSL证书申请</h3><p>这里笔者找了一个能申请90天免费SSL证书的网站<a href="https://ourl.co/zerossl">https://ourl.co/zerossl</a>。具体的操作参考<a href="https://www.landiannews.com/archives/93605.html">SSL证书申请</a></p><h3 id="https服务开启"><a class="markdownIt-Anchor" href="#https服务开启"></a> HTTPS服务开启</h3><p><strong>Nginx配置SSL证书</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将下载到windows上的证书文件上传至服务器</span></span><br><span class="line"><span class="comment"># 指定一个目录用于存放证书文件(目录可自行选择,以下仅供参考)</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /ssh/cert &amp;&amp; <span class="built_in">cd</span> /ssh/cert</span><br><span class="line"><span class="comment"># 使用远程文件传输上传文件至服务器</span></span><br><span class="line"><span class="comment"># 将证书文件信息合并</span></span><br><span class="line"><span class="built_in">cat</span> ca_bundle.crt &gt;&gt; certificate.crt</span><br></pre></td></tr></table></figure><p><strong>Nginx配置参考</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name example.com;</span><br><span class="line">        rewrite ^/(.*) https://$server_name<span class="variable">$request_uri</span>? permanent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen   443   ssl;</span><br><span class="line">        ssl_certificate /ssh/cert/certificate.crt;</span><br><span class="line">        ssl_certificate_key /ssh/cert/private.key;</span><br><span class="line">        server_name example.com; <span class="comment">#填写域名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ssl验证相关配置</span></span><br><span class="line">        ssl_session_timeout  5m;    <span class="comment">#缓存有效期</span></span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    <span class="comment">#加密算法</span></span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    <span class="comment">#安全链接可选的加密协议</span></span><br><span class="line">        ssl_prefer_server_ciphers on;   <span class="comment">#使用服务器端的首选算法</span></span><br><span class="line">        </span><br><span class="line">        root /var/www/hexo; <span class="comment">#Hexo项目目录</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add index.php to the list if you are using PHP</span></span><br><span class="line">        index index.html index.htm index.nginx-debian.html;</span><br><span class="line">        location / &#123;</span><br><span class="line">                <span class="comment"># First attempt to serve request as file, then</span></span><br><span class="line">                <span class="comment"># as directory, then fall back to displaying a 404.</span></span><br><span class="line">                try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ =404;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此HTTPS服务配置完成，在访问笔者的页面时可以看到https开头的URL</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://hexo.io/zh-cn/">Hexo官网</a></p><p><a href="https://cloud.tencent.com/developer/article/1945550">Hexo部署至服务器</a></p><p><a href="https://www.landiannews.com/archives/93605.html">SSL证书申请</a></p><p><a href="https://help.zerossl.com/hc/en-us/articles/360058295894">在NGINX上安装SSL证书 - 零SSL和 (zerossl.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;仅以此文回顾过去搭建Hexo博客的历程</summary>
    
    
    
    
    <category term="生活记录" scheme="https://s-chance.github.io/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>IDEA插件配置</title>
    <link href="https://s-chance.github.io/2023/01/14/IDEA-plugins/"/>
    <id>https://s-chance.github.io/2023/01/14/IDEA-plugins/</id>
    <published>2023-01-14T10:11:56.000Z</published>
    <updated>2023-01-16T11:22:55.310Z</updated>
    
    <content type="html"><![CDATA[<p>作为IntelliJ IDEA的用户之一，原始的IDE已经能够满足大部分需求，但IDE插件提供了更多拓展性的功能，使得开发者能够工作在适宜的“开发环境”中，提高开发效率，提升开发者体验。那么以下是笔者在使用过程中所搜寻到的一些插件，请注意其中部分插件并不能直接提升开发效率，另外过多的插件反而会造成开发效率的低下，请悉知。读者可自行选择感兴趣的插件进行配置<span id="more"></span></p><h3 id="视觉体验"><a class="markdownIt-Anchor" href="#视觉体验"></a> 视觉体验</h3><h4 id="background-image-plus"><a class="markdownIt-Anchor" href="#background-image-plus"></a> Background Image Plus +</h4><p>Background Image Plus +是一款<strong>编辑器背景</strong>图插件，是Background Image Plus的功能增强版。支持<strong>每隔指定时间随机切换背景图片</strong>（需要有包含多个图片文件的背景图片文件夹，部分图片文件格式无法显示）</p><h4 id="material-theme-ui"><a class="markdownIt-Anchor" href="#material-theme-ui"></a> Material Theme UI</h4><p>Material Theme UI是一款主题美化插件</p><h4 id="rainbow-brackets"><a class="markdownIt-Anchor" href="#rainbow-brackets"></a> Rainbow Brackets</h4><p>Rainbow Brackets彩虹括号插件，对代码排错有一定帮助</p><h4 id="nyan-progress-bar"><a class="markdownIt-Anchor" href="#nyan-progress-bar"></a> Nyan Progress Bar</h4><p>Nyan Progress Bar彩虹猫进度条样式插件</p><hr /><h3 id="代码跳转与快速浏览"><a class="markdownIt-Anchor" href="#代码跳转与快速浏览"></a> 代码跳转与快速浏览</h3><h4 id="codeglance-pro"><a class="markdownIt-Anchor" href="#codeglance-pro"></a> CodeGlance Pro</h4><p>CodeGlance Pro是一款<strong>快速浏览代码</strong>的插件，是CodeGlance的最新版。提供了<strong>代码缩略图</strong>，并能对缩略图中的部分代码进行<strong>放大浏览</strong>以及<strong>快速跳转</strong>到指定的代码</p><hr /><h3 id="代码编辑"><a class="markdownIt-Anchor" href="#代码编辑"></a> 代码编辑</h3><h4 id="string-manipulation"><a class="markdownIt-Anchor" href="#string-manipulation"></a> String Manipulation</h4><p>String Manipulation用于代码大小写转换、驼峰命名转换、去除空格等</p><h4 id="ideavim"><a class="markdownIt-Anchor" href="#ideavim"></a> IdeaVim</h4><p>Ideavim是一个Vim仿真插件，用于在IDAE上实现Vim操作。（适用于习惯Vim操作的开发者，部分快捷键与IDEA自带快捷键存在冲突，需要手动配置）</p><h3 id="代码生成"><a class="markdownIt-Anchor" href="#代码生成"></a> 代码生成</h3><h4 id="easy-code"><a class="markdownIt-Anchor" href="#easy-code"></a> Easy Code</h4><p>Easy Code是一款能够根据数据表直接生成entity、controller、service、dao、mapper的代码，非常方便</p><h4 id="easy-code-mybatiscodehelperpro"><a class="markdownIt-Anchor" href="#easy-code-mybatiscodehelperpro"></a> Easy Code-MybatisCodeHelperPro</h4><p>为了与MybatisCodeHelperPro兼容而的推出的Easy Code版本</p><hr /><h3 id="代码简化"><a class="markdownIt-Anchor" href="#代码简化"></a> 代码简化</h3><h4 id="lombok"><a class="markdownIt-Anchor" href="#lombok"></a> Lombok</h4><p>Lombok能够通过注解实现实体类的方法，简化、减少代码的编写</p><hr /><h3 id="代码规范"><a class="markdownIt-Anchor" href="#代码规范"></a> 代码规范</h3><h4 id="checkstyle"><a class="markdownIt-Anchor" href="#checkstyle"></a> CheckStyle</h4><p>Java代码格式规范插件，能够自定义不同的规范</p><h4 id="alibaba-java-coding-guidelines"><a class="markdownIt-Anchor" href="#alibaba-java-coding-guidelines"></a> Alibaba Java Coding Guidelines</h4><p>Alibaba Java Coding Guidelines阿里巴巴的代码规范插件，用于开发者规范自己的代码编写，改善代码质量</p><h4 id="sonarlint"><a class="markdownIt-Anchor" href="#sonarlint"></a> SonarLint</h4><p>SonarLint是一个代码质量检测器插件，用于培养开发者良好的开发习惯以及提高代码质量</p><hr /><h3 id="git提交规范"><a class="markdownIt-Anchor" href="#git提交规范"></a> Git提交规范</h3><h4 id="git-commit-template"><a class="markdownIt-Anchor" href="#git-commit-template"></a> Git Commit Template</h4><p>Git Commit Template用于规范git提交信息</p><hr /><h3 id="代码测试"><a class="markdownIt-Anchor" href="#代码测试"></a> 代码测试</h3><h4 id="junitgenerator-v20"><a class="markdownIt-Anchor" href="#junitgenerator-v20"></a> JUnitGenerator V2.0</h4><p>JUnitGenerator V2.0用于快速生成代码测试模块</p><hr /><h3 id="项目架构分析"><a class="markdownIt-Anchor" href="#项目架构分析"></a> 项目架构分析</h3><h4 id="plantuml-integration"><a class="markdownIt-Anchor" href="#plantuml-integration"></a> PlantUML Integration</h4><p>PlantUML Integration是一款用于快速创建UML（统一建模语言）图形的插件，能够通过绘制图形来系统性地分析和设计项目</p><h4 id="sequencediagram"><a class="markdownIt-Anchor" href="#sequencediagram"></a> SequenceDiagram</h4><p>SequenceDiagram用于生成项目类调用关系与执行流程的时序图</p><hr /><h3 id="云部署"><a class="markdownIt-Anchor" href="#云部署"></a> 云部署</h3><h4 id="alibaba-cloud-toolkit"><a class="markdownIt-Anchor" href="#alibaba-cloud-toolkit"></a> Alibaba Cloud Toolkit</h4><p>Alibaba Cloud Toolkit用于高效开发并部署适合在云端运行的应用</p><hr /><h3 id="json辅助工具"><a class="markdownIt-Anchor" href="#json辅助工具"></a> Json辅助工具</h3><h4 id="json-parser"><a class="markdownIt-Anchor" href="#json-parser"></a> Json Parser</h4><p>Json Parser是一款json解析器插件，是一个用于<strong>验证和格式化JSON字符串</strong>的轻量级插件</p><h4 id="gsonformatplus"><a class="markdownIt-Anchor" href="#gsonformatplus"></a> GsonFormatPlus</h4><p>GsonFormat能够将json数据直接转换为Java的类，提高效率</p><hr /><h3 id="翻译工具"><a class="markdownIt-Anchor" href="#翻译工具"></a> 翻译工具</h3><h4 id="translation"><a class="markdownIt-Anchor" href="#translation"></a> Translation</h4><p>Translation是一款中英文翻译插件，用于在IDEA内部快速实现中英文翻译</p><hr /><h3 id="maven辅助工具"><a class="markdownIt-Anchor" href="#maven辅助工具"></a> Maven辅助工具</h3><h4 id="maven-helper"><a class="markdownIt-Anchor" href="#maven-helper"></a> Maven Helper</h4><p>Maven Helper是一款maven依赖冲突分析的插件，主要提供图形化操作来替代命令行操作</p><hr /><h3 id="mybatis辅助工具"><a class="markdownIt-Anchor" href="#mybatis辅助工具"></a> Mybatis辅助工具</h3><p>注意部分MyBatis插件和MybatisPlus插件可能会产生冲突</p><h4 id="mybatis-log"><a class="markdownIt-Anchor" href="#mybatis-log"></a> Mybatis Log</h4><p>Mybatis Log是一款Mybatis的<strong>日志处理</strong>工具，将Mybatis框架日志中的SQL信息转换可直接执行的SQL语句，节省时间。其历史版本不需要付费，最新版本需要付费使用</p><h4 id="mybatiscodehelperpro"><a class="markdownIt-Anchor" href="#mybatiscodehelperpro"></a> MybatisCodeHelperPro</h4><p>MybatisCodeHelperPro是一款MyBatis的强大辅助插件（不少开发者对此给出很高的评价），提供免费版和付费版，免费版提供的功能基本能够满足日常需求。（可能会与其它插件产生冲突）</p><hr /><h3 id="mybatisplus辅助工具"><a class="markdownIt-Anchor" href="#mybatisplus辅助工具"></a> MybatisPlus辅助工具</h3><h4 id="mybatisx"><a class="markdownIt-Anchor" href="#mybatisx"></a> MybatisX</h4><p>MybatisX是MybatisPlus的强大辅助插件。（可能会与Mybatis的部分插件产生冲突）</p><hr /><h3 id="restful辅助工具"><a class="markdownIt-Anchor" href="#restful辅助工具"></a> Restful辅助工具</h3><h4 id="restfultoolkit"><a class="markdownIt-Anchor" href="#restfultoolkit"></a> Restfultoolkit</h4><p>Restfultoolkit是一款针对Restful服务开发的辅助工具，能够根据URL快速跳转到对应的方法接口，提供了一个接口列表窗口，内置一个简单的Http请求工具（相当于一个简化的测试工具，类似于postman和apifox等）</p><hr /><h3 id="k8s辅助工具"><a class="markdownIt-Anchor" href="#k8s辅助工具"></a> K8s辅助工具</h3><h4 id="kubernetes"><a class="markdownIt-Anchor" href="#kubernetes"></a> Kubernetes</h4><p>Kubernetes插件用于检测管理Kubernetes系统</p><hr />]]></content>
    
    
    <summary type="html">&lt;p&gt;作为IntelliJ IDEA的用户之一，原始的IDE已经能够满足大部分需求，但IDE插件提供了更多拓展性的功能，使得开发者能够工作在适宜的“开发环境”中，提高开发效率，提升开发者体验。那么以下是笔者在使用过程中所搜寻到的一些插件，请注意其中部分插件并不能直接提升开发效率，另外过多的插件反而会造成开发效率的低下，请悉知。读者可自行选择感兴趣的插件进行配置</summary>
    
    
    
    
    <category term="配置优化" scheme="https://s-chance.github.io/tags/%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>在linux终端显示系统信息</title>
    <link href="https://s-chance.github.io/2022/12/30/screenfetch-neofetch/"/>
    <id>https://s-chance.github.io/2022/12/30/screenfetch-neofetch/</id>
    <published>2022-12-29T16:14:15.000Z</published>
    <updated>2022-12-30T06:17:11.492Z</updated>
    
    <content type="html"><![CDATA[<p>在linux操作系统的桌面用户群体中, 一个能够打印linux发行版logo以及相关系统信息的命令, 一定程度上能够使不同用户的linux系统更加个性化。基于Ubuntu22.04LTS, 下面介绍两个相关命令<span id="more"></span></p><h3 id="screenfetch命令"><a class="markdownIt-Anchor" href="#screenfetch命令"></a> screenfetch命令</h3><h4 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install screenfetch</span><br></pre></td></tr></table></figure><h4 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h4><p>直接在终端输入以下命令即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screenfetch</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/s-chance/firgure-bed/img/screenfetch-202212300156995.png" alt="image-20221230014403780" /></p><h4 id="可能出现的问题"><a class="markdownIt-Anchor" href="#可能出现的问题"></a> 可能出现的问题</h4><p>Ubuntu22.04LTS直接使用screenfetch可能会出现操作数问题, 从而导致部分信息无法正确显示。可以根据提示信息找到对应脚本文件进行修改</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/bin/screenfetch</span><br></pre></td></tr></table></figure><p>找到提示的配置文件所在行</p><p><img src="https://cdn.jsdelivr.net/gh/s-chance/firgure-bed/img/screenfetch202212300215987.png" alt="image-20221230021511877" /></p><p><strong>经过测试实际上是awk命令识别错误</strong></p><p>使用free命令查看相关信息, 配合awk查看输出情况</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -b</span><br><span class="line">free -b | awk <span class="string">&#x27;&#123;print $1&quot;-&quot;$6&#125;&#x27;</span></span><br><span class="line">free -b | awk <span class="string">&#x27;&#123;print $2&quot;-&quot;$7&#125;&#x27;</span></span><br><span class="line">free -b | awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;NR==2&#123;print $1&#125;&#x27;</span> | awk <span class="string">&#x27;&#123;print $2&quot;-&quot;$7&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/s-chance/firgure-bed/img/screenfetch202212300228383.png" alt="image-20221230022845310" /></p><p>修改脚本文件中的命令</p><p>将原本的<code>free -b | awk -F ':' 'NR==2&#123;print $2&#125;' | awk '&#123;print $1&quot;-&quot;$6&#125;'</code>替换为<code>free -b | awk -F ':' 'NR==2&#123;print $1&#125;' | awk '&#123;print $2&quot;-&quot;$7&#125;'</code></p><p><img src="https://cdn.jsdelivr.net/gh/s-chance/firgure-bed/img/screenfetch202212300256553.png" alt="image-20221230025640469" /></p><p>重新运行screenfetch, 效果如下, 所有信息都能正常输出</p><p><img src="https://cdn.jsdelivr.net/gh/s-chance/firgure-bed/img/screenfetch202212300258212.png" alt="image-20221230025832144" /></p><h3 id="neofetch命令"><a class="markdownIt-Anchor" href="#neofetch命令"></a> neofetch命令</h3><p>neofetch相对于screenfetch可定制性更高, 推荐使用</p><h4 id="安装-2"><a class="markdownIt-Anchor" href="#安装-2"></a> 安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install neofetch</span><br></pre></td></tr></table></figure><h4 id="手动编译安装"><a class="markdownIt-Anchor" href="#手动编译安装"></a> 手动编译安装</h4><p>从github克隆下来的源代码编译安装, 可使用最新版本的neofetch</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/dylanaraps/neofetch</span><br><span class="line"><span class="built_in">cd</span> neofetch</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h4 id="使用-2"><a class="markdownIt-Anchor" href="#使用-2"></a> 使用</h4><p>直接在终端输入以下命令即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">neofetch</span><br></pre></td></tr></table></figure><p>效果如下(这里我使用了kde环境)</p><p><img src="https://cdn.jsdelivr.net/gh/s-chance/firgure-bed/img/neofetch202212300318461.png" alt="image-20221230031810370" /></p><p>注意neofetch默认不显示Disk信息, 可修改配置文件来显示Disk信息</p><p>编辑配置文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.config/neofetch/config.conf</span><br></pre></td></tr></table></figure><p>添加如下的Disk配置即可, 同理其它信息显示也可以通过类似配置实现输出</p><p><img src="https://cdn.jsdelivr.net/gh/s-chance/firgure-bed/img/neofetch202212300326391.png" alt="image-20221230032639272" /></p><h4 id="其他用法"><a class="markdownIt-Anchor" href="#其他用法"></a> 其他用法</h4><h5 id="显示另一个发行版的标志"><a class="markdownIt-Anchor" href="#显示另一个发行版的标志"></a> 显示另一个发行版的标志</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># neofetch --ascii_distro distroname</span></span><br><span class="line">neofetch --ascii_distro <span class="built_in">arch</span></span><br><span class="line">neofetch --ascii_distro debian</span><br><span class="line"><span class="comment"># 在发行版名称后面加上后缀_small可输出对应发行版的迷你标志</span></span><br><span class="line">neofetch --ascii_distro arch_small</span><br><span class="line">neofetch --ascii_distro debian_small</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/s-chance/firgure-bed/img/neofetch202212300335106.png" alt="image-20221230033519980" /></p><h5 id="隐藏logo信息"><a class="markdownIt-Anchor" href="#隐藏logo信息"></a> 隐藏logo信息</h5><p>只输出系统信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">neofetch --off</span><br></pre></td></tr></table></figure><h5 id="隐藏系统信息"><a class="markdownIt-Anchor" href="#隐藏系统信息"></a> 隐藏系统信息</h5><p>只输出logo信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">neofetch -l</span><br></pre></td></tr></table></figure><h5 id="渐变色logo"><a class="markdownIt-Anchor" href="#渐变色logo"></a> 渐变色logo</h5><p><strong>neofetch配合lolcat实现渐变色的logo</strong></p><p>安装lolcat</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install lolcat</span><br></pre></td></tr></table></figure><p>使用管道命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">neofetch | lolcat</span><br></pre></td></tr></table></figure><h5 id="自定义图片logo"><a class="markdownIt-Anchor" href="#自定义图片logo"></a> 自定义图片logo</h5><p><strong>neofetch配合w3m自定义图片作为logo在终端展示</strong></p><p>安装w3m-img</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install w3m-img</span><br></pre></td></tr></table></figure><p>测试一下能否显示图片</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">w3m www.baidu.com</span><br></pre></td></tr></table></figure><p>添加图片路径, 否则默认为桌面壁纸</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">neofetch --w3m img/logo.png <span class="comment"># 图片路径根据实际情况编写</span></span><br></pre></td></tr></table></figure><p>在这边的测试环境下w3m出现了一定的显示问题, 可仿照上述格式替换参数进行测试</p><p>其它的显示图片参数caca、jp2a显示的是字符组成的logo, chafa显示的是低像素图, iterm2、sixel显示的是高像素图</p><p><strong>注意: 测试环境为kde, 不同环境包括不同配置在终端展示的图片不一定具有同等效果, 且存在一定的瑕疵, 请根据实际情况进行配置</strong></p><h4 id="默认终端启动时自动执行neofetch"><a class="markdownIt-Anchor" href="#默认终端启动时自动执行neofetch"></a> 默认终端启动时自动执行neofetch</h4><p>查看shell配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/shells</span><br></pre></td></tr></table></figure><p>根据实际配置修改对应配置文件, Ubuntu22.04LTS默认为bash, 另外还有zsh</p><p>修改bash配置文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>修改zsh配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.zshrc</span><br></pre></td></tr></table></figure><p>在文件末尾添加<strong>neofetch</strong>即可</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在linux操作系统的桌面用户群体中, 一个能够打印linux发行版logo以及相关系统信息的命令, 一定程度上能够使不同用户的linux系统更加个性化。基于Ubuntu22.04LTS, 下面介绍两个相关命令</summary>
    
    
    
    <category term="linux" scheme="https://s-chance.github.io/categories/linux/"/>
    
    
    <category term="linux优化" scheme="https://s-chance.github.io/tags/linux%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前后端知识</title>
    <link href="https://s-chance.github.io/2022/12/18/font-back-end/"/>
    <id>https://s-chance.github.io/2022/12/18/font-back-end/</id>
    <published>2022-12-18T09:40:47.000Z</published>
    <updated>2022-12-18T17:13:20.591Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开发模式"><a class="markdownIt-Anchor" href="#开发模式"></a> 开发模式</h3><p><strong>前后端分离</strong>已成为web大型项目的标准开发方式, 主要解决了<strong>传统的前后端不分离</strong>所带来的一系列开发过程中的问题<span id="more"></span></p><h4 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h4><p><strong>前后端不分离</strong>: 前后端代码放在一个工程下或同一个目录下, 前端页面中含有后端的代码(如典型的jsp页面内嵌java代码)。前后端代码以及前后端工作开发<strong>耦合度极高</strong>, 前后端需要同时协作才能完成开发</p><p><strong>前后端分离</strong>: 前后端代码放在不同的工程下, 只需要<strong>提前约定好API数据规范</strong>, 前后端就可以各自独立开发。前端可以通过<strong>Mock技术模拟后端API服务</strong>来独立运行和测试; 后端也可以独立开发、运行、测试, 通过<strong>Swagger技术自动生成API文档</strong>提供给前端, 还能进行自动化接口测试API的可用性</p><h4 id="前后端分离涉及的技术"><a class="markdownIt-Anchor" href="#前后端分离涉及的技术"></a> 前后端分离涉及的技术</h4><p>1.Ajax、axios和json等基础交互技术</p><p>2.Http协议在同源策略下引发的跨域访问</p><p>3.Nodejs搭建中间层服务器以及前端Mock测试</p><h4 id="对比"><a class="markdownIt-Anchor" href="#对比"></a> 对比</h4><p><strong>以一个SpringBoot项目为例</strong></p><p>前后端不分离的情况下, <strong>直接使用SpringBoot启动即可</strong></p><ul><li>需要考虑静态资源所存放的相对路径(例如需要存放在某个指定的静态资源static目录下)</li><li>在测试过程中遇到问题难以快速定位到问题位于前端还是后端</li><li>运行时出现问题会直接导致SpringBoot项目无法启动或者运行时无法正确地进行前后端交互测试</li><li>对于**SEO(Search Engine Optimization, 搜索引擎优化)**的支持较好</li></ul><p>前后端分离的情况下, <strong>后端使用SpringBoot启动, 前端使用Nodejs启动</strong></p><ul><li>不再需要考虑相对路径的限制</li><li>可以使用特定的技术来模拟前后端进行数据交互测试, 从而准确定位问题</li><li>会有跨域访问的限制</li><li>由于前端与后端分离导致服务端无法去渲染前端页面, 即<strong>一般情况下不支持SSR(Server-Side-Rendering，服务器端渲染)</strong></li></ul><h3 id="渲染方式"><a class="markdownIt-Anchor" href="#渲染方式"></a> 渲染方式</h3><p>渲染方式可分为<strong>SSR服务端渲染</strong>和<strong>CSR客户端渲染</strong></p><p><strong>SSR服务端渲染</strong></p><ul><li><p>SSR拥有很好的SEO搜索引擎优化</p></li><li><p>SSR的首屏优化很好, 即首屏时间短</p></li><li><p>SSR加重了服务端的负载, 因为渲染需要在服务端完成</p></li><li><p>SSR的页面交互性较差</p></li><li><p>使用SSR基本说明了前后端不分离</p></li><li><p>SSR非常适合开发静态网站以及业务逻辑复杂的网站</p></li></ul><p><strong>CSR客户端渲染</strong></p><ul><li><p>CSR不支持SEO搜索引擎优化, 因为数据是异步获取的, 很难被SEO收录</p></li><li><p>CSR的首屏时间较长</p></li><li><p>CSR减轻了服务器的负载, 因为渲染是在客户端完成的</p></li><li><p>CSR的页面交互性非常好</p></li><li><p>使用CSR基本说明了前后端分离</p></li><li><p>CSR非常适合开发对即时交互性要求较高的Web应用程序以及app小程序</p></li></ul><p>基于不同的渲染方式又可以引出<strong>SPA</strong>和<strong>MPA</strong></p><h3 id="spa和mpa"><a class="markdownIt-Anchor" href="#spa和mpa"></a> SPA和MPA</h3><p><strong>SPA单页面应用模式</strong></p><ul><li>SPA模式只拥有一个主页面, 所有的静态资源都包含在主页面中, 只需要加载一次</li><li>所有的功能模块组件化, 通过刷新局部资源来实现功能</li><li>几乎不存在<strong>转发</strong>和<strong>重定向</strong>的概念</li><li>传统SPA通常都是CSR渲染, 也可以借助SSR渲染来优化SEO</li><li>SPA的实现核心是<strong>前端路由</strong>, 前端路由的核心: 改变视图的同时不会向后端发出请求</li><li>单个vue+vite的工程就是典型的SPA模式</li></ul><p><strong>MPA多页面应用模式</strong></p><ul><li>MPA模式拥有多个页面, 所有的静态资源都是公共资源, 每个页面都需要重新加载</li><li>所有的功能会划分到多个页面中, 通过转发和重定向页面来实现功能</li><li>MPA通常都是SSR渲染, 基本不会使用CSR渲染, 因为逻辑较为复杂</li><li>MPA中基本没有前端路由</li></ul><p>目前大型Web项目开发可能更多的是使用MPA+SPA的混合模式</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;开发模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#开发模式&quot;&gt;&lt;/a&gt; 开发模式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;前后端分离&lt;/strong&gt;已成为web大型项目的标准开发方式, 主要解决了&lt;strong&gt;传统的前后端不分离&lt;/strong&gt;所带来的一系列开发过程中的问题</summary>
    
    
    
    
    <category term="前后端" scheme="https://s-chance.github.io/tags/%E5%89%8D%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>在Linux上配置Java环境</title>
    <link href="https://s-chance.github.io/2022/11/26/java-in-linux/"/>
    <id>https://s-chance.github.io/2022/11/26/java-in-linux/</id>
    <published>2022-11-26T06:20:08.000Z</published>
    <updated>2022-12-29T16:23:48.670Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基于ubuntu2004lts配置java环境"><a class="markdownIt-Anchor" href="#基于ubuntu2004lts配置java环境"></a> 基于Ubuntu20.04LTS配置Java环境</h3><p>在Linux上配置Java环境的方式有3种, 系统级配置、用户级配置、临时配置</p><p>配置好Java环境就能够在Linux上运行基于Java环境运行的相关程序, 你可以在Linux系统上搭建基于Java实现的网站。这里以<strong>系统级配置</strong>为例, 适合个人开发者使用<span id="more"></span></p><h4 id="1下载targz压缩包-java官网"><a class="markdownIt-Anchor" href="#1下载targz压缩包-java官网"></a> 1.下载tar.gz压缩包 <a href="https://www.oracle.com/java/technologies/downloads/">Java官网</a></h4><p>tar.gz包先下载到windows中, 再通过远程文件传输工具, 将压缩包传送到Linux的目录下, 这里是/root目录</p><p>本文以<strong>jdk-8u151-linux-i586.tar.gz</strong>为例配置Java环境, 高版本可能有所区别, 32位与64位版本在不同linux发行版上可能有所区别</p><h4 id="2在linux中配置环境"><a class="markdownIt-Anchor" href="#2在linux中配置环境"></a> 2.在Linux中配置环境</h4><h5 id="1前提准备"><a class="markdownIt-Anchor" href="#1前提准备"></a> 1.前提准备</h5><p>默认当前目录是<strong>初始目录/root</strong>, 默认当前用户权限为<strong>root权限</strong>, 默认<strong>tar.gz包已经传送到/root目录下</strong></p><h5 id="2创建用于存放java文件夹的目录"><a class="markdownIt-Anchor" href="#2创建用于存放java文件夹的目录"></a> 2.创建用于存放Java文件夹的目录</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /usr/java</span><br></pre></td></tr></table></figure><h5 id="3解压targz压缩包到该目录"><a class="markdownIt-Anchor" href="#3解压targz压缩包到该目录"></a> 3.解压tar.gz压缩包到该目录</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tar -zxvf jdk-8u151-linux-i586.tar.gz -C /usr/java</span><br></pre></td></tr></table></figure><h5 id="4编辑环境变量文件"><a class="markdownIt-Anchor" href="#4编辑环境变量文件"></a> 4.编辑环境变量文件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure><p>在文件末尾追加下面内容, 具体目录根据实际情况编写</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.8.0_151</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><dl><dt><strong>一些特殊符号说明</strong></dt><dd>表示并列符号, 说明某个变量的值有多个, 用 : 来区分。相当于Windows下的 ;</dd></dl><p>$ 表示引用变量, {} 则用于限定变量边界, 如上面的 ${JAVA_HOME} 就表示 /usr/java/jdk1.8.0_151</p><h5 id="5使环境变量马上生效"><a class="markdownIt-Anchor" href="#5使环境变量马上生效"></a> 5.使环境变量马上生效</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h4 id="3测试java环境"><a class="markdownIt-Anchor" href="#3测试java环境"></a> 3.测试Java环境</h4><p>运行以下命令, 如果都成功运行, 则说明Java环境配置完成</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">java</span><br><span class="line">javac</span><br></pre></td></tr></table></figure><h5 id="可能遇到的问题"><a class="markdownIt-Anchor" href="#可能遇到的问题"></a> 可能遇到的问题</h5><p>安装i586后缀jdk, 即<strong>安装32位的jdk</strong>后测试Java环境时提示<strong>bash: /usr/lib/java/jdk1.8.0_151/bin/java: 没有那个文件或目录</strong>, 可能是由于当前Linux发行版<strong>默认没有用于amd64系统的32位libc开发包</strong></p><p>可通过以下5个常用命令查看Linux发行版的架构信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br><span class="line">dpkg --print-architecture <span class="comment"># 这条命令只适用于基于Debian和Ubuntu的Linux发行版</span></span><br><span class="line">getconf LONG_BIT</span><br><span class="line"><span class="built_in">arch</span></span><br><span class="line">file /sbin/init </span><br><span class="line"><span class="comment"># file命令需要配合它链接的另一个文件使用</span></span><br><span class="line"><span class="comment"># 在Ubuntu中是链接的是/lib/systemd/systemd</span></span><br><span class="line"><span class="comment"># 通过file /lib/systemd/systemd查看到架构信息</span></span><br></pre></td></tr></table></figure><h5 id="安装缺失的32位开发包"><a class="markdownIt-Anchor" href="#安装缺失的32位开发包"></a> 安装缺失的32位开发包</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libc6-i386</span><br></pre></td></tr></table></figure><p>如果安装libc6-i386失败, 请先更新软件列表, 再尝试重新安装, 并重新测试Java环境</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>如果还是失败请选择64位的jdk版本重新进行配置</p><h5 id="重新测试java环境"><a class="markdownIt-Anchor" href="#重新测试java环境"></a> 重新测试Java环境</h5><h4 id="4update-alternatives软件版本管理"><a class="markdownIt-Anchor" href="#4update-alternatives软件版本管理"></a> 4.update-alternatives软件版本管理</h4><h5 id="1系统注册jdk需要使用多个jdk版本时"><a class="markdownIt-Anchor" href="#1系统注册jdk需要使用多个jdk版本时"></a> 1.系统注册jdk(需要使用多个jdk版本时)</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/java java /usr/java/jdk1.8.0_151/bin/java 300</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><p>第一个参数: --install表示向update-alternatives注册服务名</p><p>第二个参数: 注册<strong>最终地址</strong>, 成功后将会把命令在这个固定的目的地址做真实命令的<strong>软链接</strong>, 通过管理这个软链就能实现不同版本jdk的切换</p><p>第三个参数: <strong>服务名</strong>, 管理时以它为关联依据</p><p>第四个参数: 被管理命令的<strong>绝对路径</strong></p><p>第五个参数: <strong>优先级</strong>, 数字越大优先级越高</p><h5 id="2交互式修改"><a class="markdownIt-Anchor" href="#2交互式修改"></a> 2.交互式修改</h5><p>如果有多个版本的jdk, 可执行下面的命令通过交互界面进行切换</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --config java</span><br></pre></td></tr></table></figure><p>查看多个版本的jdk以及当前状态</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --display java</span><br></pre></td></tr></table></figure><p>调整为<strong>auto</strong>模式, 如果上面查看的状态是<strong>manual</strong>, 则还不能自动选择优先级高的jdk版本, 需要调整为auto模式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --auto java</span><br></pre></td></tr></table></figure><h4 id="5补充"><a class="markdownIt-Anchor" href="#5补充"></a> 5.补充</h4><p><strong>将上述的/etc/profile替换成~/.bashrc就是用户级配置</strong></p><p><strong>/etc/profile</strong>: 此文件为系统的每个用户设置环境信息, 当用户第一次登录时, 该文件被执行, 是<strong>系统全局</strong>对终端环境的设置, 它是login时最先被系统加载的, 是它调用了/etc/bashrc, 以及/etc/profile.d目录下的*.sh文件, 如果有一个软件包, 系统上只安装一份, 供所有开发者使用, 建议在/etc/profile.d下创建一个新的xxx.sh, 配置环境变量</p><p><strong>~/.bashrc</strong>: 是<strong>用户</strong>相关的终端（shell）的环境设置, 通常打开一个新终端时, 默认会加载里面的设置, 在这里的设置不会影响其它用户。如果一个服务器多个开发者使用, 需要配置多个sdk, 则推荐使用该设置</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;基于ubuntu2004lts配置java环境&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基于ubuntu2004lts配置java环境&quot;&gt;&lt;/a&gt; 基于Ubuntu20.04LTS配置Java环境&lt;/h3&gt;
&lt;p&gt;在Linux上配置Java环境的方式有3种, 系统级配置、用户级配置、临时配置&lt;/p&gt;
&lt;p&gt;配置好Java环境就能够在Linux上运行基于Java环境运行的相关程序, 你可以在Linux系统上搭建基于Java实现的网站。这里以&lt;strong&gt;系统级配置&lt;/strong&gt;为例, 适合个人开发者使用</summary>
    
    
    
    <category term="linux" scheme="https://s-chance.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://s-chance.github.io/tags/linux/"/>
    
    <category term="Java" scheme="https://s-chance.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>linux-base</title>
    <link href="https://s-chance.github.io/2022/11/17/linux-base/"/>
    <id>https://s-chance.github.io/2022/11/17/linux-base/</id>
    <published>2022-11-17T11:58:38.000Z</published>
    <updated>2022-12-29T16:24:07.907Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于linux的通用操作"><a class="markdownIt-Anchor" href="#关于linux的通用操作"></a> 关于Linux的通用操作</h3><p>基于Ubuntu22.04发行版的环境，本文整理了一些在Linux系统下基本通用的操作，使初学者能初步学会Linux系统的操作或使老用户重新回顾一下常用操作<span id="more"></span></p><h4 id="参考文章-linux-幕布-mubucom-作者时光逝"><a class="markdownIt-Anchor" href="#参考文章-linux-幕布-mubucom-作者时光逝"></a> 参考文章 <a href="https://mubu.com/doc/28TtabEpGV3">Linux - 幕布 (mubu.com) 作者：时光＆逝 </a></h4><h4 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h4><p>远程连接工具<a href="https://www.xshell.com/zh/xshell/">XSHELL - NetSarang Website</a></p><p>远程文件传输工具 <a href="https://www.xshell.com/zh/xftp/">XFTP - NetSarang Website</a></p><p>配合XFTP可以较为直观地观察文件及目录的变化</p><p>注：一些发行版可能需要手动安装部分命令。另外，在执行命令时<strong>请确认自己所处的当前目录</strong></p><h4 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 提示</h4><p>一些命令可能需要在root权限下执行，或者在执行命令的前面都加上<code>sudo</code>的前缀，表示临时使用root权限执行这条命令</p><p>如果忘记了root密码可以通过以下方法重新设置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo passwd <span class="comment"># 进入密码设置</span></span><br><span class="line"><span class="comment"># 输入当初安装时设置的非root普通用户密码</span></span><br><span class="line"><span class="comment"># 输入新的root密码</span></span><br><span class="line"><span class="comment"># 重复输入root密码</span></span><br><span class="line">su <span class="comment"># 切换到root</span></span><br><span class="line"><span class="comment"># 输入刚刚设置的root密码，就能切换到root用户</span></span><br></pre></td></tr></table></figure><h4 id="vim文本编辑器"><a class="markdownIt-Anchor" href="#vim文本编辑器"></a> vim文本编辑器</h4><p><strong>查看vim配置信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim --version</span><br></pre></td></tr></table></figure><p><strong>简易配置一下vim</strong></p><p>用vim打开用户vimrc文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim <span class="variable">$HOME</span>/.vimrc</span><br></pre></td></tr></table></figure><p>写入以下内容（后面的注释不需要）</p><blockquote><p>syntax on   # 开启语法高亮</p><p>set ts = 4    #  设置tab的缩进显示为四个空格的宽度</p><p>set expandtab # 设置tab字符替换为等宽的4个空格字符</p><p>set autoindent # 开启自动缩进</p><p>set number # 开启行号显示</p><p>set relativenumber # 使用相对行号</p></blockquote><p>关于vim的基本操作可以参考其它文章 <a href="https://www.runoob.com/linux/linux-vim.html">Linux vi/vim | 菜鸟教程 (runoob.com)</a> 或者视频<a href="https://www.bilibili.com/video/BV13t4y1t7Wg/?share_source=copy_web&amp;vd_source=f4fedbdbfad10afdb2269285bd340510">【保姆级入门】Vim编辑器</a></p><h4 id="用户管理"><a class="markdownIt-Anchor" href="#用户管理"></a> 用户管理</h4><p>linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户都必须先向系统管理员申请一个账号，然后以这个账号的身份进入系统</p><p>linux的用户至少要属于一个组</p><h5 id="基本命令"><a class="markdownIt-Anchor" href="#基本命令"></a> 基本命令</h5><p><strong>useradd命令</strong>：创建一个用户</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># useradd [参数] 用户名</span></span><br><span class="line">useradd normal <span class="comment"># 创建一个名为normal的用户，用户目录默认家目录</span></span><br><span class="line">useradd -d /myuser normal <span class="comment"># 创建一个名为normal的用户，指定用户目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># useradd [参数] 组名 用户名</span></span><br><span class="line">useradd -g visitor vis <span class="comment"># 创建一个名为vis的用户的同时指定用户组为visitor</span></span><br></pre></td></tr></table></figure><p><strong>passwd命令</strong>：指定或修改用户的密码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># passwd 用户名</span></span><br><span class="line">passwd normal <span class="comment"># 指定或修改normal用户的密码</span></span><br></pre></td></tr></table></figure><p><strong>userdel命令</strong>：删除用户</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># userdel 用户名</span></span><br><span class="line">userdel normal <span class="comment"># 删除normal用户</span></span><br><span class="line">userdel -r normal <span class="comment"># 同时删除该用户的目录</span></span><br></pre></td></tr></table></figure><p><strong>usermod命令</strong>：修改用户信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># usermod [参数] 新用户名 旧用户名</span></span><br><span class="line">usermod -l vis normal <span class="comment"># 修改normal用户名为vis、</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># usermod [参数] 组名 用户名</span></span><br><span class="line">groupadd demo</span><br><span class="line">usermod -g demo vis <span class="comment"># 修改vis用户所在的用户组为demo组</span></span><br></pre></td></tr></table></figure><p><strong>id命令</strong>：查询用户信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># id 用户名</span></span><br><span class="line"><span class="built_in">id</span> normal <span class="comment"># 查询normal用户信息</span></span><br></pre></td></tr></table></figure><p><strong>su命令</strong>：用户切换</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># su [参数] 用户名</span></span><br><span class="line">su common <span class="comment"># 切换到一个名为common的用户</span></span><br><span class="line">su - common <span class="comment"># 将环境变量一并切换为common用户的环境变量</span></span><br></pre></td></tr></table></figure><p><strong>groupadd命令</strong>：添加一个名为visitor的用户组</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># groupadd 组名</span></span><br><span class="line">groupadd visitor</span><br></pre></td></tr></table></figure><p><strong>groupdel命令</strong>：删除visitor用户组</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># groupdel 组名</span></span><br><span class="line">groupdel visitor</span><br></pre></td></tr></table></figure><p><strong>groupmod命令</strong>：修改用户组</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># groupmod [选项 参数] 组名</span></span><br><span class="line">groupmod -n demo <span class="built_in">test</span> <span class="comment"># 修改test组名为demo</span></span><br><span class="line">groupmod -g 9999 <span class="built_in">test</span> <span class="comment"># 修改test组ID为9999</span></span><br></pre></td></tr></table></figure><h5 id="用户信息文件"><a class="markdownIt-Anchor" href="#用户信息文件"></a> 用户信息文件</h5><ul><li><p><strong>/etc/passwd</strong>是用户(user)的配置文件，记录用户的各种信息</p></li><li><p><strong>/ect/shadow</strong>是口令的配置文件</p></li><li><p><strong>/etc/group</strong>是组(group)的配置文件，记录组的各种信息</p></li></ul><h4 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h4><h5 id="进程命令"><a class="markdownIt-Anchor" href="#进程命令"></a> 进程命令</h5><p><strong>init命令</strong>：Linux下的进程初始化工具，用于切换运行级别</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">init 0 <span class="comment"># 停机(不要将initdefault设置为0)</span></span><br><span class="line">init 1 <span class="comment"># 单用户模式，一般用于系统级维护</span></span><br><span class="line">init 2 <span class="comment"># 多用户模式，无法使用NFS(网络文件系统)挂载，没有网络支持</span></span><br><span class="line">init 3 <span class="comment"># 多用户模式，标准的运行级，有网络支持</span></span><br><span class="line">init 4 <span class="comment"># 保留，未使用</span></span><br><span class="line">init 5 <span class="comment"># X11(xwindow)图形化界面模式，多用户，有网络支持，一般用于远程连接时使用Linux图形化界面</span></span><br><span class="line">init 6 <span class="comment"># 重新启动(不要将initdefault设置为6)</span></span><br></pre></td></tr></table></figure><h5 id="帮助命令"><a class="markdownIt-Anchor" href="#帮助命令"></a> 帮助命令</h5><p><strong>man命令</strong>：用于获取帮助手册</p><p><strong>help命令</strong>：获取shell内置命令的帮助信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man vim <span class="comment"># 获取vim的帮助手册</span></span><br><span class="line"><span class="built_in">help</span> <span class="built_in">cd</span> <span class="comment"># 获取cd命令的帮助信息</span></span><br><span class="line"><span class="built_in">help</span> <span class="built_in">mv</span> <span class="comment"># 获取mv命令的帮助信息，但会失败，因为mv不是内置命令</span></span><br><span class="line"><span class="built_in">type</span> <span class="built_in">mv</span> <span class="comment"># 查看mv命令的类型(内置命令或外部命令)</span></span><br></pre></td></tr></table></figure><h5 id="文件目录命令"><a class="markdownIt-Anchor" href="#文件目录命令"></a> 文件目录命令</h5><p><strong>pwd命令</strong>：查看当前所在目录的绝对路径</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><p><strong>ls命令</strong>：查看当前所在目录的所有文件和目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls [参数] [目录或文件名]</span></span><br><span class="line"><span class="built_in">ls</span> -a <span class="comment"># 显示当前所有文件和目录，包括不可见的</span></span><br><span class="line"><span class="built_in">ls</span> -l <span class="comment"># 以列表的形式显示信息</span></span><br></pre></td></tr></table></figure><p><strong>cd命令</strong>：切换到指定目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd [目录路径]</span></span><br><span class="line"><span class="built_in">cd</span> ~  <span class="comment"># 进入默认初始目录</span></span><br><span class="line"><span class="built_in">cd</span> .. <span class="comment"># 返回上一级目录</span></span><br><span class="line"><span class="built_in">cd</span> /opt <span class="comment"># 进入opt目录</span></span><br></pre></td></tr></table></figure><p><strong>mkdir命令</strong>：创建指定目录，可根据绝对路径或相对路径创建</p><p><strong>rmdir命令</strong>：删除指定的空目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkdir [参数] 目录名</span></span><br><span class="line"><span class="built_in">mkdir</span> <span class="built_in">test</span> <span class="comment"># 在当前目录下创建一个test目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p a/b/c <span class="comment"># 在当前目录下创建a/b/c的嵌套多级目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rmdir [参数] 目录名</span></span><br><span class="line"><span class="built_in">rmdir</span> <span class="built_in">test</span> <span class="comment"># 删除test目录，test目录下不能有其它内容</span></span><br><span class="line"><span class="comment"># 删除有其它内容的目录时需要使用rm -rf命令</span></span><br></pre></td></tr></table></figure><p><strong>touch命令</strong>：创建空文件，可根据绝对路径或相对路径创建</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># touch 文件名</span></span><br><span class="line"><span class="built_in">touch</span> demo.txt <span class="comment"># 在当前目录下创建demo.txt文件</span></span><br></pre></td></tr></table></figure><p><strong>cp命令</strong>：拷贝文件到指定目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cp [参数] 源目录 指定目录</span></span><br><span class="line"><span class="built_in">cp</span> demo.txt <span class="built_in">test</span> <span class="comment"># 复制demo.txt文件到当前同级的test目录下</span></span><br><span class="line"><span class="built_in">cp</span> -r <span class="built_in">source</span> <span class="built_in">test</span> <span class="comment"># 将source文件夹以及文件夹下所有内容复制到同级的test文件夹下(递归复制)</span></span><br></pre></td></tr></table></figure><p><strong>rm命令</strong>：删除文件或目录（文件夹）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rm [参数] 文件名</span></span><br><span class="line"><span class="built_in">rm</span> demo.txt <span class="comment"># 删除demo.txt文件</span></span><br><span class="line"><span class="built_in">rm</span> -r <span class="built_in">source</span> <span class="comment"># 递归删除整个source目录</span></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="built_in">test</span> <span class="comment"># 无提示地强制删除整个test目录 </span></span><br></pre></td></tr></table></figure><p><strong>cat命令</strong>：只读地查看文件内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat [参数] 文件名</span></span><br><span class="line"><span class="built_in">cat</span> demo.txt <span class="comment"># 查看demo.txt的内容</span></span><br><span class="line"><span class="built_in">cat</span> -n demo.txt <span class="comment"># 查看文件时显示行号</span></span><br></pre></td></tr></table></figure><p><strong>more命令</strong>：基于vi编辑器的文本过滤器，以全屏方式按页显示文件内容，适合阅读长内容的文本</p><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">具体功能</th></tr></thead><tbody><tr><td style="text-align:center">空格(space)</td><td style="text-align:center">向下翻一页</td></tr><tr><td style="text-align:center">Enter</td><td style="text-align:center">向下翻一行</td></tr><tr><td style="text-align:center">q</td><td style="text-align:center">退出</td></tr><tr><td style="text-align:center">Ctrl+F</td><td style="text-align:center">向下滚动一屏</td></tr><tr><td style="text-align:center">Ctrl+B</td><td style="text-align:center">返回上一屏</td></tr><tr><td style="text-align:center">=</td><td style="text-align:center">输出当前行行号</td></tr><tr><td style="text-align:center">:f</td><td style="text-align:center">输出文件名和行号</td></tr></tbody></table><p><strong>less命令</strong>： 来分屏查看文件内容，与<strong>more命令</strong>类似，但功能更加强大。能根据显示需要加载文件内容，而不是一次性加载，对于显示大型文件有较高的效率</p><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">具体功能</th></tr></thead><tbody><tr><td style="text-align:center">空格(space)</td><td style="text-align:center">向下翻一页</td></tr><tr><td style="text-align:center">[pagedown]</td><td style="text-align:center">向下翻一页</td></tr><tr><td style="text-align:center">[pageup]</td><td style="text-align:center">向上翻一页</td></tr><tr><td style="text-align:center">/字串</td><td style="text-align:center">向下搜寻字串 n向下 N向上</td></tr><tr><td style="text-align:center">?字串</td><td style="text-align:center">向上搜寻字串 n向上 N向下</td></tr><tr><td style="text-align:center">q</td><td style="text-align:center">退出</td></tr></tbody></table><p><strong>&gt;指令</strong>：输出重定向，会覆盖文件的内容</p><p><strong>&gt;&gt;指令</strong>：追加内容到文件尾部，不会覆盖文件的内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> &gt; info.txt <span class="comment"># 将当前目录的信息写入info.txt</span></span><br><span class="line"><span class="built_in">ls</span> -l &gt; info.txt <span class="comment"># 覆盖info.txt的内容为列表形式的目录信息</span></span><br><span class="line"><span class="built_in">ls</span> &gt;&gt; info.txt <span class="comment"># 将目录信息追加到文件末尾</span></span><br></pre></td></tr></table></figure><p><strong>echo命令</strong>：输出内容到控制台，可与**&gt;指令或&gt;&gt;指令**组合使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo [参数] [字符串]</span></span><br><span class="line"><span class="built_in">echo</span> hello world <span class="comment"># 输出hello world到控制台</span></span><br><span class="line"><span class="built_in">echo</span> happy &gt;&gt; info.txt <span class="comment"># 此时控制台不会输出内容，内容追加到info.txt中，具体内容可以自定义</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span> <span class="comment"># 获取PATH变量，PATH是原本就存在于Linux下的环境变量</span></span><br></pre></td></tr></table></figure><p><strong>head命令</strong>：查看文件前n行内容，n默认为10</p><p><strong>tail命令</strong>：查看文件后n行内容，n默认为10</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># head [参数] [行数] 文件名</span></span><br><span class="line"><span class="built_in">head</span> info.txt <span class="comment"># 查看info.txt的前10行内容</span></span><br><span class="line"><span class="built_in">head</span> -n 3 info.txt <span class="comment"># 查看info.txt的前3行内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tail [参数] [行数] 文件名</span></span><br><span class="line"><span class="built_in">tail</span> info.txt <span class="comment"># 查看info.txt的后10行内容</span></span><br><span class="line"><span class="built_in">tail</span> -n 3 info.txt <span class="comment"># 查看info.txt的后3行内容</span></span><br></pre></td></tr></table></figure><p><strong>ln命令</strong>：给源文件创建一个<strong>软链接</strong>。软链接也称符号链接，类似于快捷方式，主要存放了链接其他文件的路径。可以通过ln命令<strong>软链接的方式</strong>设置<strong>全局</strong>环境变量（这是一种方式）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ln -s 源文件路径 目标路径</span></span><br><span class="line"><span class="built_in">ln</span> -s info.txt <span class="built_in">test</span>/ <span class="comment"># 将info.txt软链接到同级的test目录下</span></span><br></pre></td></tr></table></figure><h5 id="时间日期命令"><a class="markdownIt-Anchor" href="#时间日期命令"></a> 时间日期命令</h5><p><strong>date命令</strong>：显示或设定系统的日期和时间</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># date [参数] [格式]</span></span><br><span class="line"><span class="built_in">date</span> <span class="comment"># 显示当前系统时间</span></span><br><span class="line"><span class="built_in">date</span> -u <span class="comment"># 显示UTC时间</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;+1 day&quot;</span> +%Y%m%d <span class="comment"># 显示后一天的日期</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;-1 month&quot;</span> +%Y%m%d <span class="comment"># 显示上一月的日期</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;2022-11-18 06:30:00&quot;</span> <span class="comment"># 设置系统时间为2022年11月18日 6时30分0秒，重启系统后会失效</span></span><br></pre></td></tr></table></figure><p><strong>cal命令</strong>：显示月历，需要手动安装命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install ncal <span class="comment"># 安装命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cal [参数] [月份] [年份]</span></span><br><span class="line">cal <span class="comment"># 查看本月月历</span></span><br><span class="line">cal 12 2022 <span class="comment"># 查看2022年12月月历</span></span><br></pre></td></tr></table></figure><h5 id="搜索查找命令"><a class="markdownIt-Anchor" href="#搜索查找命令"></a> 搜索查找命令</h5><p><strong>find命令</strong>：从指定目录向下递归地遍历各个子目录，将满足条件的文件或目录显示在终端</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># find [搜索范围] [参数] ...</span></span><br><span class="line">find . -name <span class="string">&quot;*.txt&quot;</span> <span class="comment"># 查找当前目录及子目录下文件名后缀为txt的文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f <span class="comment"># 查找当前目录及子目录下普通类型的文件</span></span><br><span class="line">find . -user root <span class="comment"># 查找当前目录及子目录下属于root用户的文件</span></span><br><span class="line">find . -size 0 <span class="comment"># 查找当前目录及子目录下长度为0的文件</span></span><br></pre></td></tr></table></figure><p><strong>locate命令</strong>：可以快速定位文件路径，需要手动安装命令。利用事先建立的包含系统中所有文件名称路径的locate数据库实现快速定位，无需遍历整个文件夹，查询速度较快。</p><p>locate数据库不是实时更新的(默认情况下每天自动更新一次)，无法查询当天新建的文件，但可以手动更新locate数据库</p><p><font color='red'>注意：测试命令需要新建文件时，记得随时手动更新locate数据库</font></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install plocate <span class="comment"># 安装命令</span></span><br><span class="line">updatedb <span class="comment"># 手动更新locate数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># locate [参数] [文件名]</span></span><br><span class="line">locate passwd <span class="comment"># 查找passwd文件</span></span><br><span class="line">locate /etc/sh <span class="comment"># 查找etc目录下所有以sh开头的文件</span></span><br><span class="line">locate -n 2 passwd <span class="comment"># 最多显示2个输出</span></span><br><span class="line">locate -i ~/r <span class="comment"># 忽略大小写查找当前用户目录下r开头的文件</span></span><br></pre></td></tr></table></figure><p><strong>grep命令</strong>：在指定文件里查找指定的内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># grep [内容] [文件名]</span></span><br><span class="line">grep root info.txt <span class="comment"># 在info.txt里查找root字符所在的行并输出到控制台</span></span><br><span class="line">grep -n root info.txt <span class="comment"># 显示在完整文本中对应匹配的行号</span></span><br><span class="line">grep -i root info.txt <span class="comment"># 忽略大小写进行查找</span></span><br></pre></td></tr></table></figure><h5 id="压缩与解压命令"><a class="markdownIt-Anchor" href="#压缩与解压命令"></a> 压缩与解压命令</h5><p><strong>gzip命令</strong>：压缩文件，格式只能为*.gz，它的设计目标是为了处理单个文件</p><p><strong>gunzip命令</strong>：解压文件，只能解压*.gz后缀的文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gzip 文件</span></span><br><span class="line">gzip info.txt <span class="comment"># 压缩info.txt文件为info.txt.gz文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gunzip 文件</span></span><br><span class="line">gunzip info.txt.gz <span class="comment"># 解压info.txt.gz文件为info.txt文件</span></span><br></pre></td></tr></table></figure><p><strong>zip命令</strong>：压缩文件和目录，适用于多个文件和目录</p><p><strong>unzip命令</strong>：解压文件和目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zip [参数] 文件名.zip 要压缩的文件名</span></span><br><span class="line">zip info.zip info.txt <span class="comment"># 将info.txt压缩到info.zip中</span></span><br><span class="line">zip -r test.zip <span class="built_in">test</span>/ <span class="comment"># 将test目录下所有文件和子目录递归压缩，用于处理多文件多目录的压缩</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># unzip [参数] 文件名.zip</span></span><br><span class="line">unzip test.zip <span class="comment"># 直接解压test.zip</span></span><br><span class="line">unzip -d beta/ test.zip <span class="comment"># 指定解压test.zip到同级的beta目录下 </span></span><br></pre></td></tr></table></figure><p><strong>tar命令</strong>：打包目录或解包tar文件，并且能附加压缩和解压功能</p><p>注意：打包和压缩包不是一个概念，解包和解压也不是</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tar 必填参数[选填参数] 打包文件名 源文件名</span></span><br><span class="line">tar -cvf info.tar info.txt <span class="comment"># 打包info.txt到info.tar中</span></span><br><span class="line">tar -zcvf info.tar.gz info.txt <span class="comment"># 打包的同时使用gzip进行压缩</span></span><br><span class="line"></span><br><span class="line">tar -xvf info.tar <span class="comment"># 解包info.tar</span></span><br><span class="line">tar -zxvf info.tar.gz <span class="comment"># 解压并解包info.tar.gz</span></span><br><span class="line"></span><br><span class="line">tar -tvf info.tar <span class="comment"># 不解压，仅查看包中的文件信息</span></span><br><span class="line"><span class="comment"># 指定解包到哪个目录</span></span><br><span class="line">tar -xvf info.tar -C /tmp <span class="comment"># 解包到tmp目录下</span></span><br></pre></td></tr></table></figure><h5 id="路由表命令"><a class="markdownIt-Anchor" href="#路由表命令"></a> 路由表命令</h5><p><strong>route命令</strong>： 显示和操作IP路由表</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># route [参数]</span></span><br><span class="line">route <span class="comment"># 查看路由表</span></span><br><span class="line">route -n <span class="comment"># 不解析名字</span></span><br></pre></td></tr></table></figure><h5 id="文本操作命令"><a class="markdownIt-Anchor" href="#文本操作命令"></a> 文本操作命令</h5><p><strong>sed命令</strong>：能够在不打开文件的情况下处理、编辑文本文件， 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sed [参数] 文件名</span></span><br><span class="line">sed -e <span class="string">&#x27;s/-/*/g&#x27;</span> info.txt &gt;&gt; info.txt <span class="comment"># 将info.txt中所有的字符-替换为*，并应用修改到info.txt中</span></span><br></pre></td></tr></table></figure><h4 id="组管理与权限管理"><a class="markdownIt-Anchor" href="#组管理与权限管理"></a> 组管理与权限管理</h4><h5 id="组管理"><a class="markdownIt-Anchor" href="#组管理"></a> 组管理</h5><p>在linux中的每个用户必须属于一个组，不能独立于组外</p><p>在linux中每个文件有所有者、所在组、其它组的概念</p><p>文件的所有者就是创建该文件的用户</p><p>除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组</p><p>提示：<strong>查看文件权限、所有者等信息</strong>可以使用<strong>ls -l 指定的文件名</strong>实现；<strong>查看用户相关信息</strong>可以使用<strong>id 指定的用户名</strong>实现</p><h5 id="基本命令-2"><a class="markdownIt-Anchor" href="#基本命令-2"></a> 基本命令</h5><p><strong>chown命令</strong>：修改文件所有者，但不改变组</p><p><strong>chgrp命令</strong>：修改文件所在组</p><p><strong>usermod命令</strong>：改变用户所在组</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chown 用户名 文件名</span></span><br><span class="line"><span class="built_in">chown</span> common info.txt <span class="comment"># info.txt所有者改为common用户</span></span><br><span class="line"><span class="built_in">ls</span> -l info.txt <span class="comment"># 查看info.txt的信息</span></span><br><span class="line"><span class="comment"># chgrp 组名 文件名</span></span><br><span class="line"><span class="built_in">chgrp</span> common info.txt <span class="comment"># info.txt所在组改为common组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># usermod -g 组名 用户名</span></span><br><span class="line">usermod -g ok common <span class="comment"># common用户所在组改为ok组</span></span><br><span class="line"><span class="built_in">id</span> common <span class="comment"># 查看common用户的信息</span></span><br></pre></td></tr></table></figure><h5 id="权限管理"><a class="markdownIt-Anchor" href="#权限管理"></a> 权限管理</h5><p>文件权限内容，通过ls -l 指定文件名查看</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一个示例</span></span><br><span class="line">-rw-r--r-- 1 root root 320 11月 18 17:49 info.txt</span><br></pre></td></tr></table></figure><p><strong>-rw-r–r--解读</strong>(下标从0开始)</p><ol><li>第0位确定文件类型(d, - , l , c , b)</li><li>第1-3位确定所有者（该文件的所有者）拥有该文件的权限</li><li>第4-6位确定所属组（同用户组的）拥有该文件的权限</li><li>第7-9位确定其他用户拥有该文件的权限</li></ol><p><strong>rwx权限说明</strong></p><ol><li><p>r表示可读read</p></li><li><p>w表示可写write</p></li><li><p>x表示可执行execute</p></li><li><p>对于文件来说</p><ul><li><p>r表示可以读取查看文件</p></li><li><p>w表示可以修改，但不能删除文件，删除一个文件必须拥有父文件夹的rwx权限(存在一个特例，在提前知道目录里的具体内容的情况下，手动指定对应的完整文件名进行删除)</p></li><li><p>x表示文件可执行</p></li></ul></li><li><p>对于目录来说</p><ul><li>r表示可以读取，查看目录内容</li><li>w表示可修改，<strong>目录内</strong>创建+删除+重命名目录</li><li>x表示可以进入该目录</li></ul></li></ol><h5 id="基本命令-3"><a class="markdownIt-Anchor" href="#基本命令-3"></a> 基本命令</h5><p><strong>chmod命令</strong>：修改文件或目录的权限</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数</span></span><br><span class="line"><span class="comment"># u:所有者 g:使用组 o:其他人 a:所有人</span></span><br><span class="line"><span class="comment"># +:添加权限 -:删除权限 =:设置权限</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> a=--- info.txt <span class="comment"># 取消所有人对info.txt的rwx权限</span></span><br><span class="line"><span class="built_in">chmod</span> u=rwx,g=rw-,o=r info.txt</span><br><span class="line"><span class="built_in">chmod</span> g+x,o-r info.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过rwx权限对应的数字设置权限</span></span><br><span class="line"><span class="comment"># r=4 w=2 x=1  rwx=4+2+1=7</span></span><br><span class="line"><span class="built_in">chmod</span> 611 info.txt</span><br></pre></td></tr></table></figure><h4 id="进程管理"><a class="markdownIt-Anchor" href="#进程管理"></a> 进程管理</h4><p>在linux中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个 ID 号</p><p>每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程</p><p>每个进程都可能以两种方式存在的：前台与后台</p><p>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，直到关机</p><h5 id="fg和bg命令进程前后台调度命令"><a class="markdownIt-Anchor" href="#fg和bg命令进程前后台调度命令"></a> fg和bg命令：进程前后台调度命令</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在前台结束一个进程</span></span><br><span class="line">Control+c</span><br><span class="line"><span class="comment"># 在前台暂停一个进程</span></span><br><span class="line">Control+z</span><br><span class="line"><span class="comment"># 查看后台执行进程的进程号</span></span><br><span class="line"><span class="built_in">jobs</span></span><br><span class="line"><span class="comment"># 运行命令时，在命令末尾加上&amp;可让命令在后台执行</span></span><br><span class="line">&amp;</span><br><span class="line"><span class="comment"># 将命令进程号码为N的命令进程放到前台执行</span></span><br><span class="line"><span class="built_in">fg</span> N</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">%N</span><br><span class="line"><span class="comment"># 将命令进程号码为N的命令进程放到后台执行</span></span><br><span class="line"><span class="built_in">bg</span> N</span><br></pre></td></tr></table></figure><h5 id="ps命令查看系统进程"><a class="markdownIt-Anchor" href="#ps命令查看系统进程"></a> ps命令查看系统进程</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ps [参数]</span></span><br><span class="line">ps -a <span class="comment"># 显示当前终端的所有进程信息</span></span><br><span class="line">ps -u <span class="comment"># 以用户的格式显示进程信息</span></span><br><span class="line">ps -x <span class="comment"># 显示后台进程运行的参数</span></span><br></pre></td></tr></table></figure><h5 id="kill命令终止进程"><a class="markdownIt-Anchor" href="#kill命令终止进程"></a> kill命令终止进程</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kill [参数] 进程号PID</span></span><br><span class="line"><span class="comment"># 参数(基本都使用9)</span></span><br><span class="line"><span class="comment"># 1:重新加载 9:强制停止 15:正常停止</span></span><br><span class="line"><span class="comment"># kill命令需要与ps命令配合使用</span></span><br><span class="line"><span class="built_in">kill</span> -9 9899 <span class="comment"># 9899是通过ps获取的PID号，强制停止9899的进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># killall命令能终止指定名称的所有进程，适合系统负载过大时使用</span></span><br><span class="line"><span class="comment"># killall -9 进程名称</span></span><br></pre></td></tr></table></figure><h5 id="pstree命令查看进程信息"><a class="markdownIt-Anchor" href="#pstree命令查看进程信息"></a> pstree命令查看进程信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pstree [参数]</span></span><br><span class="line"><span class="comment"># pstree相对ps可以更直观地查看进程信息</span></span><br><span class="line">pstree -p <span class="comment"># 额外显示进程的PID</span></span><br><span class="line">pstree -u <span class="comment"># 额外显示进程的所属用户</span></span><br></pre></td></tr></table></figure><h5 id="service命令操作进程后台服务"><a class="markdownIt-Anchor" href="#service命令操作进程后台服务"></a> service命令操作进程（后台服务）</h5><p>服务(service) 本质就是进程，但是是<strong>运行在后台的一个特殊进程</strong>。这个特殊进程通常都会监听某个端口等待其它程序的请求，比如(mysql , sshd 防火墙等)。因此这个进程又称为<strong>守护进程</strong>。</p><p><strong>telnet命令</strong>可以用于远程登录主机，也可以测试某个端口</p><p><strong>查看服务</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig --list | grep 8989 <span class="comment"># 该命令已被弃用</span></span><br></pre></td></tr></table></figure><p><strong>top命令持续监听运行状态</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># top [参数]</span></span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line"><span class="comment"># -d 秒数:指定每隔几秒更新，默认3秒</span></span><br><span class="line"><span class="comment"># -i:不显示任何闲置或僵死进程</span></span><br><span class="line"><span class="comment"># -p 进程PID:监控指定的PID的进程状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># top命令会进入一个交互页面，可以通过以下操作进行交互</span></span><br><span class="line"><span class="comment"># P:以CPU使用率排序，默认</span></span><br><span class="line"><span class="comment"># M:以内存的使用率排序</span></span><br><span class="line"><span class="comment"># N:以PID排序</span></span><br><span class="line"><span class="comment"># q:退出top交互页面</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;关于linux的通用操作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关于linux的通用操作&quot;&gt;&lt;/a&gt; 关于Linux的通用操作&lt;/h3&gt;
&lt;p&gt;基于Ubuntu22.04发行版的环境，本文整理了一些在Linux系统下基本通用的操作，使初学者能初步学会Linux系统的操作或使老用户重新回顾一下常用操作</summary>
    
    
    
    <category term="linux" scheme="https://s-chance.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://s-chance.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>一封数字签名邮件</title>
    <link href="https://s-chance.github.io/2022/11/10/digital-signature/"/>
    <id>https://s-chance.github.io/2022/11/10/digital-signature/</id>
    <published>2022-11-10T07:35:56.000Z</published>
    <updated>2022-11-10T17:46:25.981Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用outlook邮箱发送一封带有数字签名的邮件"><a class="markdownIt-Anchor" href="#使用outlook邮箱发送一封带有数字签名的邮件"></a> 使用outlook邮箱发送一封带有数字签名的邮件</h3><p>Digital Signature(数字签名)<strong>是</strong>Electronic Signature(电子签名)的一种特定类型, 是一种改进型的更加可信的电子方式签名。<span id="more"></span></p><p>数字签名是使用数字证书来验证签名者的身份, 并通过密码算法将签名者身份绑定到文档中来证明签名行为的不可否认, 已签名文档无需包含签名过程审计报告, 签名者的身份验证则由证书颁发机构(CA)或信任服务提供商(TSP)完成。</p><h4 id="1下载数字证书"><a class="markdownIt-Anchor" href="#1下载数字证书"></a> 1.下载数字证书</h4><p>数字证书需要先到网站上申请下载, 这里提供了一个申请90天免费证书的网站 <a href="https://www.cersign.com/smime-email-certificates.html">证签安全电子邮件证书 - CerSign</a></p><p>按照网站上提示完成申请以及邮箱验证即可。免费邮件证书大约几分钟后就会签发, 点击下载证书设置保护口令即可</p><h4 id="2在邮箱客户端中设置"><a class="markdownIt-Anchor" href="#2在邮箱客户端中设置"></a> 2.在邮箱客户端中设置</h4><p>outlook邮箱中导入数字证书: <strong>文件→选项→信任中心→电子邮件安全性</strong>, 然后设置加密以及数字签名。在默认设置中选择<strong>签名证书和加密证书</strong>(需要先找到之前下载好的证书文件双击运行并导入证书)</p><h4 id="3发送邮件进行测试"><a class="markdownIt-Anchor" href="#3发送邮件进行测试"></a> 3.发送邮件进行测试</h4><p>选择收件人(可以选择本地的另外一个邮箱)后输入邮件内容发送, 通过outlook客户端查看邮件内容会有一个额外的数字签名的图标, 点击该图标能够查看到发件人的数字证书信息。另外经过加密的邮件还会有一个🔒的图标, 在收件人拥有发件人的<strong>公钥</strong>时, 就能够进行解密获取正文内容。其他情况下, 则只有一个加密的smime.p7m文件(无法直接获取正文内容)</p><h4 id="4关于公钥和私钥的一些简单理解"><a class="markdownIt-Anchor" href="#4关于公钥和私钥的一些简单理解"></a> 4.关于公钥和私钥的一些简单理解</h4><p>公钥是一种<strong>非对称加密算法</strong>, 一般都是公布给对方用于加密解密</p><p>私钥是一种<strong>对称加密算法</strong>, 一般不对任何人公开, 同样可用于加密解密</p><p>公钥和私钥是<strong>成对出现</strong>的, 且<strong>唯一对应</strong></p><h5 id="思路1确保邮件只能由特定的收件人读取"><a class="markdownIt-Anchor" href="#思路1确保邮件只能由特定的收件人读取"></a> 思路1：确保邮件只能由特定的收件人读取</h5><p><strong>收件人的公钥</strong>提前就公布给所有发件人用于进行加密但不能进行解密, <strong>收件人的私钥</strong>则用于解密来自对应的公钥加密的邮件但不能进行加密(这也是一种非对称加密)</p><h5 id="思路2确认发件人的邮件未被篡改"><a class="markdownIt-Anchor" href="#思路2确认发件人的邮件未被篡改"></a> 思路2：确认发件人的邮件未被篡改</h5><p><strong>发件人的公钥</strong>提前就公布给所有收件人用于进行<strong>解密</strong>, <strong>发件人的私钥</strong>则用于<strong>加密</strong>邮件</p><p>具体流程：</p><p>发件人使用自己的私钥先对邮件加密<strong>一个hash值</strong>, 再用来自收件人的公钥对<strong>内容及hash值</strong>二次加密, 然后发送给收件人</p><p>收件人获取到了二次加密的邮件后, 先使用自己的私钥解密对应的公钥获取内容及<strong>加密的hash值</strong>, 再用来自收件人的公钥二次解密对应的私钥获取<strong>原始的hash值</strong>, 对内容进行hash计算, 如果计算的结果与之前hash值解密后的内容相同, 则说明内容未被篡改</p><p>需要注意的是：公钥和私钥的用法不是固定的, 在收件人和发件人两种情景下, 它们的用法恰恰是相反的</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;使用outlook邮箱发送一封带有数字签名的邮件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#使用outlook邮箱发送一封带有数字签名的邮件&quot;&gt;&lt;/a&gt; 使用outlook邮箱发送一封带有数字签名的邮件&lt;/h3&gt;
&lt;p&gt;Digital Signature(数字签名)&lt;strong&gt;是&lt;/strong&gt;Electronic Signature(电子签名)的一种特定类型, 是一种改进型的更加可信的电子方式签名。</summary>
    
    
    
    
    <category term="数字签名" scheme="https://s-chance.github.io/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    
    <category term="计算机网络" scheme="https://s-chance.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>后缀表达式</title>
    <link href="https://s-chance.github.io/2022/10/27/suffix-expression/"/>
    <id>https://s-chance.github.io/2022/10/27/suffix-expression/</id>
    <published>2022-10-26T16:28:58.000Z</published>
    <updated>2022-10-26T16:57:24.186Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基于stl的中缀转后缀实现"><a class="markdownIt-Anchor" href="#基于stl的中缀转后缀实现"></a> 基于STL的中缀转后缀实现</h3><h4 id="1定义分析"><a class="markdownIt-Anchor" href="#1定义分析"></a> 1.定义分析</h4><p><strong>首先明确后缀表达式的定义</strong></p><p>后缀表达式是一种不需要括号的表达式，这表示在将中缀表达式转化为后缀表达式时，如果中缀表达式中存在括号，<strong>不能将括号写入后缀表达式</strong><span id="more"></span></p><p>那么这里引出一个问题，后缀表达式中不存在括号那要如何表示运算的优先级？</p><p><strong>理解后缀表达式的运算过程</strong></p><p>以(1+5-4)*(6-9)为例，它的后缀表达式是15+4-69-*</p><p>先分析中缀表达式的运算过程，参与运算过程的操作符依次是+ - - *，正好是后缀表达式中从左往右的操作符顺序。而操作符所涉及到的2个操作数都是位于该操作符的前面。</p><p>那么回到上面的问题来看，中缀表达式中的<strong>括号的作用如何在后缀表达式中体现出来</strong>？</p><p>以1+2*3、(1+2)*3为例</p><p>1+2*3的后缀表达式为123*+</p><p>(1+2)*3的后缀表达式为12+3*</p><p>通过对比可以发现当表达式中存在括号时，<strong>括号中的操作符提前输出</strong>了，这表示在遇到括号的情况时，可以将括号内的操作符提前输出。</p><p><strong>此外，还需要考虑四则运算中，乘除的优先级高于加减</strong></p><p>以1+2*3为例，如果不加以判断直接转化后缀表达式，结果为12+3*，先运算+再运算*，这显然违背了基本的四则运算法则，实际上正确的结果应该是123*+</p><p>通过对比两个结果，可以发现优先级较低的操作符移到了后面，这表示在运算过程中可以<strong>先将优先级低的操作符存储起来</strong>，而将<strong>优先级高的运算符输出</strong>。</p><h4 id="2思路分析"><a class="markdownIt-Anchor" href="#2思路分析"></a> 2.思路分析</h4><p>采用STL模板实现中缀转后缀，这里使用的是stack。定义一个stack字符栈专门用于存储操作符</p><p><font color='red'>这里特别说明一下字符栈，字符栈栈底的操作符优先级最低，栈顶的操作符优先级最高</font></p><p><strong>1.输入中缀表达式的字符串依次获取字符串中的每个字符</strong></p><p><strong>2.对字符进行以下的判断和操作</strong></p><ul><li>数字字符，直接输出</li><li>左括号字符，直接存入stack</li><li>右括号字符，将stack中的操作符依次输出，直到遇到左括号时停止，将左括号出栈但不输出</li><li>加减乘除字符<ul><li>优先级高的字符直接存入stack</li><li>优先级低的字符，则比较当前字符栈栈顶操作符的优先级，遇到优先级更低的操作符或左括号字符时不出栈，并将当前操作符入栈</li></ul></li></ul><p><strong>3.当字符串遍历完成后，再依次输出字符栈内剩余的操作符</strong></p><h4 id="3实现过程分析"><a class="markdownIt-Anchor" href="#3实现过程分析"></a> 3.实现过程分析</h4><p>以(1+5-4)*(6-9)为例，字符串长度为13</p><p>获取到的字符：(</p><blockquote><p>表达式：</p><p>字符栈：(</p></blockquote><p>获取到的字符：1</p><blockquote><p>表达式：1</p><p>字符栈：(</p></blockquote><p>获取到的字符：+</p><blockquote><p>表达式：1</p><p>字符栈：(+</p></blockquote><p>获取到的字符：5</p><blockquote><p>表达式：15</p><p>字符栈：(+</p></blockquote><p>获取到的字符：-</p><blockquote><p>表达式：15+</p><p>字符栈：(-</p></blockquote><p>获取到的字符：4</p><blockquote><p>表达式：15+4</p><p>字符栈：(-</p></blockquote><p>获取到的字符：)</p><blockquote><p>表达式：15+4-</p><p>字符栈：</p></blockquote><p>获取到的字符：*</p><blockquote><p>表达式：15+4-</p><p>字符栈：*</p></blockquote><p>获取到的字符：(</p><blockquote><p>表达式：15+4-</p><p>字符栈：*(</p></blockquote><p>获取到的字符：6</p><blockquote><p>表达式：15+4-6</p><p>字符栈：*(</p></blockquote><p>获取到的字符：-</p><blockquote><p>表达式：15+4-6</p><p>字符栈：*(-</p></blockquote><p>获取到的字符：9</p><blockquote><p>表达式：15+4-69</p><p>字符栈：*(-</p></blockquote><p>获取到的字符：)</p><blockquote><p>表达式：15+4-69-</p><p>字符栈：*</p></blockquote><p>最后，依次输出字符栈中所有的操作符</p><blockquote><p>表达式：15+4-69-*</p></blockquote><h4 id="4源代码"><a class="markdownIt-Anchor" href="#4源代码"></a> 4.源代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">transfer</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">length</span>(); <span class="comment">//记录长度</span></span><br><span class="line">    list&lt;string&gt; listIn;  <span class="comment">//存储中缀表达式</span></span><br><span class="line">    list&lt;string&gt; listOut; <span class="comment">//存储后缀表达式</span></span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; symbol;   <span class="comment">//符号栈</span></span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; ans;      <span class="comment">//结果表达式</span></span><br><span class="line"></span><br><span class="line">    listIn.<span class="built_in">push_back</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//数字直接存入ans</span></span><br><span class="line">        <span class="comment">//运算符:</span></span><br><span class="line">        <span class="comment">//如果是&#x27;(&#x27;直接存入symbol</span></span><br><span class="line">        <span class="comment">//如果是&#x27;)&#x27;依次出栈symbol中的运算符并存入ans, 直到遇到&#x27;(&#x27;, &#x27;(&#x27;不存入ans</span></span><br><span class="line">        <span class="comment">//其他符号, 依次出栈symbol中的运算符并存入ans, 直到遇到优先级更低的运算符或&#x27;(&#x27;时, 将当前符号存入symbol</span></span><br><span class="line">        <span class="comment">//字符串遍历完成后, 依次出栈符号栈中剩余的运算符并存入ans</span></span><br><span class="line">        <span class="keyword">if</span> (listIn.<span class="built_in">back</span>()[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; listIn.<span class="built_in">back</span>()[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            ans.<span class="built_in">push</span>(listIn.<span class="built_in">back</span>()[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (listIn.<span class="built_in">back</span>()[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            symbol.<span class="built_in">push</span>(listIn.<span class="built_in">back</span>()[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (listIn.<span class="built_in">back</span>()[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (symbol.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push</span>(symbol.<span class="built_in">top</span>());</span><br><span class="line">                symbol.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            symbol.<span class="built_in">pop</span>(); <span class="comment">//将&#x27;(&#x27;出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里手动优先考虑乘除的优先级高于加减</span></span><br><span class="line">            <span class="keyword">if</span> (listIn.<span class="built_in">back</span>()[i] == <span class="string">&#x27;+&#x27;</span> || listIn.<span class="built_in">back</span>()[i] == <span class="string">&#x27;-&#x27;</span>) <span class="comment">//加减符号优先级最低</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (!symbol.<span class="built_in">empty</span>() &amp;&amp; symbol.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.<span class="built_in">push</span>(symbol.<span class="built_in">top</span>()); <span class="comment">//直接存入symbol中的运算符</span></span><br><span class="line">                    symbol.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                symbol.<span class="built_in">push</span>(listIn.<span class="built_in">back</span>()[i]); <span class="comment">//符号栈存入当前从listIn中获取的符号</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//乘除符号优先级高直接存入符号栈</span></span><br><span class="line">            &#123;</span><br><span class="line">                symbol.<span class="built_in">push</span>(listIn.<span class="built_in">back</span>()[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!symbol.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ans.<span class="built_in">push</span>(symbol.<span class="built_in">top</span>());</span><br><span class="line">        symbol.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将结果表达式的值存入listOut</span></span><br><span class="line">    <span class="comment">//先利用已经清空的symbol实现反转</span></span><br><span class="line">    <span class="keyword">while</span> (!ans.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        symbol.<span class="built_in">push</span>(ans.<span class="built_in">top</span>());</span><br><span class="line">        ans.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!symbol.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        res += symbol.<span class="built_in">top</span>();</span><br><span class="line">        symbol.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    listOut.<span class="built_in">push_back</span>(res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> listOut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        list&lt;string&gt; res = <span class="built_in">transfer</span>(s);</span><br><span class="line">        cout &lt;&lt; res.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;基于stl的中缀转后缀实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基于stl的中缀转后缀实现&quot;&gt;&lt;/a&gt; 基于STL的中缀转后缀实现&lt;/h3&gt;
&lt;h4 id=&quot;1定义分析&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1定义分析&quot;&gt;&lt;/a&gt; 1.定义分析&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;首先明确后缀表达式的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后缀表达式是一种不需要括号的表达式，这表示在将中缀表达式转化为后缀表达式时，如果中缀表达式中存在括号，&lt;strong&gt;不能将括号写入后缀表达式&lt;/strong&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="https://s-chance.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="cpp" scheme="https://s-chance.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础</title>
    <link href="https://s-chance.github.io/2022/09/14/Redis-Base/"/>
    <id>https://s-chance.github.io/2022/09/14/Redis-Base/</id>
    <published>2022-09-14T13:24:00.000Z</published>
    <updated>2022-09-15T12:19:13.484Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis基础"><a class="markdownIt-Anchor" href="#redis基础"></a> Redis基础</h3><h4 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h4><p>redis是一款高性能的NoSQL系列的非关系型数据库，全称Remote Dictionary Server远程字典服务器，是基于C语言开发的一个开源的高性能键值对数据库<span id="more"></span></p><p>NoSQL，全称Not-Only SQL，泛指非关系型的数据库，专门用于应对基于海量用户和海量数据下的数据处理问，不同于MySQL这类关系型数据库，NoSQL系列的非关系型数据库减少了磁盘读写次数、去除了数据间的关联性弥补关系型数据库在磁盘读写性能、复杂的数据关联性难于扩展的不足，专门用于应对大量用户<strong>高并发</strong>的问题</p><p>但非关系型数据库与关系型数据库在开发中一般会配合使用，非关系型数据库能实现大量数据的高效率访问，关系型数据库能实现复杂的数据查询以及保障安全性能的事务机制。单一的非关系数据库则无法实现复杂查询、安全保障，单一的关系型数据库也无法实现高效访问。因此联合使用非关系数据库和关系型数据库，相互弥补缺点，才能提供最好的用户体验。</p><h4 id="开始使用"><a class="markdownIt-Anchor" href="#开始使用"></a> 开始使用</h4><h5 id="下载安装"><a class="markdownIt-Anchor" href="#下载安装"></a> 下载安装</h5><p>redis<a href="https://redis.io">官网</a>以及<a href="http://www.redis.net.cn/">中文官网</a>主要提供的是Linux发行版下的redis版本，用于投入开发使用。本文章以windows系统下的redis版本做为学习使用，在GitHub上的<a href="https://github.com/microsoftarchive/redis/releases">Releases · microsoftarchive/redis</a>下载zip压缩包找到内部的release目录下含有redis主要的exe文件的压缩包后解压即可（这里是以2.8.9版本为例）</p><p>关于redis的图形化管理工具<a href="https://github.com/uglide/RedisDesktopManager">下载</a>(最新版本需要收费使用)</p><h5 id="重要文件"><a class="markdownIt-Anchor" href="#重要文件"></a> 重要文件</h5><p>redis压缩包解压后目录下的重要文件主要是以下文件：</p><ul><li>redis.windows.conf：配置文件</li><li>redis-cli.exe：redis客户端</li><li>redis-server.exe：redis服务器端</li></ul><h5 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h5><p><strong>请确保redis服务器端先启动，否则redis客户端在启动后将会无法连接至redis服务器端</strong></p><p>redis数据类型：string、hash、list、set、sorted_set/zset</p><p>注意：在未持久化redis中的数据时，关闭redis服务器端会导致在redis客户端存储的数据全部丢失，因此请在确保redis服务器端一直运行的前提下，测试下面的命令操作</p><ol><li><p>字符串类型：string</p><p>主要用于存储单个数据，是最简单也是最常用的数据存储类型</p><p>一个存储空间存储一个数据</p><p>存储的数据如果是整数类型，则可进行数字操作</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 存储命令</span></span><br><span class="line"><span class="comment"># 格式: set key value</span></span><br><span class="line"><span class="comment"># 存储一个键为name, 值为tom的字符串数据</span></span><br><span class="line"><span class="built_in">set</span> name tom</span><br><span class="line"><span class="comment"># 存储一个键为age, 值为26的字符串数据</span></span><br><span class="line"><span class="built_in">set</span> age 26</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取命令</span></span><br><span class="line"><span class="comment"># 格式: get key</span></span><br><span class="line"><span class="comment"># 获取name键对应的值</span></span><br><span class="line">get name</span><br><span class="line"><span class="comment"># 获取age键对应的值</span></span><br><span class="line">get age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除命令</span></span><br><span class="line"><span class="comment"># 格式: del key</span></span><br><span class="line"><span class="comment"># 删除name键对应的值</span></span><br><span class="line">del name</span><br><span class="line"><span class="comment">#删除age键对应的值</span></span><br><span class="line">del age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新获取值, 确认是否已经删除</span></span><br><span class="line">get name</span><br><span class="line">get age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数字操作命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自增处理incr key, 当key不存在时会自动创建, 默认自增值1</span></span><br><span class="line">incr num <span class="comment">#num键若不存在, 则自动创建</span></span><br><span class="line"><span class="comment"># 自增指定数据incrby key increment</span></span><br><span class="line">incrby num 20 <span class="comment">#指定num键的值自增20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自减处理decr key, 同样的若key不存在会自动创建, 默认自减值1</span></span><br><span class="line">decr num</span><br><span class="line"><span class="comment"># 自减指定数据decrby key decrement</span></span><br><span class="line">decrby num 30</span><br></pre></td></tr></table></figure></li><li><p>哈希类型：hash</p><p>主要用于分组存储有一定关联性的数据，比如java对象中的一系列成员变量数据</p><p>一个存储空间存储多个键值对数据</p><p>底层使用哈希表结构实现数据存储</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 存储命令</span></span><br><span class="line"><span class="comment"># 格式: hset key field value</span></span><br><span class="line"><span class="comment"># 在myhash键中存储一个name字段, 值为jerry的数据</span></span><br><span class="line">hset myhash name jerry</span><br><span class="line"><span class="comment"># 在myhash键中存储一个password字段, 值为pass的数据</span></span><br><span class="line">hset myhash password pass</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取命令</span></span><br><span class="line"><span class="comment"># 格式一: hget key field 获取指定的field所对应的值</span></span><br><span class="line"><span class="comment"># 获取myhash键中name字段的值</span></span><br><span class="line">hget myhash name</span><br><span class="line"><span class="comment"># 格式二: hgetall key 获取指定key下的所有field和value</span></span><br><span class="line"><span class="comment"># 获取myhash键下的所有键值对数据</span></span><br><span class="line">hgetall myhash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除命令</span></span><br><span class="line"><span class="comment"># 格式: hdel key field</span></span><br><span class="line"><span class="comment"># 删除myhash键下的name字段及其对应的值</span></span><br><span class="line">hdel myhash name</span><br></pre></td></tr></table></figure></li><li><p>列表类型：list</p><p>主要用于存储多个数据，并对数据先后进入存储空间的顺序进行区分</p><p>一个存储空间存储多个数据，且区分数据存储的先后顺序</p><p>底层使用双向链表结构实现数据存储</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 存储命令</span></span><br><span class="line"><span class="comment"># 格式一: lpush key value 在列表左边(头部)添加数据</span></span><br><span class="line"><span class="comment"># 格式二: rpush key value 在列表右边(尾部)添加数据</span></span><br><span class="line"><span class="comment"># 先任意添加一个测试的初始数据</span></span><br><span class="line">lpush mylist origin</span><br><span class="line"><span class="comment"># 在mylist键列表头部添加一个数据</span></span><br><span class="line">lpush mylist <span class="built_in">head</span></span><br><span class="line"><span class="comment"># 在mylist键列表尾部添加一个数据</span></span><br><span class="line">rpush mylist <span class="built_in">tail</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取命令</span></span><br><span class="line"><span class="comment"># lrange key start end 根据start和end的范围获取</span></span><br><span class="line"><span class="comment"># list数据下标从0开始, 若使用负数, 则表示从列表尾部倒数第几个数据</span></span><br><span class="line"><span class="comment"># 获取mylist下标0-2的数据</span></span><br><span class="line">lrange mylist 0 2</span><br><span class="line">lrange mylist 0 -1 <span class="comment">#-1表示列表倒数第一个数据, 即正数最后一个数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除命令</span></span><br><span class="line"><span class="comment"># 格式一: lpop key 删除列表最左边的数据</span></span><br><span class="line"><span class="comment"># 格式二: rpop key 删除列表最右边的数据</span></span><br><span class="line"><span class="comment"># 删除mylist键列表头部的一个数据</span></span><br><span class="line">lpop mylist</span><br><span class="line"><span class="comment"># 删除mylist键列表尾部的一个数据</span></span><br><span class="line">rpop mylist</span><br></pre></td></tr></table></figure></li><li><p>集合类型：set</p><p>主要用于存储大量的数据，提供更高的数据查询效率</p><p>一个存储空间能够存储大量数据，且具有高效的内部存储机制</p><p>底层与hash存储结构相同，并且不允许存储重复的值</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 存储命令</span></span><br><span class="line"><span class="comment"># 格式: sadd key value</span></span><br><span class="line"><span class="comment"># 在myset键存储一个值为a的数据</span></span><br><span class="line">sadd myset a <span class="comment">#第二次重复执行, 不会再新增数据</span></span><br><span class="line">sadd myset b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取命令</span></span><br><span class="line"><span class="comment"># 格式: smembers key</span></span><br><span class="line"><span class="comment"># 获取myset键中的所有数据</span></span><br><span class="line">smembers myset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除命令</span></span><br><span class="line"><span class="comment"># 格式: srem key value</span></span><br><span class="line"><span class="comment"># 删除myset键中值为a的数据</span></span><br><span class="line">srem myset a</span><br></pre></td></tr></table></figure></li><li><p>有序集合类型：sorted_set</p><p>不允许存储重复数据，并且存储的数据是有顺序的，每个数据会关联一个double类型的分数作为排序的依据</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 存储命令</span></span><br><span class="line"><span class="comment"># 格式: zadd key score value</span></span><br><span class="line"><span class="comment"># 在mysort键存储一个分数为3, 值为pascal的数据</span></span><br><span class="line">zadd mysort 3 pascal</span><br><span class="line"><span class="comment"># 在mysort键存储一个分数为1, 值为visual的数据</span></span><br><span class="line">zadd mysort 1 visual</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取命令</span></span><br><span class="line"><span class="comment"># 格式: zrange key start end 范围获取, 可参考list列表类型的获取命令来理解</span></span><br><span class="line"><span class="comment"># 获取mysort键下的所有数据</span></span><br><span class="line">zrange mysort 0 -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除命令</span></span><br><span class="line"><span class="comment"># 格式: zrem key value</span></span><br><span class="line"><span class="comment"># 删除mysort键下值为visual的数据</span></span><br><span class="line">zrem mysort visual</span><br></pre></td></tr></table></figure><p><strong>通用命令操作</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询所有的键</span></span><br><span class="line">keys *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定键对应的数据类型</span></span><br><span class="line"><span class="comment"># 获取mysort键对应的数据类型</span></span><br><span class="line"><span class="built_in">type</span> mysort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的键及其数据</span></span><br><span class="line"><span class="comment"># 删除myhash键下的所有键值对数据</span></span><br><span class="line">del myhash</span><br></pre></td></tr></table></figure></li></ol><h4 id="持久化"><a class="markdownIt-Anchor" href="#持久化"></a> 持久化</h4><h5 id="rdb方式"><a class="markdownIt-Anchor" href="#rdb方式"></a> RDB方式</h5><p>redis作为一个内存数据库，当redis服务器重启后，数据就会丢失。为了能够在redis服务器重启后能够快速恢复缓存的数据，就需要使用持久化技术</p><ul><li><p>redis持久化机制：每隔一定时间检测key的变化情况，根据配置决定是否进行持久化。持久化的数据就存储在dump.rdb文件中。</p></li><li><p>持久化配置过程：打开redis.windows.conf文件，找到<code># Save the DB on disk</code>所在的位置，在#注释的下方可以看到<code>save 900 1</code>的字样，这些原始的字样就是默认的持久化机制。通过修改这些字样就能设置持久化机制。</p></li><li><p>关于持久化配置的简单说明：</p><p><code>save 900 1</code></p><h6 id="after-900-sec-15-min-if-at-least-1-key-changed"><a class="markdownIt-Anchor" href="#after-900-sec-15-min-if-at-least-1-key-changed"></a> after 900 sec (15 min) if at least 1 key changed</h6><h6 id="经过15分钟如果至少有一个key发生变化那么就进行一次持久化"><a class="markdownIt-Anchor" href="#经过15分钟如果至少有一个key发生变化那么就进行一次持久化"></a> 经过15分钟，如果至少有一个key发生变化，那么就进行一次持久化</h6><p><code>save 300 10</code></p><h6 id="after-300-sec-5-min-if-at-least-10-keys-changed"><a class="markdownIt-Anchor" href="#after-300-sec-5-min-if-at-least-10-keys-changed"></a> after 300 sec (5 min) if at least 10 keys changed</h6><h6 id="经过5分钟如果至少有10个key发生变化那么就进行一次持久化"><a class="markdownIt-Anchor" href="#经过5分钟如果至少有10个key发生变化那么就进行一次持久化"></a> 经过5分钟，如果至少有10个key发生变化，那么就进行一次持久化</h6><p><code>save 60 10000</code></p><h6 id="after-60-sec-1-min-if-at-least-10000-keys-changed"><a class="markdownIt-Anchor" href="#after-60-sec-1-min-if-at-least-10000-keys-changed"></a> after 60 sec (1 min) if at least 10000 keys changed</h6><h6 id="经过1分钟如果至少有10000个key发生变化那么就进行一次持久化"><a class="markdownIt-Anchor" href="#经过1分钟如果至少有10000个key发生变化那么就进行一次持久化"></a> 经过1分钟，如果至少有10000个key发生变化，那么就进行一次持久化</h6></li><li><p>持久化机制测试：</p><blockquote><p>配置之前请先确保关闭redis服务器，以防配置无法生效</p><ol><li><p>修改配置文件在指定位置添加字样<code>save 10 5</code>，10秒后有5个key发生变化，则持久化</p></li><li><p>在redis根目录下打开cmd，通过<code>redis-server.exe redis.windows.conf</code>命令启动redis服务器，否则持久化机制还是使用默认方式，如果觉得麻烦可以看<a href="#bc">补充</a></p></li><li><p>打开redis客户端</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试数据, 修改5个key</span></span><br><span class="line"><span class="built_in">set</span> name 1</span><br><span class="line"><span class="built_in">set</span> name 2</span><br><span class="line"><span class="built_in">set</span> name 3</span><br><span class="line"><span class="built_in">set</span> name 4</span><br><span class="line"><span class="built_in">set</span> name 5</span><br><span class="line"><span class="comment"># 之后根据save 10 5的配置, 会在redis的根目录下生成dump.rdb文件</span></span><br></pre></td></tr></table></figure></li><li><p>关闭redis服务器和客户端，再重启服务器和客户端重新查询数据，测试数据是否实现持久化</p></li></ol></blockquote></li></ul><h5 id="aof方式"><a class="markdownIt-Anchor" href="#aof方式"></a> AOF方式</h5><p>AOF是一种日志记录，用于记录redis每一条命令执行的历史操作，可在每一次命令操作后持久化数据</p><p>AOF配置过程：打开redis.windows.conf文件，找到<code>appendonly no</code>字样修改<code>no</code>为<code>yes</code>开启AOF支持。再找到<code>#appendfsync</code>开头的字样，去掉前面的<code>#</code>启动持久化机制</p><p>AOF持久化机制简单说明：<code>appendfsync always</code>每一次操作进行一次持久化，<code>appendfsync everysec</code>每隔一秒进行一次持久化，<code>appendfsync no</code>不进行持久化</p><p>注意：在redis根目录下用cmd执行<code>redis-server.exe redis.windows.conf</code>命令启动服务器，否则配置可能不生效</p><h4 id="span-idbc补充span"><a class="markdownIt-Anchor" href="#span-idbc补充span"></a> <span id='bc'>补充</span></h4><h5 id="关于redis-serverexe启动时默认加载配置文件"><a class="markdownIt-Anchor" href="#关于redis-serverexe启动时默认加载配置文件"></a> 关于redis-server.exe启动时默认加载配置文件</h5><p>右击文件<strong>创建快捷方式</strong>，右击快捷方式<strong>设置属性</strong>，在<strong>目标</strong>的后面<strong>添加空格和配置文件名</strong>，配置完后的示例<code>D:\redis-2.8.9\redis-server.exe redis.windows.conf</code>，前面的exe文件路径根据本地实际情况配置，默认是已有的，然后<strong>点击应用</strong>。之后使用该快捷方式启动服务器就能自动加载配置文件</p><h5 id="关于redisqfork_8412dat文件"><a class="markdownIt-Anchor" href="#关于redisqfork_8412dat文件"></a> 关于RedisQFork_8412.dat文件</h5><p>这是redis的内存映射文件。当redis启动时会自动创建，redis关闭后会自动消失。不过这个文件会随数据量的增长而增长，没有限制能够增长到几十G的大小，如果硬盘空间无法容纳这几十G的大小，就无法启动redis服务。可以通过修改配置文件中的<code>maxheap</code>字样后的参数实现（单位B），如设置最大为4G，则填写4294967296（4GB换算成B）</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;redis基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redis基础&quot;&gt;&lt;/a&gt; Redis基础&lt;/h3&gt;
&lt;h4 id=&quot;概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概念&quot;&gt;&lt;/a&gt; 概念&lt;/h4&gt;
&lt;p&gt;redis是一款高性能的NoSQL系列的非关系型数据库，全称Remote Dictionary Server远程字典服务器，是基于C语言开发的一个开源的高性能键值对数据库</summary>
    
    
    
    
    <category term="Redis" scheme="https://s-chance.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Git分支重命名</title>
    <link href="https://s-chance.github.io/2022/09/08/Git-Branch-Rename/"/>
    <id>https://s-chance.github.io/2022/09/08/Git-Branch-Rename/</id>
    <published>2022-09-08T04:20:19.000Z</published>
    <updated>2022-09-20T17:43:08.119Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git重命名分支"><a class="markdownIt-Anchor" href="#git重命名分支"></a> Git重命名分支</h3><p>在开发过程中，有时需要对分支进行重命名。重命名分支需要考虑到分支是否已经推送到远端的情况<span id="more"></span></p><h4 id="git重命名本地分支还未推送到远端"><a class="markdownIt-Anchor" href="#git重命名本地分支还未推送到远端"></a> Git重命名本地分支（还未推送到远端）</h4><ul><li><p>在需要重命名的分支处</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -m <span class="string">&#x27;新的分支名&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>不在需要重命名的分支处</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -m <span class="string">&#x27;需要重命名的分支名&#x27;</span> <span class="string">&#x27;新的分支名&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="git重命名远端分支已经推送到远端"><a class="markdownIt-Anchor" href="#git重命名远端分支已经推送到远端"></a> Git重命名远端分支（已经推送到远端）</h4><p><strong>假设已经处于需要重命名的分支上，参考上面的操作，并且在通过命令修改分支名之前没有手动去远端进行过修改，即修改之前本地分支名与远端分支名仍保持一致</strong></p><ul><li><p>重命名本地分支</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -m 新的分支名</span><br></pre></td></tr></table></figure></li><li><p>删除远程分支</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --delete origin 要删除的分支名</span><br></pre></td></tr></table></figure></li><li><p>上传新命名的分支</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin 新的分支名</span><br></pre></td></tr></table></figure></li><li><p>关联修改后的本地分支与远端分支</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to origin/新的分支名</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;git重命名分支&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#git重命名分支&quot;&gt;&lt;/a&gt; Git重命名分支&lt;/h3&gt;
&lt;p&gt;在开发过程中，有时需要对分支进行重命名。重命名分支需要考虑到分支是否已经推送到远端的情况</summary>
    
    
    
    
    <category term="Git" scheme="https://s-chance.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>关于yarn禁止在此系统上运行脚本</title>
    <link href="https://s-chance.github.io/2022/09/05/yarn-problem/"/>
    <id>https://s-chance.github.io/2022/09/05/yarn-problem/</id>
    <published>2022-09-05T13:36:27.000Z</published>
    <updated>2022-09-05T14:02:21.336Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nodejs中使用yarn安装依赖失败"><a class="markdownIt-Anchor" href="#nodejs中使用yarn安装依赖失败"></a> nodejs中使用yarn安装依赖失败</h3><h4 id="错误原因"><a class="markdownIt-Anchor" href="#错误原因"></a> 错误原因</h4><p>windows默认执行策略禁止脚本<span id="more"></span></p><h4 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h4><ol><li>在电脑的开始菜单中，搜索<strong>PowerShell</strong>，并<strong>以管理员身份运行</strong></li><li>在窗口输入命令<code>get-ExecutionPolicy</code>查看权限，如果返回值是<strong>Restricted</strong>，则表示当前是禁用状态</li><li>在窗口输入命令<code>set-ExecutionPolicy</code>设置权限</li><li>为<strong>ExecutionPolicy</strong>参数提供值<strong>RemoteSigned</strong>，后面输入<strong>A</strong>之后再回车（默认为否），开启所有脚本权限</li><li>重新测试yarn命令</li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;nodejs中使用yarn安装依赖失败&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#nodejs中使用yarn安装依赖失败&quot;&gt;&lt;/a&gt; nodejs中使用yarn安装依赖失败&lt;/h3&gt;
&lt;h4 id=&quot;错误原因&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#错误原因&quot;&gt;&lt;/a&gt; 错误原因&lt;/h4&gt;
&lt;p&gt;windows默认执行策略禁止脚本</summary>
    
    
    
    
    <category term="nodejs" scheme="https://s-chance.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>RSS订阅的使用以及优势</title>
    <link href="https://s-chance.github.io/2022/09/04/RSS/"/>
    <id>https://s-chance.github.io/2022/09/04/RSS/</id>
    <published>2022-09-04T11:38:08.000Z</published>
    <updated>2022-09-05T13:37:09.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="rssreally-simple-syndication简易信息聚合"><a class="markdownIt-Anchor" href="#rssreally-simple-syndication简易信息聚合"></a> RSS(Really Simple Syndication)简易信息聚合</h3><h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4><p>RSS本身是一种消息来源格式规范，主要用于聚合数据时效性很强的网站，例如个人博客文章、新闻，以及很多社交网站。RSS文件包含全文或者部分内容。<span id="more"></span></p><h4 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h4><ul><li>能够自主选择您感兴趣的内容和信息进行浏览</li><li>通过RSS，您可以把需要的信息从网站中筛选出来，排除掉那些不需要的信息，例如广告</li><li>通过RSS，您可以创建自己的新闻频道，并发布到互联网上供其他人以RSS订阅您的新闻频道</li><li>使用RSS的客户端，能够在不打开网站内容页面的情况下阅读支持RSS输出的网站内容</li></ul><h4 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h4><p>windows平台这里推荐微软商店的Fluent Reader<a href="https://apps.microsoft.com/store/detail/9P71FC94LRH8">官网链接</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;rssreally-simple-syndication简易信息聚合&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#rssreally-simple-syndication简易信息聚合&quot;&gt;&lt;/a&gt; RSS(Really Simple Syndication)简易信息聚合&lt;/h3&gt;
&lt;h4 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h4&gt;
&lt;p&gt;RSS本身是一种消息来源格式规范，主要用于聚合数据时效性很强的网站，例如个人博客文章、新闻，以及很多社交网站。RSS文件包含全文或者部分内容。</summary>
    
    
    
    
    <category term="RSS" scheme="https://s-chance.github.io/tags/RSS/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown进阶:表情、图标</title>
    <link href="https://s-chance.github.io/2022/09/04/MarkDownPro-face%E3%80%81icon/"/>
    <id>https://s-chance.github.io/2022/09/04/MarkDownPro-face%E3%80%81icon/</id>
    <published>2022-09-04T06:22:31.000Z</published>
    <updated>2022-09-05T13:38:01.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="markdown-emoji"><a class="markdownIt-Anchor" href="#markdown-emoji"></a> markdown-emoji</h1><p>Markdown语法支持添加 <code>emoji</code> 表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情<span id="more"></span></p><hr /><ul><li><a href="#%E4%BA%BA%E7%89%A9">人物</a></li><li><a href="#%E8%87%AA%E7%84%B6">自然</a></li><li><a href="#%E4%BA%8B%E7%89%A9">事物</a></li><li><a href="#%E5%9C%B0%E7%82%B9">地点</a></li><li><a href="#%E7%AC%A6%E5%8F%B7">符号</a></li></ul><h2 id="人物"><a class="markdownIt-Anchor" href="#人物"></a> 人物</h2><table><thead><tr><th style="text-align:left">:bowtie: <code>:bowtie:</code></th><th style="text-align:left">😄 <code>:smile:</code></th><th style="text-align:left">😆 <code>:laughing:</code></th></tr></thead><tbody><tr><td style="text-align:left">😊 <code>:blush:</code></td><td style="text-align:left">😃 <code>:smiley:</code></td><td style="text-align:left">☺️ <code>:relaxed:</code></td></tr><tr><td style="text-align:left">😏 <code>:smirk:</code></td><td style="text-align:left">😍 <code>:heart_eyes:</code></td><td style="text-align:left">😘 <code>:kissing_heart:</code></td></tr><tr><td style="text-align:left">😚 <code>:kissing_closed_eyes:</code></td><td style="text-align:left">😳 <code>:flushed:</code></td><td style="text-align:left">😌 <code>:relieved:</code></td></tr><tr><td style="text-align:left">😆 <code>:satisfied:</code></td><td style="text-align:left">😁 <code>:grin:</code></td><td style="text-align:left">😉 <code>:wink:</code></td></tr><tr><td style="text-align:left">😜 <code>:stuck_out_tongue_winking_eye:</code></td><td style="text-align:left">😝 <code>:stuck_out_tongue_closed_eyes:</code></td><td style="text-align:left">😀 <code>:grinning:</code></td></tr><tr><td style="text-align:left">😗 <code>:kissing:</code></td><td style="text-align:left">😙 <code>:kissing_smiling_eyes:</code></td><td style="text-align:left">😛 <code>:stuck_out_tongue:</code></td></tr><tr><td style="text-align:left">😴 <code>:sleeping:</code></td><td style="text-align:left">😟 <code>:worried:</code></td><td style="text-align:left">😦 <code>:frowning:</code></td></tr><tr><td style="text-align:left">😧 <code>:anguished:</code></td><td style="text-align:left">😮 <code>:open_mouth:</code></td><td style="text-align:left">😬 <code>:grimacing:</code></td></tr><tr><td style="text-align:left">😕 <code>:confused:</code></td><td style="text-align:left">😯 <code>:hushed:</code></td><td style="text-align:left">😑 <code>:expressionless:</code></td></tr><tr><td style="text-align:left">😒 <code>:unamused:</code></td><td style="text-align:left">😅 <code>:sweat_smile:</code></td><td style="text-align:left">😓 <code>:sweat:</code></td></tr><tr><td style="text-align:left">😥 <code>:disappointed_relieved:</code></td><td style="text-align:left">😩 <code>:weary:</code></td><td style="text-align:left">😔 <code>:pensive:</code></td></tr><tr><td style="text-align:left">😞 <code>:disappointed:</code></td><td style="text-align:left">😖 <code>:confounded:</code></td><td style="text-align:left">😨 <code>:fearful:</code></td></tr><tr><td style="text-align:left">😰 <code>:cold_sweat:</code></td><td style="text-align:left">😣 <code>:persevere:</code></td><td style="text-align:left">😢 <code>:cry:</code></td></tr><tr><td style="text-align:left">😭 <code>:sob:</code></td><td style="text-align:left">😂 <code>:joy:</code></td><td style="text-align:left">😲 <code>:astonished:</code></td></tr><tr><td style="text-align:left">😱 <code>:scream:</code></td><td style="text-align:left">:neckbeard: <code>:neckbeard:</code></td><td style="text-align:left">😫 <code>:tired_face:</code></td></tr><tr><td style="text-align:left">😠 <code>:angry:</code></td><td style="text-align:left">😡 <code>:rage:</code></td><td style="text-align:left">😤 <code>:triumph:</code></td></tr><tr><td style="text-align:left">😪 <code>:sleepy:</code></td><td style="text-align:left">😋 <code>:yum:</code></td><td style="text-align:left">😷 <code>:mask:</code></td></tr><tr><td style="text-align:left">😎 <code>:sunglasses:</code></td><td style="text-align:left">😵 <code>:dizzy_face:</code></td><td style="text-align:left">👿 <code>:imp:</code></td></tr><tr><td style="text-align:left">😈 <code>:smiling_imp:</code></td><td style="text-align:left">😐 <code>:neutral_face:</code></td><td style="text-align:left">😶 <code>:no_mouth:</code></td></tr><tr><td style="text-align:left">😇 <code>:innocent:</code></td><td style="text-align:left">👽 <code>:alien:</code></td><td style="text-align:left">💛 <code>:yellow_heart:</code></td></tr><tr><td style="text-align:left">💙 <code>:blue_heart:</code></td><td style="text-align:left">💜 <code>:purple_heart:</code></td><td style="text-align:left">❤️ <code>:heart:</code></td></tr><tr><td style="text-align:left">💚 <code>:green_heart:</code></td><td style="text-align:left">💔 <code>:broken_heart:</code></td><td style="text-align:left">💓 <code>:heartbeat:</code></td></tr><tr><td style="text-align:left">💗 <code>:heartpulse:</code></td><td style="text-align:left">💕 <code>:two_hearts:</code></td><td style="text-align:left">💞 <code>:revolving_hearts:</code></td></tr><tr><td style="text-align:left">💘 <code>:cupid:</code></td><td style="text-align:left">💖 <code>:sparkling_heart:</code></td><td style="text-align:left">✨ <code>:sparkles:</code></td></tr><tr><td style="text-align:left">⭐️ <code>:star:</code></td><td style="text-align:left">🌟 <code>:star2:</code></td><td style="text-align:left">💫 <code>:dizzy:</code></td></tr><tr><td style="text-align:left">💥 <code>:boom:</code></td><td style="text-align:left">💥 <code>:collision:</code></td><td style="text-align:left">💢 <code>:anger:</code></td></tr><tr><td style="text-align:left">❗️ <code>:exclamation:</code></td><td style="text-align:left">❓ <code>:question:</code></td><td style="text-align:left">❕ <code>:grey_exclamation:</code></td></tr><tr><td style="text-align:left">❔ <code>:grey_question:</code></td><td style="text-align:left">💤 <code>:zzz:</code></td><td style="text-align:left">💨 <code>:dash:</code></td></tr><tr><td style="text-align:left">💦 <code>:sweat_drops:</code></td><td style="text-align:left">🎶 <code>:notes:</code></td><td style="text-align:left">🎵 <code>:musical_note:</code></td></tr><tr><td style="text-align:left">🔥 <code>:fire:</code></td><td style="text-align:left">💩 <code>:hankey:</code></td><td style="text-align:left">💩 <code>:poop:</code></td></tr><tr><td style="text-align:left">💩 <code>:shit:</code></td><td style="text-align:left">👍 <code>:+1:</code></td><td style="text-align:left">👍 <code>:thumbsup:</code></td></tr><tr><td style="text-align:left">👎 <code>:-1:</code></td><td style="text-align:left">👎 <code>:thumbsdown:</code></td><td style="text-align:left">👌 <code>:ok_hand:</code></td></tr><tr><td style="text-align:left">👊 <code>:punch:</code></td><td style="text-align:left">👊 <code>:facepunch:</code></td><td style="text-align:left">✊ <code>:fist:</code></td></tr><tr><td style="text-align:left">✌️ <code>:v:</code></td><td style="text-align:left">👋 <code>:wave:</code></td><td style="text-align:left">✋ <code>:hand:</code></td></tr><tr><td style="text-align:left">✋ <code>:raised_hand:</code></td><td style="text-align:left">👐 <code>:open_hands:</code></td><td style="text-align:left">☝️ <code>:point_up:</code></td></tr><tr><td style="text-align:left">👇 <code>:point_down:</code></td><td style="text-align:left">👈 <code>:point_left:</code></td><td style="text-align:left">👉 <code>:point_right:</code></td></tr><tr><td style="text-align:left">🙌 <code>:raised_hands:</code></td><td style="text-align:left">🙏 <code>:pray:</code></td><td style="text-align:left">👆 <code>:point_up_2:</code></td></tr><tr><td style="text-align:left">👏 <code>:clap:</code></td><td style="text-align:left">💪 <code>:muscle:</code></td><td style="text-align:left">🤘 <code>:metal:</code></td></tr><tr><td style="text-align:left">🖕 <code>:fu:</code></td><td style="text-align:left">🚶 <code>:walking:</code></td><td style="text-align:left">🏃 <code>:runner:</code></td></tr><tr><td style="text-align:left">🏃 <code>:running:</code></td><td style="text-align:left">👫 <code>:couple:</code></td><td style="text-align:left">👪 <code>:family:</code></td></tr><tr><td style="text-align:left">👬 <code>:two_men_holding_hands:</code></td><td style="text-align:left">👭 <code>:two_women_holding_hands:</code></td><td style="text-align:left">💃 <code>:dancer:</code></td></tr><tr><td style="text-align:left">👯 <code>:dancers:</code></td><td style="text-align:left">🙆 <code>:ok_woman:</code></td><td style="text-align:left">🙅 <code>:no_good:</code></td></tr><tr><td style="text-align:left">💁 <code>:information_desk_person:</code></td><td style="text-align:left">🙋 <code>:raising_hand:</code></td><td style="text-align:left">👰 <code>:bride_with_veil:</code></td></tr><tr><td style="text-align:left">🙎 <code>:person_with_pouting_face:</code></td><td style="text-align:left">🙍 <code>:person_frowning:</code></td><td style="text-align:left">🙇 <code>:bow:</code></td></tr><tr><td style="text-align:left">:couplekiss: <code>:couplekiss:</code></td><td style="text-align:left">💑 <code>:couple_with_heart:</code></td><td style="text-align:left">💆 <code>:massage:</code></td></tr><tr><td style="text-align:left">💇 <code>:haircut:</code></td><td style="text-align:left">💅 <code>:nail_care:</code></td><td style="text-align:left">👦 <code>:boy:</code></td></tr><tr><td style="text-align:left">👧 <code>:girl:</code></td><td style="text-align:left">👩 <code>:woman:</code></td><td style="text-align:left">👨 <code>:man:</code></td></tr><tr><td style="text-align:left">👶 <code>:baby:</code></td><td style="text-align:left">👵 <code>:older_woman:</code></td><td style="text-align:left">👴 <code>:older_man:</code></td></tr><tr><td style="text-align:left">👱 <code>:person_with_blond_hair:</code></td><td style="text-align:left">👲 <code>:man_with_gua_pi_mao:</code></td><td style="text-align:left">👳 <code>:man_with_turban:</code></td></tr><tr><td style="text-align:left">👷 <code>:construction_worker:</code></td><td style="text-align:left">👮 <code>:cop:</code></td><td style="text-align:left">👼 <code>:angel:</code></td></tr><tr><td style="text-align:left">👸 <code>:princess:</code></td><td style="text-align:left">😺 <code>:smiley_cat:</code></td><td style="text-align:left">😸 <code>:smile_cat:</code></td></tr><tr><td style="text-align:left">😻 <code>:heart_eyes_cat:</code></td><td style="text-align:left">😽 <code>:kissing_cat:</code></td><td style="text-align:left">😼 <code>:smirk_cat:</code></td></tr><tr><td style="text-align:left">🙀 <code>:scream_cat:</code></td><td style="text-align:left">😿 <code>:crying_cat_face:</code></td><td style="text-align:left">😹 <code>:joy_cat:</code></td></tr><tr><td style="text-align:left">😾 <code>:pouting_cat:</code></td><td style="text-align:left">👹 <code>:japanese_ogre:</code></td><td style="text-align:left">👺 <code>:japanese_goblin:</code></td></tr><tr><td style="text-align:left">🙈 <code>:see_no_evil:</code></td><td style="text-align:left">🙉 <code>:hear_no_evil:</code></td><td style="text-align:left">🙊 <code>:speak_no_evil:</code></td></tr><tr><td style="text-align:left">💂 <code>:guardsman:</code></td><td style="text-align:left">💀 <code>:skull:</code></td><td style="text-align:left">🐾 <code>:feet:</code></td></tr><tr><td style="text-align:left">👄 <code>:lips:</code></td><td style="text-align:left">💋 <code>:kiss:</code></td><td style="text-align:left">💧 <code>:droplet:</code></td></tr><tr><td style="text-align:left">👂 <code>:ear:</code></td><td style="text-align:left">👀 <code>:eyes:</code></td><td style="text-align:left">👃 <code>:nose:</code></td></tr><tr><td style="text-align:left">👅 <code>:tongue:</code></td><td style="text-align:left">💌 <code>:love_letter:</code></td><td style="text-align:left">👤 <code>:bust_in_silhouette:</code></td></tr><tr><td style="text-align:left">👥 <code>:busts_in_silhouette:</code></td><td style="text-align:left">💬 <code>:speech_balloon:</code></td><td style="text-align:left">💭 <code>:thought_balloon:</code></td></tr><tr><td style="text-align:left">:feelsgood: <code>:feelsgood:</code></td><td style="text-align:left">:finnadie: <code>:finnadie:</code></td><td style="text-align:left">:goberserk: <code>:goberserk:</code></td></tr><tr><td style="text-align:left">:godmode: <code>:godmode:</code></td><td style="text-align:left">:hurtrealbad: <code>:hurtrealbad:</code></td><td style="text-align:left">:rage1: <code>:rage1:</code></td></tr><tr><td style="text-align:left">:rage2: <code>:rage2:</code></td><td style="text-align:left">:rage3: <code>:rage3:</code></td><td style="text-align:left">:rage4: <code>:rage4:</code></td></tr><tr><td style="text-align:left">:suspect: <code>:suspect:</code></td><td style="text-align:left">:trollface: <code>:trollface:</code></td><td style="text-align:left"></td></tr></tbody></table><h2 id="自然"><a class="markdownIt-Anchor" href="#自然"></a> 自然</h2><table><thead><tr><th style="text-align:left">☀️ <code>:sunny:</code></th><th style="text-align:left">☔️ <code>:umbrella:</code></th><th style="text-align:left">☁️ <code>:cloud:</code></th></tr></thead><tbody><tr><td style="text-align:left">❄️ <code>:snowflake:</code></td><td style="text-align:left">⛄️ <code>:snowman:</code></td><td style="text-align:left">⚡️ <code>:zap:</code></td></tr><tr><td style="text-align:left">🌀 <code>:cyclone:</code></td><td style="text-align:left">🌁 <code>:foggy:</code></td><td style="text-align:left">🌊 <code>:ocean:</code></td></tr><tr><td style="text-align:left">🐱 <code>:cat:</code></td><td style="text-align:left">🐶 <code>:dog:</code></td><td style="text-align:left">🐭 <code>:mouse:</code></td></tr><tr><td style="text-align:left">🐹 <code>:hamster:</code></td><td style="text-align:left">🐰 <code>:rabbit:</code></td><td style="text-align:left">🐺 <code>:wolf:</code></td></tr><tr><td style="text-align:left">🐸 <code>:frog:</code></td><td style="text-align:left">🐯 <code>:tiger:</code></td><td style="text-align:left">🐨 <code>:koala:</code></td></tr><tr><td style="text-align:left">🐻 <code>:bear:</code></td><td style="text-align:left">🐷 <code>:pig:</code></td><td style="text-align:left">🐽 <code>:pig_nose:</code></td></tr><tr><td style="text-align:left">🐮 <code>:cow:</code></td><td style="text-align:left">🐗 <code>:boar:</code></td><td style="text-align:left">🐵 <code>:monkey_face:</code></td></tr><tr><td style="text-align:left">🐒 <code>:monkey:</code></td><td style="text-align:left">🐴 <code>:horse:</code></td><td style="text-align:left">🐎 <code>:racehorse:</code></td></tr><tr><td style="text-align:left">🐫 <code>:camel:</code></td><td style="text-align:left">🐑 <code>:sheep:</code></td><td style="text-align:left">🐘 <code>:elephant:</code></td></tr><tr><td style="text-align:left">🐼 <code>:panda_face:</code></td><td style="text-align:left">🐍 <code>:snake:</code></td><td style="text-align:left">🐦 <code>:bird:</code></td></tr><tr><td style="text-align:left">🐤 <code>:baby_chick:</code></td><td style="text-align:left">🐥 <code>:hatched_chick:</code></td><td style="text-align:left">🐣 <code>:hatching_chick:</code></td></tr><tr><td style="text-align:left">🐔 <code>:chicken:</code></td><td style="text-align:left">🐧 <code>:penguin:</code></td><td style="text-align:left">🐢 <code>:turtle:</code></td></tr><tr><td style="text-align:left">🐛 <code>:bug:</code></td><td style="text-align:left">🐝 <code>:honeybee:</code></td><td style="text-align:left">🐜 <code>:ant:</code></td></tr><tr><td style="text-align:left">🐞 <code>:beetle:</code></td><td style="text-align:left">🐌 <code>:snail:</code></td><td style="text-align:left">🐙 <code>:octopus:</code></td></tr><tr><td style="text-align:left">🐠 <code>:tropical_fish:</code></td><td style="text-align:left">🐟 <code>:fish:</code></td><td style="text-align:left">🐳 <code>:whale:</code></td></tr><tr><td style="text-align:left">🐋 <code>:whale2:</code></td><td style="text-align:left">🐬 <code>:dolphin:</code></td><td style="text-align:left">🐄 <code>:cow2:</code></td></tr><tr><td style="text-align:left">🐏 <code>:ram:</code></td><td style="text-align:left">🐀 <code>:rat:</code></td><td style="text-align:left">🐃 <code>:water_buffalo:</code></td></tr><tr><td style="text-align:left">🐅 <code>:tiger2:</code></td><td style="text-align:left">🐇 <code>:rabbit2:</code></td><td style="text-align:left">🐉 <code>:dragon:</code></td></tr><tr><td style="text-align:left">🐐 <code>:goat:</code></td><td style="text-align:left">🐓 <code>:rooster:</code></td><td style="text-align:left">🐕 <code>:dog2:</code></td></tr><tr><td style="text-align:left">🐖 <code>:pig2:</code></td><td style="text-align:left">🐁 <code>:mouse2:</code></td><td style="text-align:left">🐂 <code>:ox:</code></td></tr><tr><td style="text-align:left">🐲 <code>:dragon_face:</code></td><td style="text-align:left">🐡 <code>:blowfish:</code></td><td style="text-align:left">🐊 <code>:crocodile:</code></td></tr><tr><td style="text-align:left">🐪 <code>:dromedary_camel:</code></td><td style="text-align:left">🐆 <code>:leopard:</code></td><td style="text-align:left">🐈 <code>:cat2:</code></td></tr><tr><td style="text-align:left">🐩 <code>:poodle:</code></td><td style="text-align:left">🐾 <code>:paw_prints:</code></td><td style="text-align:left">💐 <code>:bouquet:</code></td></tr><tr><td style="text-align:left">🌸 <code>:cherry_blossom:</code></td><td style="text-align:left">🌷 <code>:tulip:</code></td><td style="text-align:left">🍀 <code>:four_leaf_clover:</code></td></tr><tr><td style="text-align:left">🌹 <code>:rose:</code></td><td style="text-align:left">🌻 <code>:sunflower:</code></td><td style="text-align:left">🌺 <code>:hibiscus:</code></td></tr><tr><td style="text-align:left">🍁 <code>:maple_leaf:</code></td><td style="text-align:left">🍃 <code>:leaves:</code></td><td style="text-align:left">🍂 <code>:fallen_leaf:</code></td></tr><tr><td style="text-align:left">🌿 <code>:herb:</code></td><td style="text-align:left">🍄 <code>:mushroom:</code></td><td style="text-align:left">🌵 <code>:cactus:</code></td></tr><tr><td style="text-align:left">🌴 <code>:palm_tree:</code></td><td style="text-align:left">🌲 <code>:evergreen_tree:</code></td><td style="text-align:left">🌳 <code>:deciduous_tree:</code></td></tr><tr><td style="text-align:left">🌰 <code>:chestnut:</code></td><td style="text-align:left">🌱 <code>:seedling:</code></td><td style="text-align:left">🌼 <code>:blossom:</code></td></tr><tr><td style="text-align:left">🌾 <code>:ear_of_rice:</code></td><td style="text-align:left">🐚 <code>:shell:</code></td><td style="text-align:left">🌐 <code>:globe_with_meridians:</code></td></tr><tr><td style="text-align:left">🌞 <code>:sun_with_face:</code></td><td style="text-align:left">🌝 <code>:full_moon_with_face:</code></td><td style="text-align:left">🌚 <code>:new_moon_with_face:</code></td></tr><tr><td style="text-align:left">🌑 <code>:new_moon:</code></td><td style="text-align:left">🌒 <code>:waxing_crescent_moon:</code></td><td style="text-align:left">🌓 <code>:first_quarter_moon:</code></td></tr><tr><td style="text-align:left">🌔 <code>:waxing_gibbous_moon:</code></td><td style="text-align:left">🌕 <code>:full_moon:</code></td><td style="text-align:left">🌖 <code>:waning_gibbous_moon:</code></td></tr><tr><td style="text-align:left">🌗 <code>:last_quarter_moon:</code></td><td style="text-align:left">🌘 <code>:waning_crescent_moon:</code></td><td style="text-align:left">🌜 <code>:last_quarter_moon_with_face:</code></td></tr><tr><td style="text-align:left">🌛 <code>:first_quarter_moon_with_face:</code></td><td style="text-align:left">🌔 <code>:moon:</code></td><td style="text-align:left">🌍 <code>:earth_africa:</code></td></tr><tr><td style="text-align:left">🌎 <code>:earth_americas:</code></td><td style="text-align:left">🌏 <code>:earth_asia:</code></td><td style="text-align:left">🌋 <code>:volcano:</code></td></tr><tr><td style="text-align:left">🌌 <code>:milky_way:</code></td><td style="text-align:left">⛅️ <code>:partly_sunny:</code></td><td style="text-align:left">:octocat: <code>:octocat:</code></td></tr><tr><td style="text-align:left">:squirrel: <code>:squirrel:</code></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h2 id="事物"><a class="markdownIt-Anchor" href="#事物"></a> 事物</h2><table><thead><tr><th style="text-align:left">🎍 <code>:bamboo:</code></th><th style="text-align:left">💝 <code>:gift_heart:</code></th><th style="text-align:left">🎎 <code>:dolls:</code></th></tr></thead><tbody><tr><td style="text-align:left">🎒 <code>:school_satchel:</code></td><td style="text-align:left">🎓 <code>:mortar_board:</code></td><td style="text-align:left">🎏 <code>:flags:</code></td></tr><tr><td style="text-align:left">🎆 <code>:fireworks:</code></td><td style="text-align:left">🎇 <code>:sparkler:</code></td><td style="text-align:left">🎐 <code>:wind_chime:</code></td></tr><tr><td style="text-align:left">🎑 <code>:rice_scene:</code></td><td style="text-align:left">🎃 <code>:jack_o_lantern:</code></td><td style="text-align:left">👻 <code>:ghost:</code></td></tr><tr><td style="text-align:left">🎅 <code>:santa:</code></td><td style="text-align:left">🎄 <code>:christmas_tree:</code></td><td style="text-align:left">🎁 <code>:gift:</code></td></tr><tr><td style="text-align:left">🔔 <code>:bell:</code></td><td style="text-align:left">🔕 <code>:no_bell:</code></td><td style="text-align:left">🎋 <code>:tanabata_tree:</code></td></tr><tr><td style="text-align:left">🎉 <code>:tada:</code></td><td style="text-align:left">🎊 <code>:confetti_ball:</code></td><td style="text-align:left">🎈 <code>:balloon:</code></td></tr><tr><td style="text-align:left">🔮 <code>:crystal_ball:</code></td><td style="text-align:left">💿 <code>:cd:</code></td><td style="text-align:left">📀 <code>:dvd:</code></td></tr><tr><td style="text-align:left">💾 <code>:floppy_disk:</code></td><td style="text-align:left">📷 <code>:camera:</code></td><td style="text-align:left">📹 <code>:video_camera:</code></td></tr><tr><td style="text-align:left">🎥 <code>:movie_camera:</code></td><td style="text-align:left">💻 <code>:computer:</code></td><td style="text-align:left">📺 <code>:tv:</code></td></tr><tr><td style="text-align:left">📱 <code>:iphone:</code></td><td style="text-align:left">☎️ <code>:phone:</code></td><td style="text-align:left">☎️ <code>:telephone:</code></td></tr><tr><td style="text-align:left">📞 <code>:telephone_receiver:</code></td><td style="text-align:left">📟 <code>:pager:</code></td><td style="text-align:left">📠 <code>:fax:</code></td></tr><tr><td style="text-align:left">💽 <code>:minidisc:</code></td><td style="text-align:left">📼 <code>:vhs:</code></td><td style="text-align:left">🔉 <code>:sound:</code></td></tr><tr><td style="text-align:left">🔈 <code>:speaker:</code></td><td style="text-align:left">🔇 <code>:mute:</code></td><td style="text-align:left">📢 <code>:loudspeaker:</code></td></tr><tr><td style="text-align:left">📣 <code>:mega:</code></td><td style="text-align:left">⌛️ <code>:hourglass:</code></td><td style="text-align:left">⏳ <code>:hourglass_flowing_sand:</code></td></tr><tr><td style="text-align:left">⏰ <code>:alarm_clock:</code></td><td style="text-align:left">⌚️ <code>:watch:</code></td><td style="text-align:left">📻 <code>:radio:</code></td></tr><tr><td style="text-align:left">📡 <code>:satellite:</code></td><td style="text-align:left">➿ <code>:loop:</code></td><td style="text-align:left">🔍 <code>:mag:</code></td></tr><tr><td style="text-align:left">🔎 <code>:mag_right:</code></td><td style="text-align:left">🔓 <code>:unlock:</code></td><td style="text-align:left">🔒 <code>:lock:</code></td></tr><tr><td style="text-align:left">🔏 <code>:lock_with_ink_pen:</code></td><td style="text-align:left">🔐 <code>:closed_lock_with_key:</code></td><td style="text-align:left">🔑 <code>:key:</code></td></tr><tr><td style="text-align:left">💡 <code>:bulb:</code></td><td style="text-align:left">🔦 <code>:flashlight:</code></td><td style="text-align:left">🔆 <code>:high_brightness:</code></td></tr><tr><td style="text-align:left">🔅 <code>:low_brightness:</code></td><td style="text-align:left">🔌 <code>:electric_plug:</code></td><td style="text-align:left">🔋 <code>:battery:</code></td></tr><tr><td style="text-align:left">📲 <code>:calling:</code></td><td style="text-align:left">✉️ <code>:email:</code></td><td style="text-align:left">📫 <code>:mailbox:</code></td></tr><tr><td style="text-align:left">📮 <code>:postbox:</code></td><td style="text-align:left">🛀 <code>:bath:</code></td><td style="text-align:left">🛁 <code>:bathtub:</code></td></tr><tr><td style="text-align:left">🚿 <code>:shower:</code></td><td style="text-align:left">🚽 <code>:toilet:</code></td><td style="text-align:left">🔧 <code>:wrench:</code></td></tr><tr><td style="text-align:left">🔩 <code>:nut_and_bolt:</code></td><td style="text-align:left">🔨 <code>:hammer:</code></td><td style="text-align:left">💺 <code>:seat:</code></td></tr><tr><td style="text-align:left">💰 <code>:moneybag:</code></td><td style="text-align:left">💴 <code>:yen:</code></td><td style="text-align:left">💵 <code>:dollar:</code></td></tr><tr><td style="text-align:left">💷 <code>:pound:</code></td><td style="text-align:left">💶 <code>:euro:</code></td><td style="text-align:left">💳 <code>:credit_card:</code></td></tr><tr><td style="text-align:left">💸 <code>:money_with_wings:</code></td><td style="text-align:left">📧 <code>:e-mail:</code></td><td style="text-align:left">📥 <code>:inbox_tray:</code></td></tr><tr><td style="text-align:left">📤 <code>:outbox_tray:</code></td><td style="text-align:left">✉️ <code>:envelope:</code></td><td style="text-align:left">📨 <code>:incoming_envelope:</code></td></tr><tr><td style="text-align:left">📯 <code>:postal_horn:</code></td><td style="text-align:left">📪 <code>:mailbox_closed:</code></td><td style="text-align:left">📬 <code>:mailbox_with_mail:</code></td></tr><tr><td style="text-align:left">📭 <code>:mailbox_with_no_mail:</code></td><td style="text-align:left">🚪 <code>:door:</code></td><td style="text-align:left">🚬 <code>:smoking:</code></td></tr><tr><td style="text-align:left">💣 <code>:bomb:</code></td><td style="text-align:left">🔫 <code>:gun:</code></td><td style="text-align:left">🔪 <code>:hocho:</code></td></tr><tr><td style="text-align:left">💊 <code>:pill:</code></td><td style="text-align:left">💉 <code>:syringe:</code></td><td style="text-align:left">📄 <code>:page_facing_up:</code></td></tr><tr><td style="text-align:left">📃 <code>:page_with_curl:</code></td><td style="text-align:left">📑 <code>:bookmark_tabs:</code></td><td style="text-align:left">📊 <code>:bar_chart:</code></td></tr><tr><td style="text-align:left">📈 <code>:chart_with_upwards_trend:</code></td><td style="text-align:left">📉 <code>:chart_with_downwards_trend:</code></td><td style="text-align:left">📜 <code>:scroll:</code></td></tr><tr><td style="text-align:left">📋 <code>:clipboard:</code></td><td style="text-align:left">📆 <code>:calendar:</code></td><td style="text-align:left">📅 <code>:date:</code></td></tr><tr><td style="text-align:left">📇 <code>:card_index:</code></td><td style="text-align:left">📁 <code>:file_folder:</code></td><td style="text-align:left">📂 <code>:open_file_folder:</code></td></tr><tr><td style="text-align:left">✂️ <code>:scissors:</code></td><td style="text-align:left">📌 <code>:pushpin:</code></td><td style="text-align:left">📎 <code>:paperclip:</code></td></tr><tr><td style="text-align:left">✒️ <code>:black_nib:</code></td><td style="text-align:left">✏️ <code>:pencil2:</code></td><td style="text-align:left">📏 <code>:straight_ruler:</code></td></tr><tr><td style="text-align:left">📐 <code>:triangular_ruler:</code></td><td style="text-align:left">📕 <code>:closed_book:</code></td><td style="text-align:left">📗 <code>:green_book:</code></td></tr><tr><td style="text-align:left">📘 <code>:blue_book:</code></td><td style="text-align:left">📙 <code>:orange_book:</code></td><td style="text-align:left">📓 <code>:notebook:</code></td></tr><tr><td style="text-align:left">📔 <code>:notebook_with_decorative_cover:</code></td><td style="text-align:left">📒 <code>:ledger:</code></td><td style="text-align:left">📚 <code>:books:</code></td></tr><tr><td style="text-align:left">🔖 <code>:bookmark:</code></td><td style="text-align:left">📛 <code>:name_badge:</code></td><td style="text-align:left">🔬 <code>:microscope:</code></td></tr><tr><td style="text-align:left">🔭 <code>:telescope:</code></td><td style="text-align:left">📰 <code>:newspaper:</code></td><td style="text-align:left">🏈 <code>:football:</code></td></tr><tr><td style="text-align:left">🏀 <code>:basketball:</code></td><td style="text-align:left">⚽️ <code>:soccer:</code></td><td style="text-align:left">⚾️ <code>:baseball:</code></td></tr><tr><td style="text-align:left">🎾 <code>:tennis:</code></td><td style="text-align:left">🎱 <code>:8ball:</code></td><td style="text-align:left">🏉 <code>:rugby_football:</code></td></tr><tr><td style="text-align:left">🎳 <code>:bowling:</code></td><td style="text-align:left">⛳️ <code>:golf:</code></td><td style="text-align:left">🚵 <code>:mountain_bicyclist:</code></td></tr><tr><td style="text-align:left">🚴 <code>:bicyclist:</code></td><td style="text-align:left">🏇 <code>:horse_racing:</code></td><td style="text-align:left">🏂 <code>:snowboarder:</code></td></tr><tr><td style="text-align:left">🏊 <code>:swimmer:</code></td><td style="text-align:left">🏄 <code>:surfer:</code></td><td style="text-align:left">🎿 <code>:ski:</code></td></tr><tr><td style="text-align:left">♠️ <code>:spades:</code></td><td style="text-align:left">♥️ <code>:hearts:</code></td><td style="text-align:left">♣️ <code>:clubs:</code></td></tr><tr><td style="text-align:left">♦️ <code>:diamonds:</code></td><td style="text-align:left">💎 <code>:gem:</code></td><td style="text-align:left">💍 <code>:ring:</code></td></tr><tr><td style="text-align:left">🏆 <code>:trophy:</code></td><td style="text-align:left">🎼 <code>:musical_score:</code></td><td style="text-align:left">🎹 <code>:musical_keyboard:</code></td></tr><tr><td style="text-align:left">🎻 <code>:violin:</code></td><td style="text-align:left">👾 <code>:space_invader:</code></td><td style="text-align:left">🎮 <code>:video_game:</code></td></tr><tr><td style="text-align:left">🃏 <code>:black_joker:</code></td><td style="text-align:left">🎴 <code>:flower_playing_cards:</code></td><td style="text-align:left">🎲 <code>:game_die:</code></td></tr><tr><td style="text-align:left">🎯 <code>:dart:</code></td><td style="text-align:left">🀄️ <code>:mahjong:</code></td><td style="text-align:left">🎬 <code>:clapper:</code></td></tr><tr><td style="text-align:left">📝 <code>:memo:</code></td><td style="text-align:left">📝 <code>:pencil:</code></td><td style="text-align:left">📖 <code>:book:</code></td></tr><tr><td style="text-align:left">🎨 <code>:art:</code></td><td style="text-align:left">🎤 <code>:microphone:</code></td><td style="text-align:left">🎧 <code>:headphones:</code></td></tr><tr><td style="text-align:left">🎺 <code>:trumpet:</code></td><td style="text-align:left">🎷 <code>:saxophone:</code></td><td style="text-align:left">🎸 <code>:guitar:</code></td></tr><tr><td style="text-align:left">👞 <code>:shoe:</code></td><td style="text-align:left">👡 <code>:sandal:</code></td><td style="text-align:left">👠 <code>:high_heel:</code></td></tr><tr><td style="text-align:left">💄 <code>:lipstick:</code></td><td style="text-align:left">👢 <code>:boot:</code></td><td style="text-align:left">👕 <code>:shirt:</code></td></tr><tr><td style="text-align:left">👕 <code>:tshirt:</code></td><td style="text-align:left">👔 <code>:necktie:</code></td><td style="text-align:left">👚 <code>:womans_clothes:</code></td></tr><tr><td style="text-align:left">👗 <code>:dress:</code></td><td style="text-align:left">🎽 <code>:running_shirt_with_sash:</code></td><td style="text-align:left">👖 <code>:jeans:</code></td></tr><tr><td style="text-align:left">👘 <code>:kimono:</code></td><td style="text-align:left">👙 <code>:bikini:</code></td><td style="text-align:left">🎀 <code>:ribbon:</code></td></tr><tr><td style="text-align:left">🎩 <code>:tophat:</code></td><td style="text-align:left">👑 <code>:crown:</code></td><td style="text-align:left">👒 <code>:womans_hat:</code></td></tr><tr><td style="text-align:left">👞 <code>:mans_shoe:</code></td><td style="text-align:left">🌂 <code>:closed_umbrella:</code></td><td style="text-align:left">💼 <code>:briefcase:</code></td></tr><tr><td style="text-align:left">👜 <code>:handbag:</code></td><td style="text-align:left">👝 <code>:pouch:</code></td><td style="text-align:left">👛 <code>:purse:</code></td></tr><tr><td style="text-align:left">👓 <code>:eyeglasses:</code></td><td style="text-align:left">🎣 <code>:fishing_pole_and_fish:</code></td><td style="text-align:left">☕️ <code>:coffee:</code></td></tr><tr><td style="text-align:left">🍵 <code>:tea:</code></td><td style="text-align:left">🍶 <code>:sake:</code></td><td style="text-align:left">🍼 <code>:baby_bottle:</code></td></tr><tr><td style="text-align:left">🍺 <code>:beer:</code></td><td style="text-align:left">🍻 <code>:beers:</code></td><td style="text-align:left">🍸 <code>:cocktail:</code></td></tr><tr><td style="text-align:left">🍹 <code>:tropical_drink:</code></td><td style="text-align:left">🍷 <code>:wine_glass:</code></td><td style="text-align:left">🍴 <code>:fork_and_knife:</code></td></tr><tr><td style="text-align:left">🍕 <code>:pizza:</code></td><td style="text-align:left">🍔 <code>:hamburger:</code></td><td style="text-align:left">🍟 <code>:fries:</code></td></tr><tr><td style="text-align:left">🍗 <code>:poultry_leg:</code></td><td style="text-align:left">🍖 <code>:meat_on_bone:</code></td><td style="text-align:left">🍝 <code>:spaghetti:</code></td></tr><tr><td style="text-align:left">🍛 <code>:curry:</code></td><td style="text-align:left">🍤 <code>:fried_shrimp:</code></td><td style="text-align:left">🍱 <code>:bento:</code></td></tr><tr><td style="text-align:left">🍣 <code>:sushi:</code></td><td style="text-align:left">🍥 <code>:fish_cake:</code></td><td style="text-align:left">🍙 <code>:rice_ball:</code></td></tr><tr><td style="text-align:left">🍘 <code>:rice_cracker:</code></td><td style="text-align:left">🍚 <code>:rice:</code></td><td style="text-align:left">🍜 <code>:ramen:</code></td></tr><tr><td style="text-align:left">🍲 <code>:stew:</code></td><td style="text-align:left">🍢 <code>:oden:</code></td><td style="text-align:left">🍡 <code>:dango:</code></td></tr><tr><td style="text-align:left">🥚 <code>:egg:</code></td><td style="text-align:left">🍞 <code>:bread:</code></td><td style="text-align:left">🍩 <code>:doughnut:</code></td></tr><tr><td style="text-align:left">🍮 <code>:custard:</code></td><td style="text-align:left">🍦 <code>:icecream:</code></td><td style="text-align:left">🍨 <code>:ice_cream:</code></td></tr><tr><td style="text-align:left">🍧 <code>:shaved_ice:</code></td><td style="text-align:left">🎂 <code>:birthday:</code></td><td style="text-align:left">🍰 <code>:cake:</code></td></tr><tr><td style="text-align:left">🍪 <code>:cookie:</code></td><td style="text-align:left">🍫 <code>:chocolate_bar:</code></td><td style="text-align:left">🍬 <code>:candy:</code></td></tr><tr><td style="text-align:left">🍭 <code>:lollipop:</code></td><td style="text-align:left">🍯 <code>:honey_pot:</code></td><td style="text-align:left">🍎 <code>:apple:</code></td></tr><tr><td style="text-align:left">🍏 <code>:green_apple:</code></td><td style="text-align:left">🍊 <code>:tangerine:</code></td><td style="text-align:left">🍋 <code>:lemon:</code></td></tr><tr><td style="text-align:left">🍒 <code>:cherries:</code></td><td style="text-align:left">🍇 <code>:grapes:</code></td><td style="text-align:left">🍉 <code>:watermelon:</code></td></tr><tr><td style="text-align:left">🍓 <code>:strawberry:</code></td><td style="text-align:left">🍑 <code>:peach:</code></td><td style="text-align:left">🍈 <code>:melon:</code></td></tr><tr><td style="text-align:left">🍌 <code>:banana:</code></td><td style="text-align:left">🍐 <code>:pear:</code></td><td style="text-align:left">🍍 <code>:pineapple:</code></td></tr><tr><td style="text-align:left">🍠 <code>:sweet_potato:</code></td><td style="text-align:left">🍆 <code>:eggplant:</code></td><td style="text-align:left">🍅 <code>:tomato:</code></td></tr><tr><td style="text-align:left">🌽 <code>:corn:</code></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h2 id="地点"><a class="markdownIt-Anchor" href="#地点"></a> 地点</h2><table><thead><tr><th style="text-align:left">🏠 <code>:house:</code></th><th style="text-align:left">🏡 <code>:house_with_garden:</code></th><th style="text-align:left">🏫 <code>:school:</code></th></tr></thead><tbody><tr><td style="text-align:left">🏢 <code>:office:</code></td><td style="text-align:left">🏣 <code>:post_office:</code></td><td style="text-align:left">🏥 <code>:hospital:</code></td></tr><tr><td style="text-align:left">🏦 <code>:bank:</code></td><td style="text-align:left">🏪 <code>:convenience_store:</code></td><td style="text-align:left">🏩 <code>:love_hotel:</code></td></tr><tr><td style="text-align:left">🏨 <code>:hotel:</code></td><td style="text-align:left">💒 <code>:wedding:</code></td><td style="text-align:left">⛪️ <code>:church:</code></td></tr><tr><td style="text-align:left">🏬 <code>:department_store:</code></td><td style="text-align:left">🏤 <code>:european_post_office:</code></td><td style="text-align:left">🌇 <code>:city_sunrise:</code></td></tr><tr><td style="text-align:left">🌆 <code>:city_sunset:</code></td><td style="text-align:left">🏯 <code>:japanese_castle:</code></td><td style="text-align:left">🏰 <code>:european_castle:</code></td></tr><tr><td style="text-align:left">⛺️ <code>:tent:</code></td><td style="text-align:left">🏭 <code>:factory:</code></td><td style="text-align:left">🗼 <code>:tokyo_tower:</code></td></tr><tr><td style="text-align:left">🗾 <code>:japan:</code></td><td style="text-align:left">🗻 <code>:mount_fuji:</code></td><td style="text-align:left">🌄 <code>:sunrise_over_mountains:</code></td></tr><tr><td style="text-align:left">🌅 <code>:sunrise:</code></td><td style="text-align:left">🌠 <code>:stars:</code></td><td style="text-align:left">🗽 <code>:statue_of_liberty:</code></td></tr><tr><td style="text-align:left">🌉 <code>:bridge_at_night:</code></td><td style="text-align:left">🎠 <code>:carousel_horse:</code></td><td style="text-align:left">🌈 <code>:rainbow:</code></td></tr><tr><td style="text-align:left">🎡 <code>:ferris_wheel:</code></td><td style="text-align:left">⛲️ <code>:fountain:</code></td><td style="text-align:left">🎢 <code>:roller_coaster:</code></td></tr><tr><td style="text-align:left">🚢 <code>:ship:</code></td><td style="text-align:left">🚤 <code>:speedboat:</code></td><td style="text-align:left">⛵️ <code>:boat:</code></td></tr><tr><td style="text-align:left">⛵️ <code>:sailboat:</code></td><td style="text-align:left">🚣 <code>:rowboat:</code></td><td style="text-align:left">⚓️ <code>:anchor:</code></td></tr><tr><td style="text-align:left">🚀 <code>:rocket:</code></td><td style="text-align:left">✈️ <code>:airplane:</code></td><td style="text-align:left">🚁 <code>:helicopter:</code></td></tr><tr><td style="text-align:left">🚂 <code>:steam_locomotive:</code></td><td style="text-align:left">🚊 <code>:tram:</code></td><td style="text-align:left">🚞 <code>:mountain_railway:</code></td></tr><tr><td style="text-align:left">🚲 <code>:bike:</code></td><td style="text-align:left">🚡 <code>:aerial_tramway:</code></td><td style="text-align:left">🚟 <code>:suspension_railway:</code></td></tr><tr><td style="text-align:left">🚠 <code>:mountain_cableway:</code></td><td style="text-align:left">🚜 <code>:tractor:</code></td><td style="text-align:left">🚙 <code>:blue_car:</code></td></tr><tr><td style="text-align:left">🚘 <code>:oncoming_automobile:</code></td><td style="text-align:left">🚗 <code>:car:</code></td><td style="text-align:left">🚗 <code>:red_car:</code></td></tr><tr><td style="text-align:left">🚕 <code>:taxi:</code></td><td style="text-align:left">🚖 <code>:oncoming_taxi:</code></td><td style="text-align:left">🚛 <code>:articulated_lorry:</code></td></tr><tr><td style="text-align:left">🚌 <code>:bus:</code></td><td style="text-align:left">🚍 <code>:oncoming_bus:</code></td><td style="text-align:left">🚨 <code>:rotating_light:</code></td></tr><tr><td style="text-align:left">🚓 <code>:police_car:</code></td><td style="text-align:left">🚔 <code>:oncoming_police_car:</code></td><td style="text-align:left">🚒 <code>:fire_engine:</code></td></tr><tr><td style="text-align:left">🚑 <code>:ambulance:</code></td><td style="text-align:left">🚐 <code>:minibus:</code></td><td style="text-align:left">🚚 <code>:truck:</code></td></tr><tr><td style="text-align:left">🚋 <code>:train:</code></td><td style="text-align:left">🚉 <code>:station:</code></td><td style="text-align:left">🚆 <code>:train2:</code></td></tr><tr><td style="text-align:left">🚅 <code>:bullettrain_front:</code></td><td style="text-align:left">🚄 <code>:bullettrain_side:</code></td><td style="text-align:left">🚈 <code>:light_rail:</code></td></tr><tr><td style="text-align:left">🚝 <code>:monorail:</code></td><td style="text-align:left">🚃 <code>:railway_car:</code></td><td style="text-align:left">🚎 <code>:trolleybus:</code></td></tr><tr><td style="text-align:left">🎫 <code>:ticket:</code></td><td style="text-align:left">⛽️ <code>:fuelpump:</code></td><td style="text-align:left">🚦 <code>:vertical_traffic_light:</code></td></tr><tr><td style="text-align:left">🚥 <code>:traffic_light:</code></td><td style="text-align:left">⚠️ <code>:warning:</code></td><td style="text-align:left">🚧 <code>:construction:</code></td></tr><tr><td style="text-align:left">🔰 <code>:beginner:</code></td><td style="text-align:left">🏧 <code>:atm:</code></td><td style="text-align:left">🎰 <code>:slot_machine:</code></td></tr><tr><td style="text-align:left">🚏 <code>:busstop:</code></td><td style="text-align:left">💈 <code>:barber:</code></td><td style="text-align:left">♨️ <code>:hotsprings:</code></td></tr><tr><td style="text-align:left">🏁 <code>:checkered_flag:</code></td><td style="text-align:left">🎌 <code>:crossed_flags:</code></td><td style="text-align:left">🏮 <code>:izakaya_lantern:</code></td></tr><tr><td style="text-align:left">🗿 <code>:moyai:</code></td><td style="text-align:left">🎪 <code>:circus_tent:</code></td><td style="text-align:left">🎭 <code>:performing_arts:</code></td></tr><tr><td style="text-align:left">📍 <code>:round_pushpin:</code></td><td style="text-align:left">🚩 <code>:triangular_flag_on_post:</code></td><td style="text-align:left">🇯🇵 <code>:jp:</code></td></tr><tr><td style="text-align:left">🇰🇷 <code>:kr:</code></td><td style="text-align:left">🇨🇳 <code>:cn:</code></td><td style="text-align:left">🇺🇸 <code>:us:</code></td></tr><tr><td style="text-align:left">🇫🇷 <code>:fr:</code></td><td style="text-align:left">🇪🇸 <code>:es:</code></td><td style="text-align:left">🇮🇹 <code>:it:</code></td></tr><tr><td style="text-align:left">🇷🇺 <code>:ru:</code></td><td style="text-align:left">🇬🇧 <code>:gb:</code></td><td style="text-align:left">🇬🇧 <code>:uk:</code></td></tr><tr><td style="text-align:left">🇩🇪 <code>:de:</code></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h2 id="符号"><a class="markdownIt-Anchor" href="#符号"></a> 符号</h2><table><thead><tr><th style="text-align:left">1️⃣ <code>:one:</code></th><th style="text-align:left">2️⃣ <code>:two:</code></th><th style="text-align:left">3️⃣ <code>:three:</code></th></tr></thead><tbody><tr><td style="text-align:left">4️⃣ <code>:four:</code></td><td style="text-align:left">5️⃣ <code>:five:</code></td><td style="text-align:left">6️⃣ <code>:six:</code></td></tr><tr><td style="text-align:left">7️⃣ <code>:seven:</code></td><td style="text-align:left">8️⃣ <code>:eight:</code></td><td style="text-align:left">9️⃣ <code>:nine:</code></td></tr><tr><td style="text-align:left">🔟 <code>:keycap_ten:</code></td><td style="text-align:left">🔢 <code>:1234:</code></td><td style="text-align:left">0️⃣ <code>:zero:</code></td></tr><tr><td style="text-align:left">#️⃣ <code>:hash:</code></td><td style="text-align:left">🔣 <code>:symbols:</code></td><td style="text-align:left">◀️ <code>:arrow_backward:</code></td></tr><tr><td style="text-align:left">⬇️ <code>:arrow_down:</code></td><td style="text-align:left">▶️ <code>:arrow_forward:</code></td><td style="text-align:left">⬅️ <code>:arrow_left:</code></td></tr><tr><td style="text-align:left">🔠 <code>:capital_abcd:</code></td><td style="text-align:left">🔡 <code>:abcd:</code></td><td style="text-align:left">🔤 <code>:abc:</code></td></tr><tr><td style="text-align:left">↙️ <code>:arrow_lower_left:</code></td><td style="text-align:left">↘️ <code>:arrow_lower_right:</code></td><td style="text-align:left">➡️ <code>:arrow_right:</code></td></tr><tr><td style="text-align:left">⬆️ <code>:arrow_up:</code></td><td style="text-align:left">↖️ <code>:arrow_upper_left:</code></td><td style="text-align:left">↗️ <code>:arrow_upper_right:</code></td></tr><tr><td style="text-align:left">⏬ <code>:arrow_double_down:</code></td><td style="text-align:left">⏫ <code>:arrow_double_up:</code></td><td style="text-align:left">🔽 <code>:arrow_down_small:</code></td></tr><tr><td style="text-align:left">⤵️ <code>:arrow_heading_down:</code></td><td style="text-align:left">⤴️ <code>:arrow_heading_up:</code></td><td style="text-align:left">↩️ <code>:leftwards_arrow_with_hook:</code></td></tr><tr><td style="text-align:left">↪️ <code>:arrow_right_hook:</code></td><td style="text-align:left">↔️ <code>:left_right_arrow:</code></td><td style="text-align:left">↕️ <code>:arrow_up_down:</code></td></tr><tr><td style="text-align:left">🔼 <code>:arrow_up_small:</code></td><td style="text-align:left">🔃 <code>:arrows_clockwise:</code></td><td style="text-align:left">🔄 <code>:arrows_counterclockwise:</code></td></tr><tr><td style="text-align:left">⏪ <code>:rewind:</code></td><td style="text-align:left">⏩ <code>:fast_forward:</code></td><td style="text-align:left">ℹ️ <code>:information_source:</code></td></tr><tr><td style="text-align:left">🆗 <code>:ok:</code></td><td style="text-align:left">🔀 <code>:twisted_rightwards_arrows:</code></td><td style="text-align:left">🔁 <code>:repeat:</code></td></tr><tr><td style="text-align:left">🔂 <code>:repeat_one:</code></td><td style="text-align:left">🆕 <code>:new:</code></td><td style="text-align:left">🔝 <code>:top:</code></td></tr><tr><td style="text-align:left">🆙 <code>:up:</code></td><td style="text-align:left">🆒 <code>:cool:</code></td><td style="text-align:left">🆓 <code>:free:</code></td></tr><tr><td style="text-align:left">🆖 <code>:ng:</code></td><td style="text-align:left">🎦 <code>:cinema:</code></td><td style="text-align:left">🈁 <code>:koko:</code></td></tr><tr><td style="text-align:left">📶 <code>:signal_strength:</code></td><td style="text-align:left">:u5272: <code>:u5272:</code></td><td style="text-align:left">:u5408: <code>:u5408:</code></td></tr><tr><td style="text-align:left">:u55b6: <code>:u55b6:</code></td><td style="text-align:left">:u6307: <code>:u6307:</code></td><td style="text-align:left">:u6708: <code>:u6708:</code></td></tr><tr><td style="text-align:left">:u6709: <code>:u6709:</code></td><td style="text-align:left">🈵 <code>:u6e80:</code></td><td style="text-align:left">:u7121: <code>:u7121:</code></td></tr><tr><td style="text-align:left">:u7533: <code>:u7533:</code></td><td style="text-align:left">:u7a7a: <code>:u7a7a:</code></td><td style="text-align:left">:u7981: <code>:u7981:</code></td></tr><tr><td style="text-align:left">🈂️ <code>:sa:</code></td><td style="text-align:left">🚻 <code>:restroom:</code></td><td style="text-align:left">🚹 <code>:mens:</code></td></tr><tr><td style="text-align:left">🚺 <code>:womens:</code></td><td style="text-align:left">🚼 <code>:baby_symbol:</code></td><td style="text-align:left">🚭 <code>:no_smoking:</code></td></tr><tr><td style="text-align:left">🅿️ <code>:parking:</code></td><td style="text-align:left">♿️ <code>:wheelchair:</code></td><td style="text-align:left">🚇 <code>:metro:</code></td></tr><tr><td style="text-align:left">🛄 <code>:baggage_claim:</code></td><td style="text-align:left">🉑 <code>:accept:</code></td><td style="text-align:left">🚾 <code>:wc:</code></td></tr><tr><td style="text-align:left">🚰 <code>:potable_water:</code></td><td style="text-align:left">🚮 <code>:put_litter_in_its_place:</code></td><td style="text-align:left">㊙️ <code>:secret:</code></td></tr><tr><td style="text-align:left">㊗️ <code>:congratulations:</code></td><td style="text-align:left">Ⓜ️ <code>:m:</code></td><td style="text-align:left">🛂 <code>:passport_control:</code></td></tr><tr><td style="text-align:left">🛅 <code>:left_luggage:</code></td><td style="text-align:left">🛃 <code>:customs:</code></td><td style="text-align:left">🉐 <code>:ideograph_advantage:</code></td></tr><tr><td style="text-align:left">🆑 <code>:cl:</code></td><td style="text-align:left">🆘 <code>:sos:</code></td><td style="text-align:left">🆔 <code>:id:</code></td></tr><tr><td style="text-align:left">🚫 <code>:no_entry_sign:</code></td><td style="text-align:left">🔞 <code>:underage:</code></td><td style="text-align:left">📵 <code>:no_mobile_phones:</code></td></tr><tr><td style="text-align:left">🚯 <code>:do_not_litter:</code></td><td style="text-align:left">🚱 <code>:non-potable_water:</code></td><td style="text-align:left">🚳 <code>:no_bicycles:</code></td></tr><tr><td style="text-align:left">🚷 <code>:no_pedestrians:</code></td><td style="text-align:left">🚸 <code>:children_crossing:</code></td><td style="text-align:left">⛔️ <code>:no_entry:</code></td></tr><tr><td style="text-align:left">✳️ <code>:eight_spoked_asterisk:</code></td><td style="text-align:left">✴️ <code>:eight_pointed_black_star:</code></td><td style="text-align:left">💟 <code>:heart_decoration:</code></td></tr><tr><td style="text-align:left">🆚 <code>:vs:</code></td><td style="text-align:left">📳 <code>:vibration_mode:</code></td><td style="text-align:left">📴 <code>:mobile_phone_off:</code></td></tr><tr><td style="text-align:left">💹 <code>:chart:</code></td><td style="text-align:left">💱 <code>:currency_exchange:</code></td><td style="text-align:left">♈️ <code>:aries:</code></td></tr><tr><td style="text-align:left">♉️ <code>:taurus:</code></td><td style="text-align:left">♊️ <code>:gemini:</code></td><td style="text-align:left">♋️ <code>:cancer:</code></td></tr><tr><td style="text-align:left">♌️ <code>:leo:</code></td><td style="text-align:left">♍️ <code>:virgo:</code></td><td style="text-align:left">♎️ <code>:libra:</code></td></tr><tr><td style="text-align:left">♏️ <code>:scorpius:</code></td><td style="text-align:left">♐️ <code>:sagittarius:</code></td><td style="text-align:left">♑️ <code>:capricorn:</code></td></tr><tr><td style="text-align:left">♒️ <code>:aquarius:</code></td><td style="text-align:left">♓️ <code>:pisces:</code></td><td style="text-align:left">⛎ <code>:ophiuchus:</code></td></tr><tr><td style="text-align:left">🔯 <code>:six_pointed_star:</code></td><td style="text-align:left">❎ <code>:negative_squared_cross_mark:</code></td><td style="text-align:left">🅰️ <code>:a:</code></td></tr><tr><td style="text-align:left">🅱️ <code>:b:</code></td><td style="text-align:left">🆎 <code>:ab:</code></td><td style="text-align:left">🅾️ <code>:o2:</code></td></tr><tr><td style="text-align:left">💠 <code>:diamond_shape_with_a_dot_inside:</code></td><td style="text-align:left">♻️ <code>:recycle:</code></td><td style="text-align:left">🔚 <code>:end:</code></td></tr><tr><td style="text-align:left">🔛 <code>:on:</code></td><td style="text-align:left">🔜 <code>:soon:</code></td><td style="text-align:left">🕐 <code>:clock1:</code></td></tr><tr><td style="text-align:left">🕜 <code>:clock130:</code></td><td style="text-align:left">🕙 <code>:clock10:</code></td><td style="text-align:left">🕥 <code>:clock1030:</code></td></tr><tr><td style="text-align:left">🕚 <code>:clock11:</code></td><td style="text-align:left">🕦 <code>:clock1130:</code></td><td style="text-align:left">🕛 <code>:clock12:</code></td></tr><tr><td style="text-align:left">🕧 <code>:clock1230:</code></td><td style="text-align:left">🕑 <code>:clock2:</code></td><td style="text-align:left">🕝 <code>:clock230:</code></td></tr><tr><td style="text-align:left">🕒 <code>:clock3:</code></td><td style="text-align:left">🕞 <code>:clock330:</code></td><td style="text-align:left">🕓 <code>:clock4:</code></td></tr><tr><td style="text-align:left">🕟 <code>:clock430:</code></td><td style="text-align:left">🕔 <code>:clock5:</code></td><td style="text-align:left">🕠 <code>:clock530:</code></td></tr><tr><td style="text-align:left">🕕 <code>:clock6:</code></td><td style="text-align:left">🕡 <code>:clock630:</code></td><td style="text-align:left">🕖 <code>:clock7:</code></td></tr><tr><td style="text-align:left">🕢 <code>:clock730:</code></td><td style="text-align:left">🕗 <code>:clock8:</code></td><td style="text-align:left">🕣 <code>:clock830:</code></td></tr><tr><td style="text-align:left">🕘 <code>:clock9:</code></td><td style="text-align:left">🕤 <code>:clock930:</code></td><td style="text-align:left">💲 <code>:heavy_dollar_sign:</code></td></tr><tr><td style="text-align:left">©️ <code>:copyright:</code></td><td style="text-align:left">®️ <code>:registered:</code></td><td style="text-align:left">™️ <code>:tm:</code></td></tr><tr><td style="text-align:left">❌ <code>:x:</code></td><td style="text-align:left">❗️ <code>:heavy_exclamation_mark:</code></td><td style="text-align:left">‼️ <code>:bangbang:</code></td></tr><tr><td style="text-align:left">⁉️ <code>:interrobang:</code></td><td style="text-align:left">⭕️ <code>:o:</code></td><td style="text-align:left">✖️ <code>:heavy_multiplication_x:</code></td></tr><tr><td style="text-align:left">➕ <code>:heavy_plus_sign:</code></td><td style="text-align:left">➖ <code>:heavy_minus_sign:</code></td><td style="text-align:left">➗ <code>:heavy_division_sign:</code></td></tr><tr><td style="text-align:left">💮 <code>:white_flower:</code></td><td style="text-align:left">💯 <code>:100:</code></td><td style="text-align:left">✔️ <code>:heavy_check_mark:</code></td></tr><tr><td style="text-align:left">☑️ <code>:ballot_box_with_check:</code></td><td style="text-align:left">🔘 <code>:radio_button:</code></td><td style="text-align:left">🔗 <code>:link:</code></td></tr><tr><td style="text-align:left">➰ <code>:curly_loop:</code></td><td style="text-align:left">〰️ <code>:wavy_dash:</code></td><td style="text-align:left">〽️ <code>:part_alternation_mark:</code></td></tr><tr><td style="text-align:left">🔱 <code>:trident:</code></td><td style="text-align:left">:black_square: <code>:black_square:</code></td><td style="text-align:left">:white_square: <code>:white_square:</code></td></tr><tr><td style="text-align:left">✅ <code>:white_check_mark:</code></td><td style="text-align:left">🔲 <code>:black_square_button:</code></td><td style="text-align:left">🔳 <code>:white_square_button:</code></td></tr><tr><td style="text-align:left">⚫️ <code>:black_circle:</code></td><td style="text-align:left">⚪️ <code>:white_circle:</code></td><td style="text-align:left">🔴 <code>:red_circle:</code></td></tr><tr><td style="text-align:left">🔵 <code>:large_blue_circle:</code></td><td style="text-align:left">🔷 <code>:large_blue_diamond:</code></td><td style="text-align:left">🔶 <code>:large_orange_diamond:</code></td></tr><tr><td style="text-align:left">🔹 <code>:small_blue_diamond:</code></td><td style="text-align:left">🔸 <code>:small_orange_diamond:</code></td><td style="text-align:left">🔺 <code>:small_red_triangle:</code></td></tr><tr><td style="text-align:left">🔻 <code>:small_red_triangle_down:</code></td><td style="text-align:left">:shipit: <code>:shipit:</code></td><td style="text-align:left"></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;markdown-emoji&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#markdown-emoji&quot;&gt;&lt;/a&gt; markdown-emoji&lt;/h1&gt;
&lt;p&gt;Markdown语法支持添加 &lt;code&gt;emoji&lt;/code&gt; 表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情</summary>
    
    
    
    
    <category term="MarkDown" scheme="https://s-chance.github.io/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>MySQL高级</title>
    <link href="https://s-chance.github.io/2022/08/21/MySQL-Pro/"/>
    <id>https://s-chance.github.io/2022/08/21/MySQL-Pro/</id>
    <published>2022-08-21T05:09:02.000Z</published>
    <updated>2022-12-29T16:24:57.297Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mysql高级"><a class="markdownIt-Anchor" href="#mysql高级"></a> MySQL高级</h3><hr /><h4 id="一-distinct关键字"><a class="markdownIt-Anchor" href="#一-distinct关键字"></a> 一、distinct关键字</h4><p>distinct能够去除查询结果中重复的记录</p><p>注意：数据表中的数据并没有被修改，实际上所有的DQL查询语句都不会修改原始数据，只是对查询结果进行处理 <span id="more"></span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 准备工作</span><br><span class="line">create database if not exists task;</span><br><span class="line">use task;</span><br><span class="line">create table emp (</span><br><span class="line">id int,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    age int,</span><br><span class="line">    sex char(20),</span><br><span class="line">    salary double</span><br><span class="line">);</span><br><span class="line">alter table emp modify sex char(20) character set gbk;</span><br><span class="line">insert into emp values</span><br><span class="line">(1,&#x27;a&#x27;,19,&#x27;男&#x27;,3500),</span><br><span class="line">(2,&#x27;b&#x27;,22,&#x27;男&#x27;,5600),</span><br><span class="line">(3,&#x27;c&#x27;,34,&#x27;女&#x27;,7700),</span><br><span class="line">(4,&#x27;d&#x27;,16,&#x27;男&#x27;,4300),</span><br><span class="line">(5,&#x27;e&#x27;,51,&#x27;女&#x27;,4300),</span><br><span class="line">(6,&#x27;f&#x27;,23,&#x27;女&#x27;,4300);</span><br><span class="line"></span><br><span class="line"># 格式: select distinct 字段名 from 数据表名;</span><br><span class="line"># distinct关键字写在所有字段前面</span><br><span class="line"># 查询salary的值有哪几种情况,不重复列出相同的情况</span><br><span class="line">select distinct salary from emp;</span><br><span class="line"># 对于多个字段,则需要在多个字段的值均重复的条件下才会去重</span><br><span class="line"># 查询数据表中存在的不重复的sex和salary的组合有哪几种情况</span><br><span class="line">select distinct salary,sex from emp;</span><br></pre></td></tr></table></figure><h4 id="二-连接查询"><a class="markdownIt-Anchor" href="#二-连接查询"></a> 二、连接查询</h4><h5 id="连接查询的概念"><a class="markdownIt-Anchor" href="#连接查询的概念"></a> 连接查询的概念</h5><p>针对一张数据表进行查询，称为单表查询。<strong>join关键字</strong></p><p>将两张及以上的数据表联合起来进行查询，获取到多张数据表组合出来的数据，称为连接查询。</p><h5 id="连接查询的分类"><a class="markdownIt-Anchor" href="#连接查询的分类"></a> 连接查询的分类</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据表连接的方式分类</span><br><span class="line">├── 内连接</span><br><span class="line">│   ├── 等值连接</span><br><span class="line">│   ├── 非等值连接</span><br><span class="line">│   └── 自连接</span><br><span class="line">|</span><br><span class="line">├── 外连接</span><br><span class="line">│   ├── 左外连接</span><br><span class="line">│   └── 右外连接</span><br></pre></td></tr></table></figure><h5 id="笛卡尔积现象"><a class="markdownIt-Anchor" href="#笛卡尔积现象"></a> 笛卡尔积现象</h5><p>一般是由于没有加任何限制条件直接联合多张表进行查询。查询结果的数量是多张表的乘积，但一般这样的查询没有太大意义，要避免这种情况需要设计好限制条件。</p><h5 id="内连接"><a class="markdownIt-Anchor" href="#内连接"></a> 内连接</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 准备数据</span><br><span class="line">create database if not exists data;</span><br><span class="line">use data;</span><br><span class="line">create table employee(</span><br><span class="line">id int,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    salary double,</span><br><span class="line">    department_id int</span><br><span class="line">);</span><br><span class="line">insert into employee values</span><br><span class="line">(1,&#x27;apple&#x27;,5469,101),</span><br><span class="line">(2,&#x27;grape&#x27;,4465,101),</span><br><span class="line">(3,&#x27;orange&#x27;,6544,102),</span><br><span class="line">(4,&#x27;mango&#x27;,4987,102),</span><br><span class="line">(5,&#x27;banana&#x27;,5323,102),</span><br><span class="line">(6,&#x27;peach&#x27;,6743,103);</span><br><span class="line">create table department(</span><br><span class="line">id int,</span><br><span class="line">    name varchar(20)</span><br><span class="line">);</span><br><span class="line">insert into department values</span><br><span class="line">(101,&#x27;develop&#x27;),</span><br><span class="line">(102,&#x27;operate&#x27;),</span><br><span class="line">(103,&#x27;loaf&#x27;);</span><br><span class="line">create table salary_level(</span><br><span class="line">grade varchar(20),</span><br><span class="line">    min int,</span><br><span class="line">    max int</span><br><span class="line">);</span><br><span class="line">insert into salary_level values</span><br><span class="line">(&#x27;A&#x27;,5501,7000),</span><br><span class="line">(&#x27;B&#x27;,4001,5500),</span><br><span class="line">(&#x27;C&#x27;,2500,4000);</span><br><span class="line"># 等值连接,where后的条件是等值判断</span><br><span class="line"># 查询enployee表中每条记录所对应的department的name</span><br><span class="line"># join前加inner关键字能直接表明这是内连接,当然inner本身可以省略不写</span><br><span class="line"># on关键字类似于where,但on是表示多表的连接条件,而where是表示对连接结果进一步筛选的条件,where写在on的后面</span><br><span class="line">select e.name,d.name from employee e join department d on e.department_id=d.id;</span><br><span class="line"></span><br><span class="line"># 非等值连接,where后的条件一般是在某个范围内判断</span><br><span class="line"># 查询employee表中每条记录所对应的salary_level的grade</span><br><span class="line">select e.name,e.salary,s.grade from employee e inner join salary_level s on e.salary between s.min and s.max;</span><br><span class="line"></span><br><span class="line"># 自连接,本质上是一张表,但进行了重复使用</span><br><span class="line"># 新增数据</span><br><span class="line">insert into employee (id,name) values</span><br><span class="line">(101,&#x27;leader_jackson&#x27;),</span><br><span class="line">(102,&#x27;leader_vim&#x27;),</span><br><span class="line">(103,&#x27;leader_fish&#x27;);</span><br><span class="line"># 查询employee表中department_id对应leader_name和name记录</span><br><span class="line">select e1.name &#x27;emp&#x27;,e2.name &#x27;leader&#x27; from employee e1 join employee e2 on e1.department_id=e2.id;</span><br><span class="line"># 一般需要使用自连接查询的话,说明表的设计还能进一步优化</span><br></pre></td></tr></table></figure><h5 id="外连接"><a class="markdownIt-Anchor" href="#外连接"></a> 外连接</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 内连接的多张表并没有主次关系,也就是说不需要考虑查询语句书写的先后顺序</span><br><span class="line"># 外连接分左外连接left join和右外连接right join,left或right关键字不可省略,表示将join关键字左右的数据表视为主表,当然也可以通过调整语句书写的先后顺序改变主次关系</span><br><span class="line"># 主表指定的数据会全部被查询,在此基础上再查询部分相关的次表的数据,也就是说指定查询的主表数据不会因为on的连接条件而有所缺失,但会受到where筛选条件的影响</span><br><span class="line"></span><br><span class="line"># 以employee为主表查询所有记录数</span><br><span class="line">select * from employee e left join department d on e.department_id=d.id;</span><br><span class="line"># 以department为主表查询所有记录数</span><br><span class="line">select * from employee e right join department d on e.department_id=d.id;</span><br><span class="line"></span><br><span class="line"># 通过对比相同的数据表在内外连接两种情况下的不同查询结果,可以找到主表中还未与次表建立逻辑关系的单独的数据</span><br></pre></td></tr></table></figure><h5 id="更多表连接三张表"><a class="markdownIt-Anchor" href="#更多表连接三张表"></a> 更多表连接（三张表）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 三张及以上数据表连接查询,多个连接条件一般都与第一张表相关联,内外连接可以混合使用</span><br><span class="line"># 查询employee、department、salary_level的联合数据</span><br><span class="line"># 查询employee中department_id对应的department表数据,salary对应的salary_level表数据</span><br><span class="line">select e.name,e.salary,d.name,s.grade from employee e join department d on e.department_id=d.id join salary_level s on e.salary between s.min and s.max;</span><br></pre></td></tr></table></figure><h4 id="三-子查询"><a class="markdownIt-Anchor" href="#三-子查询"></a> 三、子查询</h4><h5 id="子查询的概念"><a class="markdownIt-Anchor" href="#子查询的概念"></a> 子查询的概念</h5><p>DQL语句中嵌套DQL语句，被嵌套的DQL语句称为子查询。</p><h5 id="子查询的使用"><a class="markdownIt-Anchor" href="#子查询的使用"></a> 子查询的使用</h5><p>子查询可写在<strong>select</strong>、<strong>from</strong>、<strong>where</strong>关键字后面。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># where子句中的子查询,一般子查询结果是某个值</span><br><span class="line"># 查询employee表中大于平均值的salary记录,先查询出avg(salary)的值</span><br><span class="line">select salary from employee where salary&gt;(select avg(salary) from employee);</span><br><span class="line"></span><br><span class="line"># from子句中的子查询,把子查询结果视为一张新的数据表</span><br><span class="line"># 查询employee表中每个department_id对应的avg(salary)的grade,先查询出每个department_id的avg(salary)</span><br><span class="line">select e.*,s.grade from (select department_id,avg(salary) avg from employee group by department_id) e join salary_level s on avg between s.min and s.max;</span><br><span class="line"></span><br><span class="line"># select后的子查询,一般不经常使用,了解即可</span><br><span class="line"># 该子查询只能返回一条记录</span><br><span class="line">select e.name,e.salary,(select avg(salary) from employee) avg from employee e;</span><br></pre></td></tr></table></figure><h4 id="四-union关键字"><a class="markdownIt-Anchor" href="#四-union关键字"></a> 四、union关键字</h4><p><strong>union关键字</strong>能合并结果集，将多表查询的结果直接拼接起来，但多张表必须保持字段数一致。字段值在没有特殊逻辑关系下也要对应起来。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># union和join</span><br><span class="line"># 将employee中salary大于5000的结果集和department_id为101的结果集合并起来,会自动去重</span><br><span class="line">select name from employee where salary &gt; 5000 union select name from employee where department_id=101;</span><br><span class="line"></span><br><span class="line"># 关于union和or关键字的区别</span><br><span class="line"># union能够实现多表查询(前提多张表的字段能够对应),而or只能在一张表里使用</span><br><span class="line"># union会自动去重,or不会去重而是直接取查询结果的并集(实际大部分情况下两者结果区别不大)</span><br><span class="line"># union能够使用不同的索引查询,索引即where后面所用到的字段,而or因为是针对一张表所以只能使用一个索引,一个where后仅能有一个索引,有多个字段时取其一作为索引</span><br><span class="line"></span><br><span class="line"># 一般情况下,数据量较大时(包括单表的数据量和数据表的数量)推荐使用union,多个查询条件涉及到的是同一个字段时推荐使用or</span><br></pre></td></tr></table></figure><h4 id="五-limit关键字"><a class="markdownIt-Anchor" href="#五-limit关键字"></a> 五、limit关键字</h4><h5 id="limit的作用"><a class="markdownIt-Anchor" href="#limit的作用"></a> limit的作用</h5><p>将结果集的部分数据展示出来，常用于网页开发分页查询中</p><h5 id="关键字执行优先级"><a class="markdownIt-Anchor" href="#关键字执行优先级"></a> 关键字执行优先级</h5><p>执行优先级：from→where→group by→having→select→order by→<strong>limit</strong></p><h5 id="limit的使用"><a class="markdownIt-Anchor" href="#limit的使用"></a> limit的使用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 格式:limit 开始下标(缺省的话,默认从0开始),长度(即数据条数)</span><br><span class="line"># 查询employee表前2条数据</span><br><span class="line">select * from employee limit 2; # 简写,实际上是limit 0,2;</span><br><span class="line">select * from employee limit 0,2;</span><br><span class="line"># 查询employee表第2-4条数据,下标从1开始起的3条数据</span><br><span class="line">select * from employee limit 1,3;</span><br><span class="line"></span><br><span class="line"># limit在order by之后执行,所以order by的依据和排序方式会一定程度上影响limit的结果集</span><br><span class="line"># 查询以name升序排序之后的结果集的前2条数据</span><br><span class="line">select * from employee order by name asc limit 2;</span><br><span class="line"># 查询以salary降序排序之后的结果集的前2条数据</span><br><span class="line">select * from employee order by salary desc limit 2;</span><br><span class="line"></span><br><span class="line"># 分页查询的公式:limit (pageNum-1)*pageSize,pageSize</span><br></pre></td></tr></table></figure><h4 id="六-约束"><a class="markdownIt-Anchor" href="#六-约束"></a> 六、约束</h4><h5 id="约束的概念"><a class="markdownIt-Anchor" href="#约束的概念"></a> 约束的概念</h5><p>约束（constraint）是用于保证数据完整性、有效性的一种规则。</p><h5 id="多种约束规则"><a class="markdownIt-Anchor" href="#多种约束规则"></a> 多种约束规则</h5><p>非空：not null</p><p>唯一：unique</p><p>主键：primary key（PK）</p><p>外键：foreign key（FK）</p><p>检查：check（MySQL不支持，Oracle支持）</p><h5 id="约束的使用"><a class="markdownIt-Anchor" href="#约束的使用"></a> 约束的使用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 非空 not null</span><br><span class="line"># 非空约束的字段不能为null</span><br><span class="line">drop table if exists con;</span><br><span class="line">create table con(</span><br><span class="line">id int,</span><br><span class="line">    name varchar(20) not null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into con(id,name) values (1,&#x27;a&#x27;);</span><br><span class="line">insert into con(id,name) values (2,null); # 出错,name不能为null</span><br><span class="line">insert into con(id) values (3); # 出错,name没有默认值</span><br><span class="line"></span><br><span class="line"># 唯一性 unique</span><br><span class="line"># 唯一性约束的字段不能重复</span><br><span class="line">drop table if exists con;</span><br><span class="line">create table con(</span><br><span class="line">id int,</span><br><span class="line">    name varchar(20) unique</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into con(id,name) values (1,&#x27;a&#x27;);</span><br><span class="line">insert into con(id,name) values (2,&#x27;a&#x27;); # name不能出现重复的值</span><br><span class="line">insert into con(id) values (3,null); # name可以为null,且null不属于值重复</span><br><span class="line"></span><br><span class="line"># 多字段各自唯一(列级约束,每个约束仅对单个字段有效)</span><br><span class="line"># name不能重复且email也不能重复</span><br><span class="line">drop table if exists con;</span><br><span class="line">create table con(</span><br><span class="line">id int,</span><br><span class="line">    name varchar(20) unique,</span><br><span class="line">    email varchar(20) unique</span><br><span class="line">);</span><br><span class="line"># 测试数据可以直接用下面的</span><br><span class="line"></span><br><span class="line"># 多字段组合唯一(表级约束,每个约束对整张表有效,多用于给多个字段添加联合约束)</span><br><span class="line"># name和email的组合不能重复</span><br><span class="line">drop table if exists con;</span><br><span class="line">create table con(</span><br><span class="line">id int,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    email varchar(20),</span><br><span class="line">    unique(name,email)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into con(id,name,email) values (1,&#x27;a&#x27;,&#x27;a@123.com&#x27;);</span><br><span class="line">insert into con(id,name,email) values (2,&#x27;a&#x27;,&#x27;a@456.com&#x27;);</span><br><span class="line">insert into con(id,name,email) values (3,&#x27;b&#x27;,&#x27;b@123.com&#x27;);</span><br><span class="line">insert into con(id,name,email) values (4,&#x27;a&#x27;,&#x27;a@456.com&#x27;);</span><br><span class="line"></span><br><span class="line"># not null和unique联合</span><br><span class="line">drop table if exists con;</span><br><span class="line">create table con(</span><br><span class="line">id int,</span><br><span class="line">    name varchar(20) not null unique</span><br><span class="line">);</span><br><span class="line">desc con;</span><br><span class="line">insert into con(id,name) values (1,&#x27;abc&#x27;);</span><br><span class="line">insert into con(id,name) values (2,&#x27;abc&#x27;); # 出错,name不能重复</span><br><span class="line">insert into con(id,name) values (3,null); # 出错,name不能为null</span><br><span class="line"></span><br><span class="line"># 主键 primary key</span><br><span class="line"># 主键字段不能重复且不能为null,类似于unique联合not null但不完全相同</span><br><span class="line"># 根据设计规范,一张表应该存在且只能存在一个主键,主键通常是int、bigint、char等类型的字段,不建议使用varchar类型字段作为主键</span><br><span class="line"># 单一主键,列级约束,一般开发中经常使用</span><br><span class="line">drop table if exists con;</span><br><span class="line">create table con(</span><br><span class="line">id int primary key,</span><br><span class="line">    name varchar(20)</span><br><span class="line">);</span><br><span class="line">desc con;</span><br><span class="line"># 测试数据可以直接用下面的</span><br><span class="line"></span><br><span class="line"># 复合主键,表级约束,由于复合主键涉及多字段,逻辑比较复杂,一般开发中不会使用</span><br><span class="line">drop table if exists con;</span><br><span class="line">create table con(</span><br><span class="line">id int,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    primary key(id,name)</span><br><span class="line">);</span><br><span class="line">desc con;</span><br><span class="line"></span><br><span class="line">insert into con(id,name) values (1,&#x27;a&#x27;);</span><br><span class="line">insert into con(id,name) values (1,&#x27;a&#x27;); </span><br><span class="line">insert into con(id,name) values (1,&#x27;b&#x27;); </span><br><span class="line">insert into con(id,name) values (2,&#x27;a&#x27;); </span><br><span class="line">insert into con(id,name) values (3,null);</span><br><span class="line">insert into con(name) values (null,&#x27;a&#x27;);</span><br><span class="line"></span><br><span class="line"># 主键自动递增,这里主键值默认从1开始,按1递增</span><br><span class="line"># 如果insert中途指定了主键值,则从该主键值开始按1递增,如果指定了较小的主键值,会自动升序排序</span><br><span class="line">drop table if exists con;</span><br><span class="line">create table con( </span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">    name varchar(20)</span><br><span class="line">);</span><br><span class="line">desc con;</span><br><span class="line">insert into con(name) values (&#x27;a&#x27;);</span><br><span class="line">insert into con(name) values (&#x27;b&#x27;);</span><br><span class="line">insert into con(name) values (&#x27;c&#x27;);</span><br><span class="line"># 此外,主键还能分为自然主键和业务主键,自然主键使用较多,业务主键较少</span><br><span class="line"></span><br><span class="line"># 外键 foreign key</span><br><span class="line"># 外键涉及到两张相互有逻辑关系的数据表,主要是为了保证两张表的逻辑关系有效</span><br><span class="line"># 外键关联的两张表有父表和子表之分</span><br><span class="line"># 删除数据时先子表后父表,新增数据时先父表后子表,删除表时先子表后父表,创建表时先父表后子表</span><br><span class="line">drop table if exists son;</span><br><span class="line">drop table if exists dad;</span><br><span class="line">create table dad(</span><br><span class="line">no int primary key,</span><br><span class="line">    name varchar(20)</span><br><span class="line">);</span><br><span class="line">create table son(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    dad_no int,</span><br><span class="line">    foreign key(dad_no) references dad(no)</span><br><span class="line">);</span><br><span class="line">insert into dad(no,name) values (001,&#x27;fruit&#x27;);</span><br><span class="line">insert into dad(no,name) values (002,&#x27;animal&#x27;);</span><br><span class="line"></span><br><span class="line">insert into son(name,dad_no) values (&#x27;apple&#x27;,001);</span><br><span class="line">insert into son(name,dad_no) values (&#x27;pear&#x27;,001);</span><br><span class="line">insert into son(name,dad_no) values (&#x27;cat&#x27;,002);</span><br><span class="line">insert into son(name,dad_no) values (&#x27;rabbit&#x27;,002);</span><br><span class="line"># 另外被子表references的父表字段不一定是主键,但至少具有unique的约束</span><br></pre></td></tr></table></figure><h4 id="七-存储引擎"><a class="markdownIt-Anchor" href="#七-存储引擎"></a> 七、存储引擎</h4><h5 id="存储引擎的概念"><a class="markdownIt-Anchor" href="#存储引擎的概念"></a> 存储引擎的概念</h5><p>存储引擎是MySQL中特有的术语，表示一个数据表存储、组织数据的方式。不同的存储引擎，数据表存储数据的方式不同。</p><h5 id="存储引擎的使用"><a class="markdownIt-Anchor" href="#存储引擎的使用"></a> 存储引擎的使用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 准备工作</span><br><span class="line">drop table if exists engine;</span><br><span class="line">create table if not exists engine(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">    name varchar(20)</span><br><span class="line">);</span><br><span class="line"># 查看存储引擎,MySQL默认存储引擎为InnoDB</span><br><span class="line">show create table engine;</span><br><span class="line"></span><br><span class="line"># 在创建表时指定存储引擎</span><br><span class="line">drop table if exists engine;</span><br><span class="line">create table engine(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">    name varchar(20)</span><br><span class="line">)engine=innodb default charset=gbk;</span><br><span class="line">show create table engine;</span><br><span class="line"></span><br><span class="line"># 查看MySQL版本</span><br><span class="line">select version();</span><br><span class="line"># 查看支持的存储引擎,不同的MySQL版本支持的存储引擎可能不一样</span><br><span class="line">show engines;</span><br></pre></td></tr></table></figure><h5 id="常用存储引擎介绍"><a class="markdownIt-Anchor" href="#常用存储引擎介绍"></a> 常用存储引擎介绍</h5><h6 id="myisam存储引擎"><a class="markdownIt-Anchor" href="#myisam存储引擎"></a> MyISAM存储引擎</h6><p>使用三种文件来表示每个数据表：</p><ul><li>格式文件(.frm)：存储表结构的定义</li><li>数据文件(.myd)：存储表行的内容</li><li>索引文件(.myi)：存储表上索引（主键或unique约束字段会自动创建索引）</li></ul><p>特点：可以被转换为压缩，只读表里节省空间，但不支持事务，安全性低</p><h6 id="innodb存储引擎"><a class="markdownIt-Anchor" href="#innodb存储引擎"></a> InnoDB存储引擎</h6><p><strong>一般开发中最优先考虑的存储引擎</strong>，重量级的存储引擎，管理的数据表有以下特征：</p><ul><li>每个数据表在数据库目录中以.frm格式的文件表示</li><li>提供一组用于记录事务性获得的日志文件</li><li>通过commit、savepoint和rollback支持事务处理</li><li>提供全ACID兼容</li><li>在MySQL服务器崩溃后能够自动恢复</li><li>多版本MVCC和行级锁定</li><li>支持外键级引用的完整性，包括级联删除和更新</li></ul><p>特点：支持事务，以保证数据的安全性，但效率不高，不能压缩不能转换为只读，比较占存储空间</p><h6 id="memory存储引擎"><a class="markdownIt-Anchor" href="#memory存储引擎"></a> MEMORY存储引擎</h6><p>MEMORY存储引擎以前称为heap存储引擎，管理数据库有以下特征：</p><ul><li>在数据库目录内，每个数据表均以.frm格式的文件表示</li><li>表的数据以及索引被存储在内存中（这显著提升了查询速度）</li><li>表级锁机制</li><li>不支持text和blob字段</li></ul><p>特点：字段长度固定，数据存储在内存，这使得它的数据处理效率非常高，但同时一旦MySQL服务重启，存储数据就会丢失，<strong>一般开发中只用于临时存储数据</strong>。</p><h4 id="八-事务-视图-数据库设计"><a class="markdownIt-Anchor" href="#八-事务-视图-数据库设计"></a> 八、事务、视图、数据库设计</h4><h5 id="事务transaction"><a class="markdownIt-Anchor" href="#事务transaction"></a> 事务(transaction)</h5><ol><li><p>事务的概念：一个事务就是一个完整的业务逻辑，是一个不可再分的最小的工作单元。例如，银行转账，A向B转账1000，A扣除1000，B增加1000。可以用两个update语句实现，但它们必须同时成功或者失败，而不能单独拆分，否则就不构成一个完整的业务逻辑，这就是一个最小的工作单元。</p></li><li><p>只有在使用DML语句时才会涉及到事务，因为只有DML语句会增加、删除、修改数据表的数据，这就离不开事务安全性的考虑。</p></li><li><p>简单理解事务：就是要使多条DML语句同时成功或失败的一种规则。</p></li><li><p>如何实现事务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># InnoDB存储引擎提供了一组用来记录事务性活动的日志文件</span><br><span class="line"># 在事务的执行过程中,每一条DML的操作都会记录到“事务性活动的日志文件”中</span><br><span class="line"># 在事务的执行过程通过提交事务或者回滚事务就能实现事务要求的规则</span><br><span class="line"></span><br><span class="line"># MySQL默认是自动提交事务,即每执行一条DML语句就提交一次,但这不符合开发习惯</span><br><span class="line"># 关闭自动提交机制 start transaction(仅对一次事务有效)</span><br><span class="line"># 或者直接设置开启或关闭自动提交(对所有事务有效)</span><br><span class="line">set autocommit=0; # 关闭自动提交</span><br><span class="line">set autocommit=1; # 开启自动提交</span><br><span class="line"># 提交事务commit,回滚事务rollback</span><br><span class="line"># 准备工作</span><br><span class="line">drop table if exists test;</span><br><span class="line">create table test(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">    name varchar(20)</span><br><span class="line">);</span><br><span class="line">select * from test;</span><br><span class="line"></span><br><span class="line">start transaction; # 关闭自动提交机制,commit之后需要重新执行</span><br><span class="line">insert into test(name) values (&#x27;a&#x27;);</span><br><span class="line">insert into test(name) values (&#x27;b&#x27;);</span><br><span class="line">insert into test(name) values (&#x27;c&#x27;);</span><br><span class="line">select * from test;</span><br><span class="line"></span><br><span class="line">rollback; # 回滚事务</span><br><span class="line">select * from test; # 未提交的事务消失</span><br><span class="line"></span><br><span class="line">insert into test(name) values (&#x27;d&#x27;);</span><br><span class="line">commit; # 提交事务</span><br><span class="line">select * from test;</span><br><span class="line"></span><br><span class="line">rollback;</span><br><span class="line">select * from test; # 已经提交的事务,无法回滚</span><br></pre></td></tr></table></figure></li><li><p>事务的4个特性（ACID）</p><p>A：原子性，事务是最小的工作单元，不可再分。</p><p>C：一致性，在同一个事务中，所有操作必须同时成功或者失败，保证数据的一致性。</p><p>I：隔离性，A事务与B事务之间存在一定的隔离，根据隔离性可分成4个隔离级别。</p><ul><li><p>读未提交：read uncommitted（隔离级别最低）</p><p>事务A能够读取事务B<strong>未提交的数据</strong>，这种隔离级别存在读取到脏数据的问题，即读取到并不需要的数据。一般开发中不会使用这个隔离级别。</p></li><li><p>读已提交：read committed</p><p>事务A只能读取事务B<strong>已提交的数据</strong>，这种隔离级别避免了脏读问题，但存在不可重复读取数据的问题，事务B再做任何提交操作之后，事务A读取的数据就会相应地发生改变。读取的数据是比较真实的数据，这是<strong>Oracle数据库默认的隔离级别</strong>。</p></li><li><p>可重复读：repeatable read</p><p>事务B开启后，每次从事务B读取的数据都是一致的，即使事务B的数据修改并提交，事务A所<strong>读取到的数据都是事务B刚开始事务时的数据</strong>。这种隔离级别避免了不可重复读的问题，但出现了幻影读的问题，即每次读取到的数据都不是当前的真实数据，这是<strong>MySQL默认的隔离级别</strong>。</p></li><li><p>序列化/串行化：serializable（最高隔离级别）</p><p>效率最低，但解决了上面存在的所有问题。这种隔离级别的事务需要排队，不能并发。synchronized线程同步（事务同步），每次读取到的数据都是最真实的，效率也是最低的。</p></li></ul><p>D：持久性，事务完成的保障，事务提交之后，数据就被持久地保存下来。</p></li><li><p>隔离级别验证</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在同一个命令行或同一个查询下可能无法展示出隔离级别的效果,建议事务A和事务B各打开一个命令行或者在navicat下各新建一个查询</span><br><span class="line"># 建议每次重新设置隔离级别之后重启命令行或navicat刷新</span><br><span class="line"># 查看隔离级别</span><br><span class="line">select @@tx_isolation;</span><br><span class="line"></span><br><span class="line"># 准备工作</span><br><span class="line">create table isolation_level(</span><br><span class="line">name varchar(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># read uncommitted 读未提交</span><br><span class="line"># 设置全局隔离级别为read uncommitted</span><br><span class="line">set global transaction isolation level read uncommitted;</span><br><span class="line"># 事务A</span><br><span class="line">start transaction;</span><br><span class="line">select * from isolation_level;</span><br><span class="line"># 事务B</span><br><span class="line">start transaction;</span><br><span class="line">insert into isolation_level values (&#x27;hello&#x27;);</span><br><span class="line"># 事务A</span><br><span class="line">select * from isolation_level; # 读取到了未提交的数据</span><br><span class="line"></span><br><span class="line"># read committed 读已提交</span><br><span class="line"># 设置全局隔离级别为read committed</span><br><span class="line">set global transaction isolation level read committed;</span><br><span class="line"># 事务A</span><br><span class="line">start transaction;</span><br><span class="line">select * from isolation_level;</span><br><span class="line"># 事务B</span><br><span class="line">start transaction;</span><br><span class="line">insert into isolation_level values (&#x27;world&#x27;);</span><br><span class="line"># 事务A</span><br><span class="line">select * from isolation_level; # 未读取到事务B的数据</span><br><span class="line"># 事务B</span><br><span class="line">commit;</span><br><span class="line"># 事务A</span><br><span class="line">select * from isolation_level; # 读取到了事务B提交的数据</span><br><span class="line"></span><br><span class="line"># repeatable read 可重复读</span><br><span class="line"># 设置全局隔离级别为repeatable read</span><br><span class="line">set global transaction isolation level repeatable read;</span><br><span class="line"># 事务A</span><br><span class="line">start transaction;</span><br><span class="line">select * from isolation_level;</span><br><span class="line"># 事务B</span><br><span class="line">start transaction; # 第一次开启事务</span><br><span class="line">insert into isolation_level values (&#x27;read&#x27;);</span><br><span class="line"># 事务A</span><br><span class="line">select * from isolation_level;</span><br><span class="line"># 事务B</span><br><span class="line">insert into isolation_level values (&#x27;repeat&#x27;);</span><br><span class="line"># 事务A</span><br><span class="line">select * from isolation_level;</span><br><span class="line"># 事务B</span><br><span class="line">commit;</span><br><span class="line"># 事务A</span><br><span class="line">select * from isolation_level; # 事务A读取到的始终是事务B第一次开启事务时的数据</span><br><span class="line"># 事务A</span><br><span class="line">commit;</span><br><span class="line">select * from isolation_level; # 事务A也提交后再查询,就能获取事务B的最近一次事务提交的数据</span><br><span class="line"># 补充说明:事务B第一次开启事务这个概念是以事务A开启事务后事务B第一次执行start transaction为准,也就是当事务A提交之后再次开启事务,重新计算事务B第一次开启事务</span><br><span class="line"></span><br><span class="line"># serializable 序列化</span><br><span class="line"># 设置全局隔离级别为serializable</span><br><span class="line">set global transaction isolation level serializable;</span><br><span class="line"># 事务A</span><br><span class="line">start transaction;</span><br><span class="line">select * from isolation_level;</span><br><span class="line"># 事务B</span><br><span class="line">start transaction;</span><br><span class="line">insert into isolation_level values (&#x27;serializable&#x27;); # 卡住,因为事务A没有提交</span><br><span class="line"># 事务A</span><br><span class="line">commit; # 提交事务A后事务B新增数据完成</span><br><span class="line">start transaction; # 事务A重新开启事务</span><br><span class="line">select * from isolation_level; # 卡住或超时报错,因为事务B没有提交</span><br><span class="line"># 事务B</span><br><span class="line">commit; # 提交事务B后事务A查询完成视图</span><br></pre></td></tr></table></figure></li></ol><h5 id="视图view"><a class="markdownIt-Anchor" href="#视图view"></a> 视图(view)</h5><ol><li><p>视图的概念</p><p>从多个角度观察处理同一份数据，每一个角度就是一种视图。  例如，对同一份数据进行不同的处理，根据不同的需求展示出相应部分的数据或者根据不同的权限展示出每个权限被允许接触到的数据。</p></li><li><p>视图的使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 准备工作</span><br><span class="line">drop table if exists origin;</span><br><span class="line">create table origin(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    age int,</span><br><span class="line">    department varchar(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into origin(name,age,department) values</span><br><span class="line">(&#x27;apple&#x27;,13,&#x27;developer&#x27;),</span><br><span class="line">(&#x27;orange&#x27;,14,&#x27;operator&#x27;);</span><br><span class="line"># 先备份原表,复制原表</span><br><span class="line">create table origin_backup select * from origin;</span><br><span class="line"></span><br><span class="line"># 创建视图对象,需要as关键字,且只能通过DQL语句创建</span><br><span class="line">create view origin_view as select * from origin;</span><br><span class="line"># 删除视图对象</span><br><span class="line">drop view origin_view;</span><br><span class="line"></span><br><span class="line"># 对视图对象的增删改查会映射到原表的数据上</span><br><span class="line"># 查询视图</span><br><span class="line">select * from origin_view;</span><br><span class="line"># 新增视图数据</span><br><span class="line">insert into origin_view(name,age,department) values</span><br><span class="line">(&#x27;mango&#x27;,12,&#x27;manager&#x27;),</span><br><span class="line">(&#x27;banana&#x27;,16,&#x27;admin&#x27;);</span><br><span class="line"># 查询原表</span><br><span class="line">select * from origin;</span><br><span class="line"># 更新视图数据</span><br><span class="line">update origin_view set age=20 where name=&#x27;mango&#x27;;</span><br><span class="line">select * from origin;</span><br><span class="line"># 删除视图数据</span><br><span class="line">delete from origin_view;</span><br><span class="line">select * from origin;</span><br></pre></td></tr></table></figure></li><li><p>视图对象的实际开发用途</p><ul><li>视图的使用能够有效简化开发，方便维护，提高开发效率</li><li>单独的SQL语句只能针对一张数据表的数据进行修改，而视图的使用将多张表的数据集中到一个视图，通过对这个视图数据的修改，就能一次性实现对多张表数据的修改，而不需要每一张数据表重复写一条SQL语句去修改</li><li>另外对于后期大量数据表的维护，只需要重新修改视图对象所映射的DQL语句就能灵活地指定需要维护的数据表的数据</li></ul></li></ol><h5 id="数据库设计三大范式"><a class="markdownIt-Anchor" href="#数据库设计三大范式"></a> 数据库设计：三大范式</h5><h6 id="三大范式的概念"><a class="markdownIt-Anchor" href="#三大范式的概念"></a> 三大范式的概念</h6><p>范式是数据库数据表的设计依据，是一种规范和统一标准。设计数据库表时，按照以下3种范式进行，可以避免表中数据的冗余，空间的浪费。</p><h6 id="第一范式"><a class="markdownIt-Anchor" href="#第一范式"></a> 第一范式</h6><p>第一范式：要求任何一张表必须有主键，每一个字段原子性不可再分。</p><p>字段原子性是指字段数据不能再拆分，例如，联系方式字段下的数据同时出现手机号和邮箱两个联系方式，说明联系方式字段还能拆分未手机号和邮箱两个字段。</p><h6 id="第二范式"><a class="markdownIt-Anchor" href="#第二范式"></a> 第二范式</h6><p>第二范式：建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，<br />不要产生部分依赖。</p><p>部分依赖通常出现在多对多逻辑关系(例如多个学生对应多个教师)的数据表中，假设把学生编号和教师编号设置为复合主键，学生依赖学生编号，教师依赖教师编号，这就产生了部分依赖(<strong>部分依赖产生的根源就是复合主键的存在，因此设计中一般不建议使用复合主键</strong>)。从根本上解决这个问题，就需要将这一张数据表分成学生表，教师表以及关系表三张数据表，并在关系表中设置学生表和教师表两个外键。</p><h6 id="第三范式"><a class="markdownIt-Anchor" href="#第三范式"></a> 第三范式</h6><p>第三范式：建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，<br />不要产生传递依赖。</p><p>传递依赖通常出现在一对多逻辑关系(例如一个班级对应多个学生)的数据表中，假设学生编号为主键，班级名称依赖班级编号，而一个班级编号依赖多个学生编号，这就产生了传递依赖。为了解决这个问题，就需要将这一张数据表分成学生表和班级表，外键则设置在数据相对较多的数据表中。</p><h6 id="数据表设计总结"><a class="markdownIt-Anchor" href="#数据表设计总结"></a> 数据表设计总结</h6><ul><li><p>一对多，两张表，数据多的加外键</p></li><li><p>多对多，三张表，关系表两个外键</p></li><li><p>另外对于一对一逻辑关系的数据表，如果字段数过多也建议进行表的拆分。一般拆分成两张表，这时只需要在其中一张表中添加一个唯一性约束(一对一逻辑关系的数据表理论上不可能出现重复的外键字段值)的外键字段即可，外键字段通常链接的是另一张表的主键字段。</p></li></ul><p>最后，数据库设计三大范式也只是理想上的标准。实际开发中，结合实际需求，有必要牺牲一部分存储空间、规范等来换取更高的开发效率和更好的使用体验，这才是数据库数据表设计的最高目的。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;mysql高级&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mysql高级&quot;&gt;&lt;/a&gt; MySQL高级&lt;/h3&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;一-distinct关键字&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-distinct关键字&quot;&gt;&lt;/a&gt; 一、distinct关键字&lt;/h4&gt;
&lt;p&gt;distinct能够去除查询结果中重复的记录&lt;/p&gt;
&lt;p&gt;注意：数据表中的数据并没有被修改，实际上所有的DQL查询语句都不会修改原始数据，只是对查询结果进行处理</summary>
    
    
    
    <category term="MySQL5" scheme="https://s-chance.github.io/categories/MySQL5/"/>
    
    
    <category term="MySQL" scheme="https://s-chance.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础</title>
    <link href="https://s-chance.github.io/2022/08/21/MySQL-Base/"/>
    <id>https://s-chance.github.io/2022/08/21/MySQL-Base/</id>
    <published>2022-08-21T05:08:02.000Z</published>
    <updated>2022-12-29T16:24:36.868Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mysql基础"><a class="markdownIt-Anchor" href="#mysql基础"></a> MySQL基础</h3><hr /><h4 id="span-idhead快速导航span"><a class="markdownIt-Anchor" href="#span-idhead快速导航span"></a> <span id="head">快速导航</span></h4><p>提醒：Typora内无法进行快速导航跳转建议用Typora自带的功能导出为html文件；另外各个示例之间有一定数据关联性，建议先把预先准备的测试数据代码执行好。 <span id="more"></span></p><p><a href="#ddl">DDL</a></p><p><a href="#dml">DML</a></p><p><a href="#dql">DQL</a></p><p><a href="#ysf">条件查询</a></p><p><a href="#px">排序</a></p><p><a href="#juhe">聚合函数</a></p><p><a href="#fz"> 分组查询</a></p><h4 id="一-数据库管理系统"><a class="markdownIt-Anchor" href="#一-数据库管理系统"></a> 一、数据库管理系统</h4><ol><li>数据库管理系统：DataBaseManagement，简称DBMS。</li><li>数据库管理系统是专门用来管理数据库中的数据，数据库管理系统可以对数据库中的数据进行增删改查的操作。</li><li>常见的数据库管理系统：MySQL，Oracle，SqlServer，MS，DB2等。</li></ol><h4 id="二-sql"><a class="markdownIt-Anchor" href="#二-sql"></a> 二、SQL</h4><ol><li>SQL是一种结构化查询语言。</li><li>通过SQL可以实现对数据库中数据的操作。</li><li>SQL是一套标准，基本能在大部分数据库管理系统中使用。</li></ol><h4 id="三-工作流程"><a class="markdownIt-Anchor" href="#三-工作流程"></a> 三、工作流程</h4><p>​数据库管理系统SQL→执行SQL→操作数据库</p><p>​先安装数据库管理系统MySQL，然后编写SQL语句，之后DBMS对SQL语句进行执行来完成对数据库的数据管理。</p><h4 id="四-准备工作"><a class="markdownIt-Anchor" href="#四-准备工作"></a> 四、准备工作</h4><ol><li><p>MySQL官网[下载]( <a href="https://downloads.mysql.com/archives/installer/">MySQL :: Download MySQL Installer (Archived Versions)</a> )，Windows推荐下载<a href="https://downloads.mysql.com/archives/get/p/25/file/mysql-installer-community-5.7.30.0.msi">Mysql5.7社区版本</a>，使用较多的版本。简易配置推荐Server only，也可以选择Custom自定义安装路径，后面填写好root用户的密码即可。其余默认下一步。MySQL环境变量配置可配可不配，需要命令行运行MySQL的相关命令可参考jdk的环境变量配置过程配置好。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本命令</span></span><br><span class="line">mysql -uroot -p  //登录MySQL,-p后面需要输入之前设置的密码</span><br><span class="line"><span class="comment"># 登录MySQL之后所有命令结尾必须要加英文分号;</span></span><br><span class="line">mysql&gt; <span class="built_in">exit</span>;   //退出MySQL</span><br><span class="line">mysql&gt; mysqladmin -uroot newpassword;  //root密码为空时,设置新密码</span><br><span class="line">mysql&gt; mysqladmin -uroot -pxxx password yyy; //xxx为旧密码,yyy为新密码</span><br><span class="line">mysql&gt; <span class="built_in">set</span> password <span class="keyword">for</span> 用户名@localhost = password(<span class="string">&#x27;新密码&#x27;</span>);  //修改密码的另一种方式,用户名一般是root</span><br><span class="line"></span><br><span class="line">mysql&gt; show databases; //查看全部的数据库</span><br><span class="line">mysql&gt; create database 数据库名; //创建数据库</span><br><span class="line">mysql&gt; use 数据库名; //指定需要操作的数据库</span><br><span class="line">mysql&gt; show tables; //展示指定数据库里面所有的数据表</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后面的数据操作相关命令可以直接套用navicat中编写的SQL语句,记得结尾加分号;</span></span><br></pre></td></tr></table></figure></li><li><p>数据库管理工具Navicat[下载]( <a href="https://www.navicat.com/en/download/navicat-for-mysql">Navicat | Download Navicat for MySQL 14-day trial versions for Windows, macOS and Linux</a> )，原生的MySQL数据库管理系统缺乏管理工具比较难以使用，通过第三方数据库管理工具可以更方便地管理数据库。</p></li><li><p>Navicat连接MySQL时需要确保MySQL服务开启，一般安装时默认开机自启动。<strong>以管理员身份运行</strong>命令提示符，输入命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">net start mysql57  //运行MySQL服务</span><br></pre></td></tr></table></figure><p>MySQL服务的端口号为3306，输入用户名和密码后，完成连接。</p></li></ol><h4 id="五-正式开始"><a class="markdownIt-Anchor" href="#五-正式开始"></a> 五、正式开始</h4><h5 id="1sql语句分类"><a class="markdownIt-Anchor" href="#1sql语句分类"></a> 1.SQL语句分类</h5><ul><li>DQL:数据查询语言，一般以<strong>select</strong>关键字开头，查询数据</li><li>DML:数据操作语言，<strong>insert</strong>、<strong>delete</strong>、<strong>update</strong>关键字，<strong>增删改数据表中的数据</strong></li><li>DDL:数据定义语言，<strong>create</strong>、<strong>drop</strong>、<strong>alter</strong>关键字，<strong>增删改数据表的结构</strong></li><li>TCL:事务控制语言，<strong>commit</strong>、<strong>rollback</strong>关键字，事务回滚和事务提交</li><li>DCL:数据控制语言，<strong>grant</strong>、<strong>revoke</strong>关键字，定义访问权限和安全级别及创建用户</li></ul><h5 id="2ddl数据定义语言的使用"><a class="markdownIt-Anchor" href="#2ddl数据定义语言的使用"></a> 2.DDL数据定义语言的使用</h5><ul><li><p>首先明确MySQL中的数据类型大致分为：**数值、日期/时间、字符串(字符)**三类。</p></li><li><p>数值类型</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">大小</th><th style="text-align:center">范围（有符号）</th><th style="text-align:center">范围（无符号）</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">TINYINT</td><td style="text-align:center">1 Bytes</td><td style="text-align:center">(-128,127)</td><td style="text-align:center">(0,255)</td><td style="text-align:center">小整数值</td></tr><tr><td style="text-align:center">SMALLINT</td><td style="text-align:center">2 Bytes</td><td style="text-align:center">(-32768,32767)</td><td style="text-align:center">(0,65535)</td><td style="text-align:center">大整数值</td></tr><tr><td style="text-align:center">MEDIUMINT</td><td style="text-align:center">3 Bytes</td><td style="text-align:center">(-8388608,8388607)</td><td style="text-align:center">(0,16777215)</td><td style="text-align:center">大整数值</td></tr><tr><td style="text-align:center">INT或INTEGER</td><td style="text-align:center">4 Bytes</td><td style="text-align:center">(-2147483648,2147483647)</td><td style="text-align:center">(0,4294967295)</td><td style="text-align:center">大整数值</td></tr><tr><td style="text-align:center">BIGINT</td><td style="text-align:center">8 Bytes</td><td style="text-align:center">(-2<sup>63,2</sup>63-1)</td><td style="text-align:center">(0,2^64-1)</td><td style="text-align:center">极大整数值</td></tr><tr><td style="text-align:center">FLOAT</td><td style="text-align:center">4 Bytes</td><td style="text-align:center">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0， (1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td style="text-align:center">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td style="text-align:center">单精度 浮点数值</td></tr><tr><td style="text-align:center">DOUBLE</td><td style="text-align:center">8 Bytes</td><td style="text-align:center">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td style="text-align:center">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td style="text-align:center">双精度 浮点数值</td></tr><tr><td style="text-align:center">DECIMAL</td><td style="text-align:center">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td style="text-align:center">依赖于M和D的值</td><td style="text-align:center">依赖于M和D的值</td><td style="text-align:center">小数值</td></tr></tbody></table></li><li><p>日期和时间类型</p><p>TIMESTAMP类型有专有的自动更新特性，将在后面描述。</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">大小 (Bytes)</th><th style="text-align:center">范围</th><th style="text-align:center">格式</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">DATE</td><td style="text-align:center">3</td><td style="text-align:center">1000-01-01/9999-12-31</td><td style="text-align:center">YYYY-MM-DD</td><td style="text-align:center">日期值</td></tr><tr><td style="text-align:center">TIME</td><td style="text-align:center">3</td><td style="text-align:center">‘-838:59:59’/‘838:59:59’</td><td style="text-align:center">HH:MM:SS</td><td style="text-align:center">时间值或持续时间</td></tr><tr><td style="text-align:center">YEAR</td><td style="text-align:center">1</td><td style="text-align:center">1901/2155</td><td style="text-align:center">YYYY</td><td style="text-align:center">年份值</td></tr><tr><td style="text-align:center">DATETIME</td><td style="text-align:center">8</td><td style="text-align:center">1000-01-01 00:00:00/9999-12-31 23:59:59</td><td style="text-align:center">YYYY-MM-DD HH:MM:SS</td><td style="text-align:center">混合日期和时间值</td></tr><tr><td style="text-align:center">TIMESTAMP</td><td style="text-align:center">4</td><td style="text-align:center">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td style="text-align:center">YYYYMMDD HHMMSS</td><td style="text-align:center">混合日期和时间值，时间戳</td></tr></tbody></table></li><li><p>字符串类型</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">大小</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">CHAR</td><td style="text-align:left">0-255 bytes</td><td style="text-align:left">定长字符串</td></tr><tr><td style="text-align:left">VARCHAR</td><td style="text-align:left">0-65535 bytes</td><td style="text-align:left">变长字符串</td></tr><tr><td style="text-align:left">TINYBLOB</td><td style="text-align:left">0-255 bytes</td><td style="text-align:left">不超过 255 个字符的二进制字符串</td></tr><tr><td style="text-align:left">TINYTEXT</td><td style="text-align:left">0-255 bytes</td><td style="text-align:left">短文本字符串</td></tr><tr><td style="text-align:left">BLOB</td><td style="text-align:left">0-65 535 bytes</td><td style="text-align:left">二进制形式的长文本数据</td></tr><tr><td style="text-align:left">TEXT</td><td style="text-align:left">0-65 535 bytes</td><td style="text-align:left">长文本数据</td></tr><tr><td style="text-align:left">MEDIUMBLOB</td><td style="text-align:left">0-16 777 215 bytes</td><td style="text-align:left">二进制形式的中等长度文本数据</td></tr><tr><td style="text-align:left">MEDIUMTEXT</td><td style="text-align:left">0-16 777 215 bytes</td><td style="text-align:left">中等长度文本数据</td></tr><tr><td style="text-align:left">LONGBLOB</td><td style="text-align:left">0-4 294 967 295 bytes</td><td style="text-align:left">二进制形式的极大文本数据</td></tr><tr><td style="text-align:left">LONGTEXT</td><td style="text-align:left">0-4 294 967 295 bytes</td><td style="text-align:left">极大文本数据</td></tr></tbody></table><p><span id="ddl"><a href="#head">返回快速导航</a></span></p></li><li><p>DDL语句示例一：对数据表的管理操作以及对字段的增删改操作（在Navicat中新建查询输入SQL语句或在命令行中输入SQL语句）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database test;</span><br><span class="line">use test;</span><br><span class="line"># 创建一张拥有一个int类型的t1字段的test_int数据表</span><br><span class="line"># 默认为有符号</span><br><span class="line"># 多个字段用英文逗号,隔开</span><br><span class="line">create table test_int(</span><br><span class="line">t1 int</span><br><span class="line">);</span><br><span class="line"># 这里的desc作用是查看数据表的结构信息</span><br><span class="line">desc test_int;</span><br><span class="line"># 增加一条t1字段值为-11111的记录</span><br><span class="line">insert into test_int values (-11111); # 默认有符号</span><br><span class="line"></span><br><span class="line"># 增加一个t2无符号字段</span><br><span class="line">alter table test_int add column t2 int unsigned;</span><br><span class="line"># 这时候增加一条t2字段值为负数的记录,就会出现out of range的错误</span><br><span class="line">insert into test_int (t2) value (-1111); # 报错</span><br><span class="line"># 修改t2字段类型</span><br><span class="line">alter table test_int modify column t2 int;</span><br><span class="line"># 删除t2字段</span><br><span class="line">alter table test_int drop column t2;</span><br><span class="line"></span><br><span class="line"># 删除test_int数据表</span><br><span class="line">drop table if exists test_int;</span><br><span class="line"></span><br><span class="line">create table test_int(</span><br><span class="line">t1 int,</span><br><span class="line">    t2 int unsigned</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">select * from test_int;</span><br></pre></td></tr></table></figure></li><li><p>示例二：对数据库的管理操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法 create database [if not exists] 数据库名; #[]中的内容选填</span><br><span class="line">    drop database [if exists] 数据库名;</span><br><span class="line"># 创建数据库book</span><br><span class="line">create database book;</span><br><span class="line"># 更改数据库的字符集</span><br><span class="line">alter database book character set utf8;</span><br><span class="line"># 查看字符集</span><br><span class="line">show create database book;</span><br><span class="line"># 删除数据库(判断该数据库是否存在,存在则进行删除)</span><br><span class="line">drop database if exists book;</span><br></pre></td></tr></table></figure></li><li><p>示例三：对数据表结构的操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table books(</span><br><span class="line">id int,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    price double,</span><br><span class="line">    author varchar(20),</span><br><span class="line">    publish_date datetime</span><br><span class="line">);</span><br><span class="line">desc books;</span><br><span class="line"># 表的修改</span><br><span class="line"># alter table 数据表名 add/drop/modify/change column ...</span><br><span class="line"># 修改字段名publish_date为date</span><br><span class="line">alter table books change column publish_date date datetime;</span><br><span class="line"># 修改字段的类型或约束</span><br><span class="line">alter table books modify column date timestamp;</span><br><span class="line"></span><br><span class="line"># 关于alter中change和modify的使用区别</span><br><span class="line"># change的修改范围大于modify,change一般用于修改字段名</span><br><span class="line"># modify一般用于修改数据类型或约束,但modify不能修改字段名</span><br><span class="line"></span><br><span class="line"># 添加新的字段inventory,添加字段需要指明数据类型</span><br><span class="line">alter table books add column inventory int;</span><br><span class="line"># 删除字段inventory,删除字段只需要提供字段名</span><br><span class="line">alter table books drop column inventory;</span><br><span class="line"># 修改数据表名</span><br><span class="line">alter table books rename to works;</span><br><span class="line">desc works;</span><br></pre></td></tr></table></figure></li><li><p>示例四：复制数据表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 增加记录</span><br><span class="line">insert into works values</span><br><span class="line">(1,&#x27;《java》&#x27;,132.9,&#x27;詹姆斯·高斯林&#x27;,&#x27;2001-12-01&#x27;),</span><br><span class="line">(2,&#x27;《linux》&#x27;,156.9,&#x27;linus&#x27;,&#x27;1999-01-01&#x27;);</span><br><span class="line"></span><br><span class="line"># 仅复制数据表的结构</span><br><span class="line">create table copy like works;</span><br><span class="line"># 复制结构和数据</span><br><span class="line">create table clone select * from works;</span><br><span class="line"># 复制部分结构</span><br><span class="line">create table remake select id,name from works;</span><br><span class="line"># 仅复制部分字段,利用where进行条件判断,恒为0则只保留字段</span><br><span class="line">create table redo select id,name from works where 0;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3dml数据操作语言的使用"><a class="markdownIt-Anchor" href="#3dml数据操作语言的使用"></a> 3.DML数据操作语言的使用</h5><p><span id="dml"><a href="#head">返回快速导航</a></span></p><ul><li><p><strong>insert语句</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line"># insert into 数据表名(字段名1,字段名2,...) values (字段值1,字段值2,...);</span><br><span class="line">create table product(</span><br><span class="line">id int,</span><br><span class="line">name varchar(20),</span><br><span class="line">price double</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 在product表中增加一条记录</span><br><span class="line">insert into product(id,name,price) values (1,&#x27;phone&#x27;,500.0);</span><br><span class="line"># 在product表中指定的字段增加记录</span><br><span class="line">insert into product(id,price) values (2,399.9);</span><br><span class="line"></span><br><span class="line">select * from product;</span><br><span class="line"></span><br><span class="line"># 默认给全部字段增加记录</span><br><span class="line"># insert into 数据表名 values (字段值1,字段值2,...);</span><br><span class="line"></span><br><span class="line">insert into product values (3,&#x27;mac&#x27;,21499.9);</span><br><span class="line">select * from product;</span><br><span class="line"></span><br><span class="line"># 批量增加记录</span><br><span class="line"># insert into 数据表名 values (字段值1,字段值2,...),(字段值1,字段值2,...);</span><br><span class="line"></span><br><span class="line">insert into product values (4,&#x27;a&#x27;,1.1),(5,&#x27;b&#x27;,2.2),(6,&#x27;c&#x27;,3.3);</span><br><span class="line">select * from product;</span><br></pre></td></tr></table></figure><p>注意字段名和字段值的类型对应，以及日期时间、字符字符串类型数据需要加上引号（单双引号均可）</p></li><li><p><strong>update语句</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line">#update 数据表名 set 字段1 = 值1,字段2 = 值2,...[where 条件];</span><br><span class="line"></span><br><span class="line"># 修改phone的price为9999</span><br><span class="line">update product set price = 9999 where name=&#x27;phone&#x27;;</span><br><span class="line">select * from product;</span><br><span class="line"></span><br><span class="line"># 修改mac的price为39999.9,id为0</span><br><span class="line">update product set price = 39999.9,id=0 where name=&#x27;mac&#x27;;</span><br><span class="line"></span><br><span class="line"># 修改id为2记录的name为switch</span><br><span class="line">update product set name = &#x27;switch&#x27; where id=2;</span><br></pre></td></tr></table></figure><p>注意一般情况下update语句中不能缺少条件，否则会修改所有数据。</p></li><li><p><strong>delete语句</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line"># delete from 数据表名 [where 条件];</span><br><span class="line"></span><br><span class="line"># 删除product表中的switch数据</span><br><span class="line">delete from product where name=&#x27;switch&#x27;;</span><br><span class="line"></span><br><span class="line"># 删除product表中price为39999.9的数据</span><br><span class="line">delete from product where price=39999.9;</span><br><span class="line"></span><br><span class="line">select * from product;</span><br></pre></td></tr></table></figure><p>注意delete语句中必须加上条件限制，否则所有的数据将会被删除。</p><p>基本update和delete都要配合where来使用，否则和Linux系统中<code>rm -rf /</code>命令是差不多的后果。</p></li></ul><h5 id="4dql数据查询语言的使用"><a class="markdownIt-Anchor" href="#4dql数据查询语言的使用"></a> 4.DQL数据查询语言的使用</h5><p>​<span id="dql"><a href="#head">返回快速导航</a></span></p><ul><li><p>示例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line"># select 字段名 from 数据表名;</span><br><span class="line"></span><br><span class="line"># 单独查询name字段</span><br><span class="line">select name from product;</span><br><span class="line"># 查询多个字段</span><br><span class="line">select id,name from product;</span><br><span class="line"># 查询所有字段</span><br><span class="line">select * from product;</span><br><span class="line"># 或者把*替换成数据表中所有的字段名</span><br><span class="line"></span><br><span class="line"># as关键字取别名,不改变原有数据,改变的是显示的内容,as关键字可省略</span><br><span class="line">select name as product_name from product;</span><br><span class="line"></span><br><span class="line"># 别名中有空格,使用单引号括住别名</span><br><span class="line">select name &#x27;product name&#x27; from product;</span><br></pre></td></tr></table></figure></li></ul><h5 id="5sql运算符及条件查询"><a class="markdownIt-Anchor" href="#5sql运算符及条件查询"></a> 5.SQL运算符及条件查询</h5><ol><li><p>算术运算符</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center"><strong>说  明</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>+</strong></td><td style="text-align:center"><strong>加运算，求两个数或表达式相加的和，如6+8</strong></td></tr><tr><td style="text-align:center"><strong>-</strong></td><td style="text-align:center"><strong>减运算，求两个数或表达式相减的差</strong></td></tr><tr><td style="text-align:center">*****</td><td style="text-align:center"><strong>乘运算，求两个数或表达式相乘的积</strong></td></tr><tr><td style="text-align:center"><strong>/</strong></td><td style="text-align:center"><strong>除运算，求两个数或表达式相除的商，如5/3的值为1</strong></td></tr><tr><td style="text-align:center"><strong>%</strong></td><td style="text-align:center"><strong>取模运算，求两个数或表达式相除的余数，如：5%3的值为2</strong></td></tr></tbody></table><p>SQL语句也可以使用数学表达式，注意SQL没有java的自增自减等运算符。</p></li><li><p>where条件查询运算符</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">&lt;&gt;或!=</td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">between…  and…</td><td style="text-align:center">两个值之间，等同于  &gt;=   and   &lt;=</td></tr><tr><td style="text-align:center">is  null</td><td style="text-align:center">为null  （is  not  null不为空）</td></tr><tr><td style="text-align:center">and</td><td style="text-align:center">并且</td></tr><tr><td style="text-align:center">or</td><td style="text-align:center">或者</td></tr><tr><td style="text-align:center">in</td><td style="text-align:center">包含，相当于多个or（not in不在这个范围中）</td></tr><tr><td style="text-align:center">not</td><td style="text-align:center">not可以取非，主要用在is  或  in中</td></tr><tr><td style="text-align:center">like</td><td style="text-align:center">like称为模糊查询，支持%或下划线匹配，%匹配任意多个字符，一个下划线值匹配一个字符</td></tr></tbody></table><p><span id="ysf"><a href="#head">返回快速导航</a></span></p></li><li><p>示例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database if not exists task;</span><br><span class="line">use task;</span><br><span class="line">create table if not exists coder(</span><br><span class="line">id int,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    score int,</span><br><span class="line">    grade varchar(10),</span><br><span class="line">    project int</span><br><span class="line">);</span><br><span class="line">insert into coder values</span><br><span class="line">(1,&#x27;Mike&#x27;,100,&#x27;A&#x27;,1),</span><br><span class="line">(2,&#x27;Jhon&#x27;,96,&#x27;A&#x27;,2),</span><br><span class="line">(3,&#x27;Dram&#x27;,60,&#x27;D&#x27;,null),</span><br><span class="line">(4,&#x27;Lambda&#x27;,100,&#x27;A&#x27;,null),</span><br><span class="line">(5,&#x27;LuBen&#x27;,89,&#x27;B&#x27;,3),</span><br><span class="line">(6,&#x27;K&#x27;,75,&#x27;C&#x27;,null),</span><br><span class="line">(7,&#x27;Z&#x27;,88,&#x27;C&#x27;,null),</span><br><span class="line">(8,&#x27;L&#x27;,75,&#x27;B&#x27;,null);</span><br><span class="line">select * from coder;</span><br><span class="line"></span><br><span class="line"># 查询coder数据表中score等于100的name和id记录</span><br><span class="line">select name,id from coder where score=100;</span><br><span class="line"></span><br><span class="line"># 查询coder数据表中grade不等于A的name和id记录</span><br><span class="line">select name,id from coder where grade != &#x27;A&#x27;;</span><br><span class="line">select name,id from coder where grade &lt;&gt; &#x27;A&#x27;;</span><br><span class="line"></span><br><span class="line"># 查询coder数据表中score小于89的name和id记录</span><br><span class="line">select name,id from coder where score &lt; 89;</span><br><span class="line"></span><br><span class="line"># 查询coder数据表中score小于等于89的name和id记录</span><br><span class="line">select name,id from coder where score &lt;= 89;</span><br><span class="line"></span><br><span class="line"># 查询coder数据表中score大于75的name和id记录</span><br><span class="line">select name,id from coder where score &gt; 75;</span><br><span class="line"></span><br><span class="line"># 查询coder数据表中score大于等于75的name和id记录</span><br><span class="line">select name,id from coder where score &gt;= 75;</span><br><span class="line"></span><br><span class="line"># 查询coder数据表中score在75和90之间的name和id记录</span><br><span class="line">select name,id from coder where score&gt;=75 and score&lt;=90;</span><br><span class="line">select name,id from coder where score between 75 and 90;</span><br><span class="line"># between 较小值 and 较大值  闭区间</span><br><span class="line"></span><br><span class="line"># 查询coder数据表中project为null的记录</span><br><span class="line">select * from coder where project is null;</span><br><span class="line"> </span><br><span class="line"># 查询coder数据表中project不为null的记录</span><br><span class="line">select * from coder where project is not null;</span><br><span class="line"> </span><br><span class="line"># 查询coder数据表中grade为A且score为100的记录</span><br><span class="line">select * from coder where grade=&#x27;A&#x27; and score=100;</span><br><span class="line"> </span><br><span class="line"># 查询coder数据表中score为100或project为3的记录</span><br><span class="line">select * from coder where score=100 or project=3;</span><br><span class="line"> </span><br><span class="line"># and和or同时使用时,and优先级高于or,要使or先执行,则需用()括住or关联的条件</span><br><span class="line"># 查询coder数据表中grade为A且project为1 和 score大于74的记录</span><br><span class="line">select * from coder where grade=&#x27;A&#x27; and project=1 or score &gt; 74;</span><br><span class="line"># 查询coder数据表中project为1或score大于74 且grade为A的记录</span><br><span class="line">select * from coder where grade=&#x27;A&#x27; and (project=1 or score &gt; 74);</span><br><span class="line"></span><br><span class="line"># in关键字相当于多个or,但in无法关联数值范围的条件,只能关联一个具体的数值条件</span><br><span class="line"># 查询coder数据表中score为100或96的记录</span><br><span class="line">select * from coder where score=100 or score=96;</span><br><span class="line">select * from coder where score in(100,96); # 这里表示两个数值</span><br><span class="line"></span><br><span class="line"># 查询coder数据表中project不为1且不为3的记录</span><br><span class="line">select * from coder where project&lt;&gt;1 and project&lt;&gt;3;</span><br><span class="line">select * from coder where project not in(3,1);</span><br><span class="line"></span><br><span class="line"># 模糊查询</span><br><span class="line"># like关键字,匹配符%和_</span><br><span class="line"># %匹配任意多个字符,_匹配任意一个字符</span><br><span class="line"># 转义字符\,用于处理包含%和_这两个特殊符号的记录</span><br><span class="line"></span><br><span class="line"># 查询coder数据表中以e结尾的name记录</span><br><span class="line">select name from coder where name like &#x27;%e&#x27;;</span><br><span class="line"># 查询coder数据表中以L开头的name记录</span><br><span class="line">select name from coder where name like &#x27;L%&#x27;;</span><br><span class="line"># 查询coder数据表中包含u的name记录</span><br><span class="line">select name from coder where name like &#x27;%u%&#x27;;</span><br><span class="line"># 查询coder数据表中第二个字母为h的name记录</span><br><span class="line">select name from coder where name like &#x27;_h%&#x27;;</span><br></pre></td></tr></table></figure></li></ol><h5 id="6排序"><a class="markdownIt-Anchor" href="#6排序"></a> 6.排序</h5><table><thead><tr><th style="text-align:center">关键字</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">order by</td><td style="text-align:center">排序</td></tr><tr><td style="text-align:center">desc</td><td style="text-align:center">降序</td></tr><tr><td style="text-align:center">asc</td><td style="text-align:center">升序</td></tr></tbody></table><p><span id="px"><a href="#head">返回快速导航</a></span></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 对coder数据表中的score进行排序,默认升序</span><br><span class="line">select name,score from coder order by score;</span><br><span class="line"># 指定降序,这里的desc作用是指定降序排序</span><br><span class="line">select name,score from coder order by score desc;</span><br><span class="line"># 指定升序</span><br><span class="line">select name,score from coder order by score asc;</span><br><span class="line"></span><br><span class="line"># 多字段排序,第一字段相同时,根据第二字段排序</span><br><span class="line"># 根据score升序排序,score相同则根据name升序排序</span><br><span class="line">select name,score from coder order by score asc,name asc;</span><br><span class="line"></span><br><span class="line"># 不推荐写法</span><br><span class="line">select * from coder order by 1; # 这里的1表示第一个字段id</span><br><span class="line"># 这种写法很容易因为字段顺序的改变而出错</span><br></pre></td></tr></table></figure><h5 id="7聚合函数"><a class="markdownIt-Anchor" href="#7聚合函数"></a> 7.聚合函数</h5><p><span id="juhe"><a href="#head">返回快速导航</a></span></p><p><strong>多行数据经聚合函数处理之后的结果只有一行</strong></p><p><strong>聚合函数分类</strong></p><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">count(字段名)</td><td style="text-align:center">统计数量(一般选用不为null的列)</td></tr><tr><td style="text-align:center">max(字段名)</td><td style="text-align:center">最大值</td></tr><tr><td style="text-align:center">min(字段名)</td><td style="text-align:center">最小值</td></tr><tr><td style="text-align:center">sum(字段名)</td><td style="text-align:center">求和</td></tr><tr><td style="text-align:center">avg(字段名)</td><td style="text-align:center">平均值</td></tr></tbody></table><p>注意：聚合函数需要配合分组来使用，先分组再用聚合函数处理。</p><p>如果不进行分组，则默认整张数据表为一组。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 找出coder数据表中score字段的最大值记录</span><br><span class="line">select max(score) from coder;</span><br><span class="line"># 找出coder数据表中score字段的最小值记录</span><br><span class="line">select min(score) from coder;</span><br><span class="line"># 计算score字段所有记录的总和</span><br><span class="line">select sum(score) from coder;</span><br><span class="line"># 计算score字段所有记录的平均值</span><br><span class="line">select avg(score) from coder;</span><br><span class="line"># 计算记录总条数,可以用任意非空字段做参数</span><br><span class="line">select count(name) from coder;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>聚合函数会自动忽略指定字段值为null的记录</li><li>在count(*)情况下，每一行数据中只要有一个字段值不为null，则该数据就会被count函数统计进去</li><li>聚合函数也称分组函数，不能直接在<strong>where子句</strong>中使用</li><li>聚合函数之间可以相互组合使用</li></ol><h5 id="8分组查询"><a class="markdownIt-Anchor" href="#8分组查询"></a> 8.分组查询</h5><p><span id="fz"><a href="#head">返回快速导航</a></span></p><p><strong>group by关键字</strong></p><p>格式：select 字段 from 数据表 where 条件 group by 分组依据字段 order by 排序依据字段 排序方式</p><p>执行优先级：from→where→group by→select→order by</p><p>由于where的优先级高于group by，因此聚合函数无法在where子句中使用。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 计算coder数据表中grade各组的score总和</span><br><span class="line">select grade,sum(score) from coder group by grade;</span><br><span class="line"></span><br><span class="line"># 规范:使用了group by的语句,select后面的字段只能用作为分组依据的字段及聚合函数,不允许使用其他字段,否则即使不报错,数据结果也会存在问题</span><br><span class="line"></span><br><span class="line"># having关键字对group by之后的数据进行处理</span><br><span class="line"># 不同于where,having专门与group by一起使用,而不能单独使用</span><br><span class="line"></span><br><span class="line"># 找出coder数据表各grade组中score平均值大于80的记录</span><br><span class="line">select grade,avg(score) from coder group by grade having avg(score)&gt;80;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;mysql基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mysql基础&quot;&gt;&lt;/a&gt; MySQL基础&lt;/h3&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;span-idhead快速导航span&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#span-idhead快速导航span&quot;&gt;&lt;/a&gt; &lt;span id=&quot;head&quot;&gt;快速导航&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;提醒：Typora内无法进行快速导航跳转建议用Typora自带的功能导出为html文件；另外各个示例之间有一定数据关联性，建议先把预先准备的测试数据代码执行好。</summary>
    
    
    
    <category term="MySQL5" scheme="https://s-chance.github.io/categories/MySQL5/"/>
    
    
    <category term="MySQL" scheme="https://s-chance.github.io/tags/MySQL/"/>
    
  </entry>
  
</feed>
