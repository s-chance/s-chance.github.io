<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Entropy Tree</title>
  
  <subtitle>the truth of life</subtitle>
  <link href="https://s-chance.github.io/atom.xml" rel="self"/>
  
  <link href="https://s-chance.github.io/"/>
  <updated>2023-02-04T15:51:00.692Z</updated>
  <id>https://s-chance.github.io/</id>
  
  <author>
    <name>Entropy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式理论</title>
    <link href="https://s-chance.github.io/2023/02/03/golang-day8/"/>
    <id>https://s-chance.github.io/2023/02/03/golang-day8/</id>
    <published>2023-02-03T13:59:12.000Z</published>
    <updated>2023-02-04T15:51:00.692Z</updated>
    
    <content type="html"><![CDATA[<p>本文已收录到<a href="https://juejin.cn/post/7196300179998228535">分布式理论 | 青训营笔记 - 掘金 (juejin.cn)</a>，主要记录了对分布式理论的学习<span id="more"></span></p><h2 id="分布式理论"><a class="markdownIt-Anchor" href="#分布式理论"></a> 分布式理论</h2><h3 id="1分布式概述"><a class="markdownIt-Anchor" href="#1分布式概述"></a> 1.分布式概述</h3><h4 id="11-什么是分布式"><a class="markdownIt-Anchor" href="#11-什么是分布式"></a> 1.1 什么是分布式</h4><p>分布式系统是计算机程序的集合，这些程序利用跨多个独立计算节点的计算资源来实现共同的目标。可以分为分布式计算、分布式存储、分布式数据库等。</p><p>优势</p><ol><li>去中心化</li><li>低成本</li><li>弹性</li><li>资源共享</li><li>可靠性高</li></ol><p>挑战</p><ol><li>普通的节点故障</li><li>不可靠的网络</li><li>异构的机器与硬件环境</li><li>安全</li></ol><h4 id="12-分布式的必要性"><a class="markdownIt-Anchor" href="#12-分布式的必要性"></a> 1.2 分布式的必要性</h4><p>使用者角度</p><ul><li>原因：1.数据爆炸，对存储和计算有大规模运用的需求；2.成本低，构建在廉价服务器之上。</li><li>如何实现：1.分布式框架；2.成熟的分布式系统。</li><li>目标规划：1.理清规模，负载，一致性要求等；2.明确稳定性要求，制定技术方案。</li></ul><p>学习者角度</p><ul><li>原因：1.后端开发必备技能；2.帮助理解后台服务器之间协作的机理。</li><li>如何学习：1.掌握分布式理论；2.了解一致性协议。</li><li>学习规划：1.把要点深入展开，针对难点搜索互联网资料进行学习；2.将所学知识运用于实践。</li></ul><h4 id="13-常见的分布式系统"><a class="markdownIt-Anchor" href="#13-常见的分布式系统"></a> 1.3 常见的分布式系统</h4><p>分布式存储</p><ol><li><p>Google File System（GFS）：google 分布式文件存储系统</p></li><li><p>Ceph：统一的分布式存储系统</p></li><li><p>Hadoop HDFS：基于 GFS 架构的开源分布式文件系统</p></li><li><p>Zookeeper：高可用的分布式数据管理与系统协调框架</p></li></ol><p>分布式数据库</p><ol><li>Google Spanner：google 可扩展的、全球分布式的数据库</li><li>TiDB：开源分布式关系型数据库</li><li>HBase：开源 Nosql 数据库</li><li>MongoDB：文档数据库</li></ol><p>分布式计算</p><ol><li>Hadoop：基于 MapReduce 分布式计算框架</li><li>Spark：在 Hadoop 基础之上，使用内存来存储数据</li><li>YARN：分布式资源调度</li></ol><h3 id="2系统模型"><a class="markdownIt-Anchor" href="#2系统模型"></a> 2.系统模型</h3><h4 id="21-故障模型"><a class="markdownIt-Anchor" href="#21-故障模型"></a> 2.1 故障模型</h4><ul><li>Byzantine failure：节点可以任意篡改发送给其他节点的数据</li><li>Authentication detectable byzantine failure（ADB）：Byzantine failure 的特例，节点可以篡改数据，但不能伪造其他节点的数据</li><li>Performance failure：节点未在特定时间段内收到数据，即时间太早或太晚</li><li>Omission failure：节点收到数据的时间无限晚，即收不到数据</li><li>Crash failure：在 omission failure 的基础上，增加了节点停止响应的假设，即持续性地 omission failure</li><li>Fail-stop failure：在 Crash failure 的基础上增加了错误可检测的假设</li></ul><table><thead><tr><th style="text-align:center">故障</th><th style="text-align:center">描述</th><th style="text-align:center">可能的类型</th></tr></thead><tbody><tr><td style="text-align:center">磁盘故障</td><td style="text-align:center">如：磁头不寻道、盘片不转、磁介质损伤等。年发生率 1-2%</td><td style="text-align:center">Fail-stop</td></tr><tr><td style="text-align:center">磁盘坏道、坏块</td><td style="text-align:center">磁头划伤引起坏道，或受宇宙射线影响晶体管产生位反转</td><td style="text-align:center">Fail-stop，ADB</td></tr><tr><td style="text-align:center">服务器主板、板卡故障</td><td style="text-align:center">可能是风扇故障，或灰尘引起的短路，或 SCSI/RAID 卡造成的死机</td><td style="text-align:center">Crash</td></tr><tr><td style="text-align:center">网络故障</td><td style="text-align:center">电源故障、背板故障等，网卡位反转、网络流量大造成大量丢包等</td><td style="text-align:center">Byzantine，Omission</td></tr><tr><td style="text-align:center">网络分区</td><td style="text-align:center">网络分区异常引起节点形成不同的子集，子集中网络相遇，子集间网络不通</td><td style="text-align:center">Performance</td></tr><tr><td style="text-align:center">内存故障</td><td style="text-align:center">内存出错造成的数据被篡改，分为 UE、CE 两种</td><td style="text-align:center">ADB</td></tr><tr><td style="text-align:center">线缆故障</td><td style="text-align:center">服务器光模块频繁 up 或 down</td><td style="text-align:center">Performance，Omission</td></tr><tr><td style="text-align:center">内核崩溃</td><td style="text-align:center">内核内部的致命错误，产生的 kernel panic</td><td style="text-align:center">Crash</td></tr><tr><td style="text-align:center">CPU 故障</td><td style="text-align:center">年故障率接近 1%</td><td style="text-align:center">Omission、Crash</td></tr><tr><td style="text-align:center">电源故障</td><td style="text-align:center">服务器失去电力支撑</td><td style="text-align:center">Omission</td></tr><tr><td style="text-align:center">软件故障</td><td style="text-align:center">如：进程 crash、内存踩坏、状态不一致、配置错误、软件 bug 等</td><td style="text-align:center">Byzantine、Crash 等</td></tr></tbody></table><h4 id="22-拜占庭将军问题"><a class="markdownIt-Anchor" href="#22-拜占庭将军问题"></a> 2.2 拜占庭将军问题</h4><blockquote><p>两将军问题（Two Generals’ Problem）：两支军队的将军只能派信使穿越敌方领土相互通信，以此约定进攻时间。该问题希望求解如何在两名将军派出的任何信使都可能被俘虏的情况下，就经过时间达成共识。</p><p>结论是，两将军问题被证实是无解的电脑通信问题，两支军队理论上永远无法达成共识。</p><p>方案一：同时发送 N 个信使，任何一个达到对方军队，都算成功。</p><p>方案二：设置超时时间，发送后未在一定时间返回，则加派信使。</p><p>共识与消息传递不是一个概念：即使保证了消息传递成功，也不能保证达成共识。</p><p>TCP 三次握手是在两个方向确认包的序列号，增加了超时重试，是两将军问题的一个工程解。</p><p>思考</p><ol><li><p>为何 TCP 需要三次握手？而不是两次或四次？</p><p>可以参考一下笔者个人整理的笔记<a href="https://github.com/s-chance/packet-tracer#25tcp%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">s-chance/packet-tracer: 计算机网络 | Packet Tracer的使用</a></p></li><li><p>挥手过程中，如果 FIN 报文丢失，会发生什么结果？</p><p>参考<a href="https://zhuanlan.zhihu.com/p/557759425">TCP 三次握手和四次挥手，中间失败了会发生什么？ - 知乎 (zhihu.com)</a></p></li></ol><p>拜占庭将军考虑更加普适的场景，例如 3 个将军 ABC 互相传递消息，消息可能丢失，也可能被篡改，当有一个将军是“叛徒”（即出现拜占庭故障）时，整个系统无法达成一致。</p><p>如果没有“叛徒”，无论各自观察到怎样的敌情，总能达成一致的行动。</p><p>假设由于“叛徒” C 的存在，将军 A 和将军 B 获得不同的信息。这样将军 A 获得 2 票进攻 1 票撤退的信息，将军 B 获得 1 票进攻 2 票撤退的信息，产生了不一致。</p><p>考虑当 4 个将军，只有 1 个叛徒的场景。将军 D 作为消息分发中枢，约定如果没收到消息则执行撤退。</p><ul><li>如果 D 为 “叛徒”，ABC 无论收到任何消息，总能达成一致</li><li>D 为 “忠将”，ABC 中有 2 人将 D 的消息进行正确的传递，同样能保证最终决策符合大多数。</li></ul><p>进而能够证明，当有 3m+1 个将军，其中有 m 个“叛徒”时，可以增加 m 轮协商，最终达成一致。</p></blockquote><h4 id="23-共识和一致性"><a class="markdownIt-Anchor" href="#23-共识和一致性"></a> 2.3 共识和一致性</h4><p><strong>读请求和写请求并发时可能读到旧值</strong></p><p>客户端 A 读到 x=0，当客户端 C 正在写入时，客户端 A 和 B 可能读到 0 或者 1。但是当 C 写入完成后，A 和 B 最终能读到一致的数据。这样的一致性被称为 Eventually consistent（最终一致性）。</p><p><strong>一旦某个读获取到新值，所有的客户端都必须返回新值</strong></p><p>当客户端 A 读到更新的版本 x=1 后，及时将消息同步给其他客户端，这样其他客户端立即能获取到 x=1。这样的一致性被称为 Linearizability（线性一致性）</p><p>如果要保证“线性”一致性，多个节点间势必需要进行协商，以寻求一致。这样会增加延迟，系统可用性便会受损。</p><h4 id="24-时间和事件顺序"><a class="markdownIt-Anchor" href="#24-时间和事件顺序"></a> 2.4 时间和事件顺序</h4><blockquote><p>1978 年 Leslie Lamport 发表在 Communications of the ACM 上的论文 <em>Time, Clocks, and the Ordering  of Events in a Distributed System</em></p><p>我们定义“happened before”关系，记为“→”。其满足如下三个条件</p><ul><li>如果 a 和 b 是在相同节点上的两个事件，a 在 b 之前发生，则定义 a → b</li><li>如果事件 a 表示某个节点发送某条消息，b 是另一个节点接受这条消息，则有 a → b</li><li>如果有 a → b 且 b → c，则有 a → c</li></ul><p>当且仅当 a <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>↛</mo></mrow><annotation encoding="application/x-tex">\nrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel amsrm">↛</span></span></span></span> b 且 b <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>↛</mo></mrow><annotation encoding="application/x-tex">\nrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel amsrm">↛</span></span></span></span> a 时，则称两个事件为并发的（concurrent）。</p><p>Lamport 逻辑时钟</p><p>对于每一个节点 Pi 定义时钟 Ci 为一个函数，它为任意的事件 a 赋值编号为 Ci（a）</p><ol><li>如果 a 和 b 是在相同节点 Pi 上的两个事件，a 在 b 之前发生，则有 Ci（a）&lt; Ci（b）</li><li>如果事件 a 表示节点 Pi 发送某条消息， b 表示节点 Pj 接受这条消息，则有 Ci（a）&lt; Cj（b）</li></ol><p>利用逻辑时钟，可以对整个系统中的事件进行全序排序。</p></blockquote><h3 id="3理论基础"><a class="markdownIt-Anchor" href="#3理论基础"></a> 3.理论基础</h3><h4 id="31-cap-理论"><a class="markdownIt-Anchor" href="#31-cap-理论"></a> 3.1 CAP 理论</h4><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">C（Consistence）</td><td style="text-align:center">一致性，指数据在多个副本之间能够保持一致的特性（严格的一致性）。</td></tr><tr><td style="text-align:center">A（Availability）</td><td style="text-align:center">可用性，指系统提供的服务必须一直处于可用的状态，每次请求都能获取到非错的响应，但是不保证获取的数据为最新数据。</td></tr><tr><td style="text-align:center">P（Network partitioning）</td><td style="text-align:center">分区容错性，分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障。</td></tr></tbody></table><p>CAP 理论往往运用于数据库领域，同样适用于分布式存储方向</p><p>一个分布式系统最多只能同时满足 CAP 理论三项中的两项，因此有以下几种设计</p><ul><li><p>CA：放弃分区容错性，加强一致性和可用性，即传统的单机数据库的选择。</p></li><li><p>AP：放弃一致性（这里的一致性是指强一致性），追求分区容错性和可用性，例如一些注重用户体验的系统。</p></li><li><p>CP：放弃可用性，追求一致性和分区容错性，例如与资金安全相关的系统。</p></li></ul><p>目前大多数都是分布式系统，因此网络分区是必备的。在网络发生分区的情况下，必须在可用性和一致性之间做出选择。</p><p>近似解决方法：把故障节点的负载转移给备用节点负责。</p><h4 id="32-acid-理论"><a class="markdownIt-Anchor" href="#32-acid-理论"></a> 3.2 ACID 理论</h4><p>事务是数据库系统中非常重要的概念，它是数据库管理系统执行过程中的一个逻辑单元，它能够保证一个事务中的所有操作要么全部执行，要么全都不执行。</p><p>数据库事务拥有四个特性 ACID，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）</p><ul><li><p>原子性（A）</p><p>原子性是指事务包含的操作要么全部成功，要么全部失败回滚。</p></li><li><p>一致性（C）</p><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，即一个事务执行之前和执行之后都必须处于一致性状态。</p></li><li><p>隔离性（I）</p><p>隔离性是指当多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离</p></li><li><p>持久性（D）</p><p>持久性是指一个事务一旦被提交了，那么对于数据库中的数据的改变就是永久性的，即使是在数据库系统遇到故障的情况下，也不会丢失提交事务的操作</p></li></ul><h4 id="33-base-理论"><a class="markdownIt-Anchor" href="#33-base-理论"></a> 3.3 BASE 理论</h4><p>Base 理论是对 CAP 理论中一致性和可用性权衡的结果，其来源于对大型互联网分布式实践的总结，是基于 CAP 定理逐步演化而来的。其核心思想是</p><ul><li>Basically Available（基本可用）：假设系统出现了不可预知的故障，但是还能使用，只是相比较正常的系统而言，会有响应时间上的损失或功能上的损失。</li><li>Soft State（软状态）：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据信息延时。</li><li>Eventually Consistent（最终一致性）：系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问最终都能够获取到最新的值。</li></ul><h3 id="4分布式事务"><a class="markdownIt-Anchor" href="#4分布式事务"></a> 4.分布式事务</h3><h4 id="41-二阶段提交"><a class="markdownIt-Anchor" href="#41-二阶段提交"></a> 4.1 二阶段提交</h4><p>二阶段提交（Two-phase Commit）：为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种演算法。</p><p>三个假设</p><ol><li>引入协调者（Coordinator）和参与者（Participants），互相进行网络通信</li><li>所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上</li><li>所有节点不会永久性损坏，即使损坏后仍然可以恢复</li></ol><p>可能出现的情况</p><ol><li><p>Coordinator 不宕机，Participants 宕机，需要进行回滚操作。</p><p>回滚：在 Prepare 阶段，如果某个事务参与者反馈失败消息，说明该节点的本地事务执行不成功，必须回滚。</p></li><li><p>Coordinator 宕机，Participants 不宕机，可以引入新的协调者，待查询状态后，重复二阶段提交。</p></li><li><p>Coordinator 宕机，Participants 宕机。无法确认状态，需要数据库管理员的介入，防止数据库进入一个不一致的状态。</p></li></ol><p>二阶段提交需要注意的问题</p><ol><li><p>性能问题</p><p>两阶段提交需要多次节点间的网络通信，耗时过大，资源需要进行锁定，徒增资源等待时间。</p></li><li><p>协调者单点故障问题</p><p>如果事务协调者节点宕机，需要另起新的协调者，否则参与者处于中间状态无法完成事务。</p></li><li><p>网络分区带来的数据不一致</p><p>一部分参与者收到了 Commit 消息，另一部分参与者没收到 Commit 消息，会导致节点之间数据不一致。</p></li></ol><p>思考</p><ol><li><p>日志被保存在 [可靠] 的存储设备上。如何保证这一点？</p><p>参考<a href="https://zhuanlan.zhihu.com/p/509856830">分布式日志存储架构设计方案 - 知乎 (zhihu.com)</a></p></li><li><p>参与者 Commit 了，但 Ack 信息协调者没收到怎么办？</p><p>参考<a href="https://zhuanlan.zhihu.com/p/243324226">12.4 故障恢复（Crash Recovery） - 知乎 (zhihu.com)</a></p></li></ol><h4 id="42-三阶段提交"><a class="markdownIt-Anchor" href="#42-三阶段提交"></a> 4.2 三阶段提交</h4><p>三阶段提交 vs 二阶段提交</p><p>三阶段提交将二阶段提交中的 Prepare 阶段拆成两部分：CanCommit 和 PreCommit 机制。</p><ul><li>Coordinator 在 CanCommit 阶段向 Participants 询问是否可以执行</li><li>Participants 回复可以则进入 PreCommit 阶段，失败或超时则退出</li><li>在 PreCommit 阶段 Coordinator 再次向 Participants 询问是否可以执行</li><li>Participants 回复可以则进入 DoCommit 阶段，失败或超时则 Rollback</li><li>在 DoCommit 阶段 Coordinator 向所有人提交事务请求</li><li>Participants 在收到 Coordinator 的事务请求并执行之后提交反馈结果 Ack 给 Coordinator</li></ul><p>这解决了两个问题</p><ol><li>单点故障问题</li><li>阻塞问题</li></ol><p>另外引入超时机制，在等待超时之后，会继续进行事务的提交。</p><p>思考</p><p>三阶段缓和了二阶段面临的单点故障问题，但依然未解决以下问题</p><ol><li>性能问题</li><li>网络分区场景带来的数据一致性问题</li></ol><h4 id="43-mvcc"><a class="markdownIt-Anchor" href="#43-mvcc"></a> 4.3 MVCC</h4><blockquote><p>在数据库的实际使用过程中，可能会出现资源竞争导致数据不一致等问题。需要有一种机制来保证数据的正确访问和修改，这种机制就是数据库的并发控制。其中乐观并发控制、悲观并发控制和多版本并发控制是数据库并发控制主要采用的技术手段。</p></blockquote><p>悲观并发控制，也称为“悲观锁”。操作数据时直接把数据锁住，直到操作完成之后才会释放锁；上锁期间其他人不能修改数据。</p><p>乐观并发控制，也称为“乐观锁”。不会上锁，只是在执行更新时判断别人是否修改数据，只有冲突时才放弃操作。</p><p>多版本并发控制 MVCC，维持一个数据的多个版本使读写操作没有冲突。所以既不会阻塞写，也不会阻塞读。MVCC 为每个修改保存一个版本，并和事务的时间戳相关联。可以提高并发性能，解决脏读的问题。</p><blockquote><p>Spanner 论文里通过 TrueTime API 提供一个物理时钟的方式。服务器时钟偏差在 1 到 7ms 之间。</p><p>另外一种时间戳的实现：时间戳预言机（TSO），采用中心化的授时方式，所有协调者向中心化节点获取时钟。优点是算法简单，实现方便，但需要每个节点都与它进行交互，会产生一些网络通信的成本。TSO 的授时中就需要考虑低延迟，高性能以及更好的容错性。</p></blockquote><h3 id="5共识协议"><a class="markdownIt-Anchor" href="#5共识协议"></a> 5.共识协议</h3><h4 id="51-quorum-nwr-模型"><a class="markdownIt-Anchor" href="#51-quorum-nwr-模型"></a> 5.1 Quorum NWR 模型</h4><p>Quorum NWR 三要素</p><ul><li><p>N：在分布式存储系统中，有多少份备份数据</p></li><li><p>W：代表一次成功的更新数据操作要求至少有 w 份数据成功写入</p></li><li><p>R：代表一次成功的读取数据操作要求至少有 R 份数据成功读取</p></li></ul><p>为了保证强一致性，需要保证 W+R &gt; N</p><p>Quorum NWR 模型将 CAP 的选择交给用户，是一种简化版的一致性模型。</p><p>思考</p><ul><li><p>引起的并发更新问题</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">副本1</th><th style="text-align:center">副本2</th><th style="text-align:center">副本3</th></tr></thead><tbody><tr><td style="text-align:center">初始值(v)</td><td style="text-align:center">v1=1</td><td style="text-align:center">v1=1</td><td style="text-align:center">v1=1</td></tr><tr><td style="text-align:center">第一次写</td><td style="text-align:center">v2=2</td><td style="text-align:center">v2=2</td><td style="text-align:center">v1=1</td></tr><tr><td style="text-align:center">第二次写</td><td style="text-align:center">v3=3</td><td style="text-align:center">v2=2</td><td style="text-align:center">v2=2</td></tr></tbody></table><p>如果读取副本 1 和副本 2，得出 v=3 的结论</p><p>如果读取副本 2 和副本 3，得吃 v=2 的结论</p></li><li><p>问题的根源：允许数据被覆盖</p></li></ul><h4 id="52-raft-协议"><a class="markdownIt-Anchor" href="#52-raft-协议"></a> 5.2 RAFT 协议</h4><p>Raft 协议是一种分布式一致性算法（共识算法），即使出现部分节点故障，网络延时等情况，也不影响各节点，进而提高系统的整体可用性。Raft 是使用较为广泛的分布式协议。从某种角度来看，RAFT 也使用了 Quorum 机制。</p><ul><li>Leader - 领导者，通常一个系统中是一主（Leader）多从（Follower）。Leader 负责处理所有的客户端请求，并向 Follower 同步请求日志，当日志同步到大多数节点上后，通知 Follower 提交日志。</li><li>Follower - 跟随者，不会发生任何请求。接受并持久化 Leader 同步的日志，在 Leader 告知日志可以提交后，再提交日志。当 Leader 出现故障时，主动推荐自己为 Candidate。</li><li>Candidate - 备选者，Leader 选举过程中的临时角色。向其他节点发送请求投票信息。如果获得大多数选票，则晋升为 Leader。</li><li>Log（日志）：节点之间同步的信息，以只追加写的方式进行同步，解决了数据被覆盖的问题。</li><li>Term（任期号）：单调递增，每个 Term 内最多只有一个 Leader。</li><li>Committed：日志被复制到多数派节点，即可认为已经被提交。</li><li>Applied：日志被应用到本地状态机，执行了 log 中的命令，修改了内存状态</li></ul><p>Leader 选举过程</p><ol><li>初始全部为 Follower</li><li>Current Term + 1</li><li>选举自己</li><li>向其它参与者发起 RequestVote 请求，retry 直到遇到以下几种情况<ul><li>收到多数派请求，成为 Leader，并发送心跳</li><li>收到其它 Leader 的请求，转为 Follower，更新自己的 Term</li><li>收到部分请求，但未达到多数派，选举超时，随机 timeout 开始下一轮</li></ul></li></ol><p>两个规则</p><ul><li>在一个任期内每个参与者最多投一票（持久化）</li><li>要成为 Leader，必须拿到多数投票</li></ul><p>Log Replication 过程：新 Leader 产生，Leader 和 Follower 不同步，Leader 强制覆盖 Follower 的不同步的日志</p><ol><li>Leader 收到写请求 w</li><li>将 w 写入本地 log</li><li>向其它 Follower 发起 AppendEntries RPC</li><li>等待多数派回复<ul><li>更新本地状态机，返回给客户端</li><li>发送下一个心跳通知 Follower 上一个 Log 已经被 Committed</li><li>Follower 也根据命令应用本地状态机</li></ul></li><li>若 Follwer 有问题，则 Leader 会一直 retry</li><li>若 Leader 有问题，则切主</li></ol><p>切主：当 Leader 出现问题时，就需要重新选举。</p><ol><li>Leader 发现失去 Follower 的响应，失去 Leader 身份</li><li>两个 Follower 之间一段时间未收到心跳，重新进行选举，选出新的 Leader，此时发生了切主</li><li>Leader 重启，以 Follower 的身份加入进来</li></ol><p>问题：旧 Leader 未失去身份，新 Leader 已经选出，产生了“双主”，如何解决？“双主”的存在带来的主要问题就是 Stale Read，一种读取历史数据版本的机制。</p><p>Stale Read</p><p>发生 Leader 切换，old leader 收到了读请求。如果直接响应，可能会有 Stale Read。解决方案就是保证读的强一致性。</p><p>读操作在 lease timeout 内，默认自己是 leader；不是则发起一次 heartbeat。等待 Commit Index 应用到状态机。</p><p>Election timeout &gt; lease timeout：新 leader 上任，自从上次心跳之后一定超过了 Election timeout 的时间，旧 leader 大概率能够发现自己的 Lease 已经过期。</p><h4 id="53-paxos-协议"><a class="markdownIt-Anchor" href="#53-paxos-协议"></a> 5.3 Paxos 协议</h4><p>Paxos 算法与 RAFT 算法区别</p><ol><li>Multi-Paxos 可以并发修改日志，而 Raft 写日志操作必须是连续的</li><li>Multi-Paxos 可以随机选主，不必要求最新最全的节点当选 Leader</li></ol><p>Paxos 的优势：写入并发性能高，所有节点都能写入</p><p>Paxos 的劣势：没有一个节点有完整的最新的数据，恢复流程复杂，需要同步历史记录</p><p>Paxos 中有三种角色：Proposer（提出者）、Acceptor（决策者）、Learner（决策学习者）</p><p>Proposer 与 Acceptor 之间的协作</p><ol><li>Proposer 获取 Proposal ID n，并向所有 Acceptor 广播</li><li>Acceptor 接收到信息后进行判断，如果 n &gt; min_proposal 则使 min_proposal := n，并返回 accepted_value 和 Proposal</li><li>Proposer 接收过半数回复，选择 Proposal 最大的 accepted_value 作为共识</li><li>第二阶段，广播 Accept(n, value) 到所有节点</li><li>Acceptor 接收到信息后再次判断，如果 n &gt; min_proposal 则使 min_proposal := n， accepted_value := value，本地持久化后返回</li><li>Proposer 接收过半请求，若有结果 &gt; n，更新新的提议，跳转回第 1 步</li></ol><h3 id="6分布式实践"><a class="markdownIt-Anchor" href="#6分布式实践"></a> 6.分布式实践</h3><h4 id="61-mapreduce"><a class="markdownIt-Anchor" href="#61-mapreduce"></a> 6.1 MapReduce</h4><ul><li>Mapper：将输入分解为多个 Job 来并行处理。彼此之间几乎没有依赖关系。</li><li>Shuffler：将 mapper 结果打乱，防止数据倾斜。</li><li>Reducer：对 map 阶段的结果进行全局汇总。</li></ul><p>相关资料<a href="https://zhuanlan.zhihu.com/p/408392107">为什么 MapReduce 再次流行起来了？ - 知乎 (zhihu.com)</a></p><h4 id="62-分布式-kv"><a class="markdownIt-Anchor" href="#62-分布式-kv"></a> 6.2 分布式 KV</h4><p>相关资料<a href="https://juejin.cn/post/6844903504964747278">小米开源分布式KV存储系统Pegasus - 掘金 (juejin.cn)</a></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>分布式概述</p><ul><li>什么是分布式</li><li>分布式的必要性</li><li>常见的分布式系统</li></ul><p>系统模型</p><ul><li>故障模型</li><li>拜占庭将军问题</li><li>共识与一致性</li><li>时间和事件顺序</li></ul><p>基础理论</p><ul><li>CAP 理论</li><li>ACID 理论</li><li>BASE 理论</li></ul><p>分布式事务</p><ul><li>二阶段提交</li><li>三阶段提交</li><li>MVCC</li></ul><p>共识协议</p><ul><li>Quorum NWR 算法</li><li>Raft 协议</li><li>Paxos 协议</li></ul><p>分布式实践</p><ul><li>MapReduce</li><li>分布式 KV</li></ul><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/107439021">拜占庭将军问题 (The Byzantine Generals Problem) - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/338835258">CAP理论该怎么理解？为什么是三选二？为什么是CP或者AP？面试题有哪些？ - 知乎 (zhihu.com)</a></p><p><a href="https://juejin.cn/post/7016165148020703246">看一遍就理解：MVCC原理详解 - 掘金 (juejin.cn)</a></p><p><a href="https://zhuanlan.zhihu.com/p/266850866">乐观锁、悲观锁和MVCC，今天让你一次搞懂 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/404786050">Raft 一致性协议完整解析 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/361108372">理解 Paxos 协议——浅谈分布式一致性协议 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文已收录到&lt;a href=&quot;https://juejin.cn/post/7196300179998228535&quot;&gt;分布式理论 | 青训营笔记 - 掘金 (juejin.cn)&lt;/a&gt;，主要记录了对分布式理论的学习</summary>
    
    
    
    <category term="golang" scheme="https://s-chance.github.io/categories/golang/"/>
    
    
    <category term="学习笔记" scheme="https://s-chance.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="青训营" scheme="https://s-chance.github.io/tags/%E9%9D%92%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>架构初探</title>
    <link href="https://s-chance.github.io/2023/02/03/golang-day7/"/>
    <id>https://s-chance.github.io/2023/02/03/golang-day7/</id>
    <published>2023-02-03T13:34:37.000Z</published>
    <updated>2023-02-03T13:42:44.427Z</updated>
    
    <content type="html"><![CDATA[<p>本文已收录到<a href="https://juejin.cn/post/7195891149012795452">架构初探 | 青训营笔记 - 掘金 (juejin.cn)</a>，主要记录了对架构分析设计的学习<span id="more"></span></p><h2 id="架构初探"><a class="markdownIt-Anchor" href="#架构初探"></a> 架构初探</h2><h3 id="1-什么是架构"><a class="markdownIt-Anchor" href="#1-什么是架构"></a> 1. 什么是架构</h3><p><strong>定义</strong></p><p>架构，又称软件架构，是有关软件整体结构与组件的抽象描述，用于指导软件系统各个方面的设计。</p><p>实现一个软件有很多种方法，架构在方法选择上起着至关重要的指导作用。</p><p>架构的重要性</p><ul><li>地基没打好，大厦容易倒</li><li>地基坚实了，大厦才能盖得高</li><li>站在巨人肩膀上，才能看得远</li></ul><h4 id="11-问题"><a class="markdownIt-Anchor" href="#11-问题"></a> 1.1 问题</h4><ul><li>如何设计</li><li>如何开发</li><li>如何运营</li><li>…</li></ul><h4 id="12-单机"><a class="markdownIt-Anchor" href="#12-单机"></a> 1.2 单机</h4><p>软件系统需要对外提供服务。单机，就是把所有功能都实现在一个进程里，并部署在一台机器上</p><p>优点：简单，是最基本的架构</p><p>缺点</p><ul><li>单体服务存在架构瓶颈（高并发连接问题，是单体架构本身的设计缺陷）</li><li>运维的时候需要停服，届时用户无法使用服务</li></ul><p>单机服务的模式除了简单之外没有任何优点。当今互联网时代，单机服务的形态一般只适合出现在预研或初创阶段，但凡业务有发展和迭代的需求，就应该优先快速做架构迭代。</p><h4 id="13-单体-垂直应用-垂直切分"><a class="markdownIt-Anchor" href="#13-单体-垂直应用-垂直切分"></a> 1.3 单体、垂直应用 | 垂直切分</h4><p>把进程部署在多个机器上，并引入负载均衡层，经过这样的垂直切分，就来到了单体架构。负载均衡层用于引导用户去正常工作的机器。</p><p>在单体架构的基础上进一步地再把不同应用的代码从之前的一个大的进程中拆分出来，就来到了垂直应用架构。</p><ul><li>单体架构通过分布式部署逐步演化为分布式架构，垂直应用架构就是一种分布式架构。</li><li>垂直应用架构：按应用垂直切分单体并进行分布式部署的架构。</li><li>优点<ul><li>水平扩容</li><li>运维不需要停服</li></ul></li><li>缺点<ul><li>职责太多，开发效率不高</li><li>爆炸半径大（即影响范围大），小变动可能会引起大范围的问题</li></ul></li></ul><p>根据应用把架构做垂直拆分仍存在缺陷，于是演化出了根据模块/职责对架构进行水平拆分。</p><h4 id="14-soa-微服务-水平切分"><a class="markdownIt-Anchor" href="#14-soa-微服务-水平切分"></a> 1.4 SOA、微服务 | 水平切分</h4><p>把原本包含了众多复杂逻辑的进程按照功能单元抽象成多个服务，并为它们之间的通信定义标准，便得到了SOA架构。</p><p>SOA(Service-Oriented Architecture)</p><ul><li>将应用的不同功能单元抽象为服务</li><li>定义服务之间的通信标准</li></ul><p>两个重要概念</p><ul><li>服务：根据功能抽象出来的概念。比如，处理用户登录信息的 Passport 服务，负责持久化存储的数据库服务，以及为了加快查询速度的缓存服务等。</li><li>通信标准：服务之间通信的基石。</li></ul><p>为了服务之间更好的通信，有两个大的发展方向：中心化和去中心化。由于中心化的方案较重，拓展性差，普及性不高。这里就考虑去中心化方向。去中心化方向的最终形态就是微服务架构。</p><ul><li><p>微服务架构：SOA 的去中心化演进方向</p></li><li><p>优点</p><ul><li>不同模块的开发者可以各司其职，开发迭代效率得到显著提高</li><li>各个服务独立运维，变更操作的影响面可控，应用整体的稳定性得到了提高</li></ul></li></ul><p><strong>垂直切分和水平切分带来的一系列问题</strong></p><ul><li>单机部署演进而来的分布式架构，存在数据一致性问题</li><li>服务的不断拓展，依赖关系的复杂化，如何实现高可用</li><li>多个微服务的管理运维问题</li><li>微服务的目标是强化单一职责，控制爆炸半径，在解耦和过微之间取舍</li></ul><h4 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h4><p>架构的演进初衷</p><ul><li>需求量越来越大，需要增加人手</li><li>整体逻辑越做越复杂，需要分工合作</li></ul><p>架构的演进思路</p><ul><li>垂直切分：按照应用切分</li><li>水平切分：按照服务切分</li></ul><h3 id="2企业级后端架构剖析"><a class="markdownIt-Anchor" href="#2企业级后端架构剖析"></a> 2.企业级后端架构剖析</h3><h4 id="21-云计算"><a class="markdownIt-Anchor" href="#21-云计算"></a> 2.1 云计算</h4><p>云计算是指通过软件自动化管理，提供计算资源的服务网络，是现代互联网大规模熟悉分析和存储的基石。</p><p>基础</p><ul><li>虚拟化技术：硬件（虚拟机）、操作系统（容器）、网络</li><li>编排方案：虚拟机编排方案（OpenStack）、容器编排方案（Kubernetes）</li></ul><p>架构</p><ul><li>Iaas（Infrastructure as a Service）</li><li>Paas（Platform as a Service）</li><li>SaaS（Software as a Service）</li><li>Faas（Function as a Service）</li></ul><h4 id="22-云原生"><a class="markdownIt-Anchor" href="#22-云原生"></a> 2.2 云原生</h4><p>云原生，实际是云原生计算的简称，它是云计算发展到现在的一种形态。</p><p>云原生技术为在公有云、私有云、混合云等新型的动态环境中构建和运行可弹性拓展的应用提供了可能性。它的代表技术有</p><ul><li>容器化</li><li>服务网格</li><li>微服务</li><li>不可变基础架构</li><li>声明式 API</li></ul><p>基于这些技术，开发者可以构建出容错性好、易于管理、具备较好观测性的云服务。结合可靠的自动化机制，服务可以轻松应对频繁和可预测的重大变更。</p><p>云原生主要涉及四个大方面</p><ul><li>弹性资源：基于虚拟化容器以及灵活的编排调度机制，可以为云服务提供快速扩缩容能力，而且极大程度地提高了物理资源的利用率。在这方面，kubernetes 技术已经称为了业界的标准</li><li>微服务架构：微服务架构也是云原生的重要基石之一。依托于功能单元解构，使得云服务具备了快速迭代的可能，业务得以迅速发展；统一的通信标准能够帮助越来越多的组件加入到云原生的大家庭，同时也使得各组件之间的交互变的更容易</li><li>DevOps：设计-&gt;开发-&gt;测试-&gt;交付-&gt;开发-&gt;测试-&gt;交付，自动化的流程使得软件的工作流程更高效，将微服务架构的优势发挥的淋漓尽致</li><li>服务网格：如果说微服务架构的重要进步，是将庞大的单体服务按照业务功能解耦开来，那么，服务网格的重要进步就是将业务逻辑与网络通信和治理解耦开来。业务不再需要关心异构系统中 RPC 中间件治理能力的不统一，也使得复杂的治理能力的落地成为可能</li></ul><h5 id="221-弹性计算资源"><a class="markdownIt-Anchor" href="#221-弹性计算资源"></a> 2.2.1 弹性计算资源</h5><p>弹性计算资源类型</p><ul><li>服务资源调度：微服务和大服务</li><li>计算资源调度：在线和离线</li><li>消息队列：在线和离线</li></ul><h5 id="222-弹性存储资源"><a class="markdownIt-Anchor" href="#222-弹性存储资源"></a> 2.2.2 弹性存储资源</h5><p>弹性存储资源类型</p><ul><li>典型：对象和数据</li><li>关系型数据库</li><li>元数据：服务发现</li><li>NoSQL</li></ul><p>将存储资源视为服务</p><h5 id="223-devops"><a class="markdownIt-Anchor" href="#223-devops"></a> 2.2.3 DevOps</h5><p>DevOps 是云原生时代软件交付的利器，贯穿整个软件开发周期。</p><p>结合自动化流程，提高软件开发、交付效率</p><h5 id="224-微服务架构"><a class="markdownIt-Anchor" href="#224-微服务架构"></a> 2.2.4 微服务架构</h5><p>通信标准</p><ul><li>HTTP（RESTful、API）</li><li>RPC（Thrift、gRPC）</li></ul><p>微服务中间件  RPC vs HTTP</p><ul><li>性能</li><li>服务治理</li><li>协议可解释性</li></ul><p>云原生场景下，微服务大可不必在业务逻辑中实现符合通信标准的交互逻辑，而是交给框架来做。</p><h5 id="225-服务网格"><a class="markdownIt-Anchor" href="#225-服务网格"></a> 2.2.5 服务网格</h5><p>服务网络（Service Mesh）</p><ul><li>微服务之间通讯的中间层</li><li>高性能网络代理</li><li>业务代码与治理解耦</li></ul><p>相比较于 RPC/HTTP 框架</p><ul><li>异构系统治理统一化</li><li>与业务进程解耦，生命周期易管理</li></ul><h3 id="企业级后端架构的挑战"><a class="markdownIt-Anchor" href="#企业级后端架构的挑战"></a> 企业级后端架构的挑战</h3><p><strong>问题</strong></p><ul><li>基础设施层面：<ul><li>物理资源是运有限的，机器和带宽</li><li>资源利用率受制于部署服务</li></ul></li><li>用户层面<ul><li>网络通信开销较大</li><li>网络抖动导致运维成本提高</li><li>异构环境下，不同实例资源水位不均</li></ul></li></ul><h4 id="31-离在线资源并池"><a class="markdownIt-Anchor" href="#31-离在线资源并池"></a> 3.1 离在线资源并池</h4><p>核心收益</p><ul><li>降低物理资源成本</li><li>提供更多的弹性资源，增加收入</li></ul><p>解决思路：离在线并池</p><ul><li>在线业务的特点<ul><li>IO 密集型为主</li><li>潮汐性、实时性</li></ul></li><li>离线业务的特点<ul><li>计算密集型占多数</li><li>非实时性</li></ul></li></ul><p>在同一个机器做离在线隔离，使用自动扩缩容</p><h4 id="32-自动扩缩容"><a class="markdownIt-Anchor" href="#32-自动扩缩容"></a> 3.2 自动扩缩容</h4><p>核心收益：降低业务成本</p><p>解决思路：自动扩缩容，利用在线业务潮汐性自动扩缩容</p><p>扩缩容依据的指标，微服务亲和性部署</p><h4 id="33-微服务亲和性部署"><a class="markdownIt-Anchor" href="#33-微服务亲和性部署"></a> 3.3 微服务亲和性部署</h4><p>核心收益</p><ul><li>降低业务成本</li><li>提高服务可用性</li></ul><p>解决思路：微服务亲和性部署</p><ul><li>将满足亲和性条件的容器调度到一台宿主机</li><li>微服务中间件与服务网格通过共享内存通信</li><li>服务网格控制面实施灵活、动态的流量调度</li></ul><h4 id="34-流量治理"><a class="markdownIt-Anchor" href="#34-流量治理"></a> 3.4 流量治理</h4><p>核心收益</p><ul><li>提高微服务调用容错性</li><li>容灾</li><li>进一步提高开发效率，DevOps 发挥到极致</li></ul><p>解决思路：基于微服务中间件和服务网格的流量治理</p><ul><li>熔断、重试</li><li>单元化</li><li>复杂环境（功能、预览）的流量调度</li></ul><h4 id="cpu-水位负载均衡"><a class="markdownIt-Anchor" href="#cpu-水位负载均衡"></a> CPU 水位负载均衡</h4><p>核心收益</p><ul><li>打平异构环境算力差异</li><li>为自动扩缩容提供正向输入</li></ul><p>解决思路：CPU 水位负载均衡</p><ul><li>Iaas：提供资源探针</li><li>服务网格：动态负载均衡</li></ul><h3 id="4-后端架构实战"><a class="markdownIt-Anchor" href="#4-后端架构实战"></a> 4. 后端架构实战</h3><p><strong>问题提炼</strong></p><p>输入</p><ul><li>服务网格数据面：支持带权重的负载均衡策略</li><li>注册中心存储了所有容器的权重信息</li><li>宿主机能够提供容器的资源使用情况和物理资源信息（如 CPU 型号）</li></ul><p>关键点</p><ul><li>紧急回滚能力</li><li>大规模</li><li>极端场景</li></ul><h4 id="41-自适应静态权重"><a class="markdownIt-Anchor" href="#41-自适应静态权重"></a> 4.1 自适应静态权重</h4><p>方案</p><ul><li>采集宿主机物理资源信息</li><li>调整容器注册的权重</li></ul><p>优点</p><ul><li>复杂度低</li><li>完全分布式，可用性高</li><li>微服务中间件无适配成本</li></ul><p>缺点</p><ul><li>无紧急回滚能力</li><li>缺乏运行时自适应能力</li></ul><h4 id="42-自适应动态权重-alpha"><a class="markdownIt-Anchor" href="#42-自适应动态权重-alpha"></a> 4.2 自适应动态权重 Alpha</h4><p>方案</p><ul><li>容器动态权重的自适应调整</li><li>服务网格的服务发现和流量调度能力</li></ul><p>优点</p><ul><li>解决无法紧急回滚的问题</li><li>运行时权重自适应</li></ul><p>缺点：过度流量倾斜可能会有异常情况</p><h4 id="43-自适应动态权重-beta"><a class="markdownIt-Anchor" href="#43-自适应动态权重-beta"></a> 4.3 自适应动态权重 Beta</h4><p>方案：服务网格上报 RPC 指标</p><p>优点：极端场景的处理成为可能</p><p>缺点</p><ul><li>时序数据库压力较大</li><li>动态权重决策中心职责越来越多，迭代 -&gt; 变更 -&gt; 风险</li></ul><h4 id="44-自适应动态权重-release"><a class="markdownIt-Anchor" href="#44-自适应动态权重-release"></a> 4.4 自适应动态权重 Release</h4><p>演进方向</p><ul><li>微服务化</li><li>引入消息队列削峰、解耦</li><li>离在线链路切分</li><li>梳理强弱依赖</li><li>解决在线分析引擎的数据一致性问题：一致性哈希</li><li>解决时序数据库压力：将其作为旁路工具，采用纯内存的在线分析引擎进行实时策略计算</li><li>离线分析：使用消息队列解耦、削峰</li><li>离线回馈在线</li></ul><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>没有最好的架构，只有最合适的架构</p><p>架构设计的流程</p><ul><li>需求先行。弄清楚要解决什么问题</li><li>业界调研。业界都有哪些解决方案可供参考</li><li>技术选型。内部/社区都有哪些基础组件</li><li>异常情况。考虑清除应对各种异常问题的方案</li></ul><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/136587858">软件架构的演变-单体架构，垂直架构，分布式架构，SOA架构和微服务架构的演变历程 - 知乎 </a></p><p><a href="https://zhuanlan.zhihu.com/p/26302012">水平拆分 &amp; 垂直拆分 - 知乎 </a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文已收录到&lt;a href=&quot;https://juejin.cn/post/7195891149012795452&quot;&gt;架构初探 | 青训营笔记 - 掘金 (juejin.cn)&lt;/a&gt;，主要记录了对架构分析设计的学习</summary>
    
    
    
    <category term="golang" scheme="https://s-chance.github.io/categories/golang/"/>
    
    
    <category term="学习笔记" scheme="https://s-chance.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="青训营" scheme="https://s-chance.github.io/tags/%E9%9D%92%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>规则引擎与设计实现</title>
    <link href="https://s-chance.github.io/2023/02/03/golang-day6/"/>
    <id>https://s-chance.github.io/2023/02/03/golang-day6/</id>
    <published>2023-02-03T13:26:34.000Z</published>
    <updated>2023-02-03T13:43:56.599Z</updated>
    
    <content type="html"><![CDATA[<p>本文已收录到<a href="https://juejin.cn/post/7195554661318967351">规则引擎与设计实现 | 青训营笔记 - 掘金 (juejin.cn)</a>，主要记录了对规则引擎的学习<span id="more"></span></p><h2 id="规则引擎与设计实现"><a class="markdownIt-Anchor" href="#规则引擎与设计实现"></a> 规则引擎与设计实现</h2><blockquote><p>规则引擎的组成部分及应用场景</p><p>规则引擎的核心原理——编译原理的相关概念</p><p>设计并实现一个规则引擎——YoungEngine</p><p>实现一个Web版规则引擎</p></blockquote><h3 id="1-认识规则引擎"><a class="markdownIt-Anchor" href="#1-认识规则引擎"></a> 1. 认识规则引擎</h3><h4 id="规则引擎的定义"><a class="markdownIt-Anchor" href="#规则引擎的定义"></a> 规则引擎的定义</h4><ul><li><p>规则引擎是一种嵌入在应用程序中的组件，实现了将业务决策从应用程序代码中分离出来，并使用预定义的语义模块编写业务决策。接收数据输入，解释业务规则，并根据业务逻辑做出业务决策。</p></li><li><p>解决开发人员重复编码的问题</p><p>业务决策与服务本身解耦，提高服务的可维护性，缩短开发路径，提高效率</p></li></ul><h4 id="组成部分"><a class="markdownIt-Anchor" href="#组成部分"></a> 组成部分</h4><ul><li>数据输入<ul><li>支持接受使用预定义的语义编写的规则作为策略集。比如“price &gt; 500”</li><li>接受业务的数据作为执行过程中的参数。比如价格、标签等</li></ul></li><li>规则理解<ul><li>能够按照预先定义的词法、语法、优先级、运算符等正确理解业务规则所表达的语义。</li></ul></li><li>规则执行<ul><li>根据执行时输入的参数对策略集中的规则进行正确的解释和执行。</li><li>同时对规则执行过程中的数据类型进行检查，确保执行结果的正确。</li></ul></li></ul><h4 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h4><ul><li>风控对抗。快速识别和对抗，以实现最好的风控识别效果。</li><li>活动策略运营。提高运营策略的迭代效率，方便新玩法的探索和效果验证。</li><li>数据分析和清洗。方便快捷地产出所需要的数据。</li></ul><h3 id="2编译原理基本概念"><a class="markdownIt-Anchor" href="#2编译原理基本概念"></a> 2.编译原理基本概念</h3><p>规则引擎和编译原理具有一定的关联性。它们都有理解、执行、输入输出的流程。</p><ul><li>理解：词法分析、语法分析</li><li>执行：抽象语法树</li><li>输入输出：参数注入、类型检查</li></ul><h4 id="词法分析-lexicel-analysis"><a class="markdownIt-Anchor" href="#词法分析-lexicel-analysis"></a> 词法分析 Lexicel Analysis</h4><p>词法分析就是把源代码字符串转换为词法单元（Token）的过程。</p><ul><li><p>识别Token：有限自动机（Finite-State Automaton）</p><p>有限自动机就是一个状态机，它的状态数量是有限的。该状态在任何一个状态，基于输入的字符，都能做一个确定的状态转换。</p></li></ul><h4 id="语法分析-syntax-analysis"><a class="markdownIt-Anchor" href="#语法分析-syntax-analysis"></a> 语法分析 Syntax Analysis</h4><p>语法分析就是在词法分析的基础上，识别表达式的语法结构的过程。</p><ul><li>抽象语法树：表达式的语法结构可以用树来表示，其每个节点（子树）是一个语法单元，这个单元的构成规则就叫语法。每个节点还可以有下级节点。</li></ul><h4 id="抽象语法树-abstract-syntax-tree"><a class="markdownIt-Anchor" href="#抽象语法树-abstract-syntax-tree"></a> 抽象语法树 Abstract Syntax Tree</h4><ul><li><p>上下文无关语法 Context-Free Grammar</p><p>语言句子无需考虑上下文，就可以判断正确性。可以使用巴克斯范式（BNF）来表达。</p><p>产生式：一个表达式可以由另外已知类型的表达式或者符号推导产生。</p><p>内置符号：字面量（string、bool、number）标识符、运算符。</p><p>一个基础表达式可以由常量（string、bool、number）或标识符（identifier），一个乘法表达式可以由基础表达式或者乘法表达式+基础表达式组成。</p></li><li><p>递归下降算法 Recursive Descent Parsing</p><p>递归下降算法就是自顶向下构造语法树，不断地对Token进行语法展开（下降），展开过程中可能会遇到递归的情况。</p></li></ul><h4 id="类型检查"><a class="markdownIt-Anchor" href="#类型检查"></a> 类型检查</h4><ul><li><p>类型综合</p><p>根据表达式的类型构造出父表达式的类型。例如，表达式A+B的类型是根据A和B的类型定义的。</p></li><li><p>编译时检查和运行时检查</p><p>类型检查可以发生在表达式的编译阶段，即在构造语法树的阶段，也可以发生在执行时的阶段。</p><ul><li>编译时：需要提前声明参数的类型，在构建语法树过程中进行类型检查</li><li>执行时：可以根据执行时的参数输入的值类型，在执行过程中进行类型检查</li></ul></li></ul><h3 id="3设计一个规则引擎"><a class="markdownIt-Anchor" href="#3设计一个规则引擎"></a> 3.设计一个规则引擎</h3><h4 id="设计目标"><a class="markdownIt-Anchor" href="#设计目标"></a> 设计目标</h4><p>设计一个规则引擎，支持特定的词法、运算符、数据类型和优先级，并且支持基于以上预定义语法的规则表达式的编译和执行。</p><ul><li>词法（合法Token）：参数、布尔值、字符串、十进制int、十进制float、预定义运算符的规定写法</li><li>数据类型：字符串、布尔值、十进制int、十进制float</li><li>运算符：一元运算符、二元运算符、逻辑操作符、括号</li><li>优先级：各种运算符的优先级定义</li></ul><h4 id="词法分析"><a class="markdownIt-Anchor" href="#词法分析"></a> 词法分析</h4><ul><li>设计词法分析的状态机</li></ul><h4 id="语法分析"><a class="markdownIt-Anchor" href="#语法分析"></a> 语法分析</h4><ul><li>优先级的表达</li><li>语法树结构</li></ul><h4 id="语法树的执行与类型检查"><a class="markdownIt-Anchor" href="#语法树的执行与类型检查"></a> 语法树的执行与类型检查</h4><ul><li><p>语法树执行</p><p>预先定义好每种操作符的执行逻辑</p><p>对抽象语法树进行后缀遍历执行，即</p><ul><li>先执行左子树，得到左节点的值</li><li>再执行右子树，得到右节点的值</li><li>最后根据根节点的操作符执行得到根节点的值</li></ul></li><li><p>类型检查</p><p>检查时机：执行时检查</p><p>检查方法：在一个节点的左右子节点执行完成后，分别校验左右子节点的类型是否符合对应操作符的类型检查预设规则。</p><ul><li>‘&gt;’ 符号要求左右子节点的值都存在且为int或float</li><li>‘!’ 符号要求左节点为空且右节点的值为bool</li></ul></li></ul><h3 id="4规则引擎的实现"><a class="markdownIt-Anchor" href="#4规则引擎的实现"></a> 4.规则引擎的实现</h3><p>可参考<a href="https://github.com/qimengxingyuan/young_engine">qimengxingyuan/young_engine: 简单的规则引擎 </a>实现。</p><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><p><a href="https://juejin.cn/post/7193363381804335161/#heading-11">【后端专场 学习资料三】第五届字节跳动青训营</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文已收录到&lt;a href=&quot;https://juejin.cn/post/7195554661318967351&quot;&gt;规则引擎与设计实现 | 青训营笔记 - 掘金 (juejin.cn)&lt;/a&gt;，主要记录了对规则引擎的学习</summary>
    
    
    
    <category term="golang" scheme="https://s-chance.github.io/categories/golang/"/>
    
    
    <category term="学习笔记" scheme="https://s-chance.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="青训营" scheme="https://s-chance.github.io/tags/%E9%9D%92%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>Go 框架三件套详解</title>
    <link href="https://s-chance.github.io/2023/02/01/golang-day5/"/>
    <id>https://s-chance.github.io/2023/02/01/golang-day5/</id>
    <published>2023-02-01T11:11:20.000Z</published>
    <updated>2023-02-03T13:31:42.802Z</updated>
    
    <content type="html"><![CDATA[<p>本文已收录到<a href="https://juejin.cn/post/7195211923154010168">Go 框架三件套详解(Web/RPC/ORM) | 青训营笔记 - 掘金 (juejin.cn)</a>，主要记录了对golang web开发框架三件套的学习<span id="more"></span></p><h2 id="框架三件套详解webrpcorm"><a class="markdownIt-Anchor" href="#框架三件套详解webrpcorm"></a> 框架三件套详解(Web/RPC/ORM)</h2><blockquote><p>什么是 ORM 框架</p><p>对象关系映射（Object Relational Mapping，简称 ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。ORM框架是连接数据库的桥梁，只要提供了持久化类与表的映射关系，ORM框架在运行时就能参照映射文件的信息，把对象持久化到数据库中</p><p>什么是 RPC 框架</p><p>RPC 是远程过程调用（Remote Procedure Call）。RPC 的主要功能目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。为实现该目标，RPC 框架需提供一种透明调用机制，让使用者不必显式的区分本地调用和远程调用。</p><p>什么是 Web 框架（这里的 Web 框架在后面用 HTTP 框架来称呼）</p><p>Web 框架是用于进行 Web 开发的一套软件架构。主要是为开发者封装好了一系列与业务逻辑无关的代码实现，方便开发者专注于业务逻辑代码的编写。</p></blockquote><h3 id="1三件套介绍"><a class="markdownIt-Anchor" href="#1三件套介绍"></a> 1.三件套介绍</h3><ul><li><p>ORM 框架：<a href="https://github.com/go-gorm/gorm">GORM</a></p><p>GORM 是一个已经迭代了十多年的功能强大的 ORM 框架，拥有非常丰富的开源扩展。</p></li><li><p>RPC 框架：<a href="https://github.com/cloudwego/kitex">Kitex</a></p><p>Kitex 由字节跳动开发，是 Golang 微服务 RPC 框架，具有高性能、强可扩展的主要特点，支持多协议并且拥有丰富的开源扩展。</p></li><li><p>HTTP 框架：<a href="https://github.com/cloudwego/hertz">Hertz</a></p><p>Hertz 由字节跳动开发，是 HTTP 框架，参考了其他开源框架的优势，具有高易用性、高性能、高扩展性特点。</p></li></ul><h3 id="2-三件套的使用"><a class="markdownIt-Anchor" href="#2-三件套的使用"></a> 2. 三件套的使用</h3><h4 id="gorm-的基本使用"><a class="markdownIt-Anchor" href="#gorm-的基本使用"></a> GORM 的基本使用</h4><h5 id="gorm-的约定默认"><a class="markdownIt-Anchor" href="#gorm-的约定默认"></a> GORM 的约定（默认）</h5><ul><li>GORM 使用名为 ID 的字段作为主键</li><li>使用结构体的蛇形负数作为表名</li><li>字段名的蛇形作为列名</li><li>使用 CreatedAt、UpdatedAt 字段作为创建、更新时间</li></ul><p>示例</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 model</span></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code  <span class="type">string</span></span><br><span class="line">    Price <span class="type">uint</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为 model 定义表名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Product)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;product&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 连接数据库</span></span><br><span class="line">    <span class="comment">// 创建数据</span></span><br><span class="line">    <span class="comment">// 查询数据</span></span><br><span class="line">    <span class="comment">// 更新数据</span></span><br><span class="line">    <span class="comment">// 删除数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考<a href="https://gorm.cn/zh_CN/docs/models.html">模型定义 | GORM </a></p><h5 id="gorm-支持的数据库"><a class="markdownIt-Anchor" href="#gorm-支持的数据库"></a> GORM 支持的数据库</h5><p>GORM 目前支持 MySQL、SQLServer、PostgreSQL、SQLite。</p><p>GORM连接数据库需要提供 DSN 参数。DSN（DataSource Name）数据源名称，用来描述数据库连接信息。参考https://github.com/go-sql-driver/mysql#dsn-data-source-name</p><p>GORM 通过驱动来连接数据库，如果需要连接其它类型的数据库，可以复用/自行开发驱动。</p><p>示例</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dsn := <span class="string">&quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br></pre></td></tr></table></figure><p>参考<a href="https://gorm.cn/zh_CN/docs/connecting_to_the_database.html">连接到数据库 | GORM </a></p><h5 id="gorm-创建数据"><a class="markdownIt-Anchor" href="#gorm-创建数据"></a> GORM 创建数据</h5><p>通过 Create 方法创建数据</p><ul><li><p>创建一条数据</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := &amp;Product&#123;Code: <span class="string">&quot;D42&quot;</span>&#125;</span><br><span class="line">res := db.Create(p)</span><br></pre></td></tr></table></figure></li><li><p>创建多条数据</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">products := []*Product&#123;&#123;Code: <span class="string">&quot;D41&quot;</span>&#125;, &#123;Code: <span class="string">&quot;D42&quot;</span>&#125;, &#123;Code: <span class="string">&quot;D43&quot;</span>&#125;&#125;</span><br><span class="line">res, err := db.Create(products)</span><br></pre></td></tr></table></figure></li></ul><p>特殊的操作 Upsert ，用于创建一条唯一的数据，若该数据已存在则执行更新操作，若该数据不存在则执行插入操作。（这里的Upsert不是一个方法，而是一种思路逻辑）</p><p>Upsert 数据冲突问题</p><ul><li><p>使用 OnConflict 方法应对</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发生冲突时, 不对冲突做处理, 数据也不会改变</span></span><br><span class="line">p := &amp;Product&#123;Code: <span class="string">&quot;D42&quot;</span>, ID: <span class="number">1</span>&#125;</span><br><span class="line">db.Clauses(clause.OnConflict&#123;DoNothing: <span class="literal">true</span>&#125;).Create(&amp;p)</span><br></pre></td></tr></table></figure></li><li><p>使用默认值，在结构体中使用 default 标签为字段定义默认值</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID   <span class="type">int64</span></span><br><span class="line">    Code <span class="type">string</span> <span class="string">`gorm:&quot;default:404&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>参考<a href="https://gorm.cn/zh_CN/docs/create.html">创建 | GORM </a></p><h5 id="gorm-查询数据"><a class="markdownIt-Anchor" href="#gorm-查询数据"></a> GORM 查询数据</h5><p>使用 First 方法查询第一条数据（默认主键升序），查询不到数据则返回 ErrRecordNotFound 错误</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">u := &amp;User&#123;&#125;</span><br><span class="line">db.First(u) <span class="comment">// SELECT * FROM users ORDER BY id LIMIT 1;</span></span><br></pre></td></tr></table></figure><p>其它类似的有 Take 方法获取一条数据（没有指定排序字段）和 Last 方法获取最后一条数据（默认主键降序）。</p><p>使用 Where 方法和 Find 方法查询多条数据，需要注意使用 Find 查询多条数据时，查询不到数据也不会报错。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">users := <span class="built_in">make</span>([]*User, <span class="number">0</span>)</span><br><span class="line">result := db.Where(<span class="string">&quot;age &gt; 10&quot;</span>).Find(&amp;users) <span class="comment">// SELECT * FROM users where age &gt; 10;</span></span><br><span class="line">fmt.Println(result.RowsAffected) <span class="comment">// 返回查询到的记录数</span></span><br><span class="line"><span class="comment">// IN: SELECT * FROM users WHERE name IN (&#x27;abcd&#x27;, &#x27;defg&#x27;);</span></span><br><span class="line">db.Where(<span class="string">&quot;name IN ?&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;defg&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// LIKE: SELECT * FROM users WHERE name LIKE &#x27;%d%&#x27;;</span></span><br><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%d%&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// AND: SELECT * FROM users WHERE name = &#x27;abcd&#x27; AND age &gt;= 22;</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ? AND age &gt;= ?&quot;</span>, <span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;22&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure><p>使用结构体作为查询条件</p><p>当使用结构体作为条件查询时，GORM 只会查询非零值字段。这意味着字段值为 0、’’、false或其他零值的字段无法用于构建查询条件，可以使用 Map 来构建查询条件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;abc&quot;;</span></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;abc&quot;</span>, Age: <span class="number">0</span>&#125;).Find(&amp;users) <span class="comment">//Age为零值,不会被构建</span></span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;abc&quot; AND age = 0;</span></span><br><span class="line">db.Where(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">0</span>&#125;).Find(&amp;users)</span><br></pre></td></tr></table></figure><p>参考<a href="https://gorm.cn/zh_CN/docs/query.html">查询 | GORM </a></p><h5 id="gorm-更新数据"><a class="markdownIt-Anchor" href="#gorm-更新数据"></a> GORM 更新数据</h5><p>使用 Model 方法和 Update 以及 Updates 方法更新数据</p><ul><li><p>条件更新单个列</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27; WHERE age &gt; 18;</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;age &gt; ?&quot;</span>, <span class="number">18</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>条件更新多个列</p><ul><li><p>根据 struct 更新属性，使用 Struct 更新时，只会更新非零值字段，如果需要更新零值字段可以使用 Map 更新或使用 Select 选择字段。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE id = 111;</span></span><br><span class="line">db.Model(&amp;User&#123;ID: <span class="number">111</span>&#125;).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p>根据 map 更新属性</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18, actived=false WHERE id = 111;</span></span><br><span class="line">db.Model(&amp;User&#123;ID: <span class="number">111</span>&#125;).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;actived&quot;</span>: <span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p>更新选定字段</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27; WHERE id = 111;</span></span><br><span class="line">db.Model(&amp;User&#123;ID: <span class="number">111</span>&#125;).Select(<span class="string">&quot;name&quot;</span>).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;actived&quot;</span>: <span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>SQL 表达式更新</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UPDATE &quot;products&quot; SET &quot;price&quot; = price * 2 + 100 WHERE &quot;id&quot; = 3;</span></span><br><span class="line">db.Model(&amp;Product&#123;ID: <span class="number">3</span>&#125;).Update(<span class="string">&quot;price&quot;</span>, gorm.Expr(<span class="string">&quot;price * ? + ?&quot;</span>, <span class="number">2</span>, <span class="number">100</span>))</span><br></pre></td></tr></table></figure></li></ul><p>参考<a href="https://gorm.cn/zh_CN/docs/update.html">更新 | GORM </a></p><h5 id="gorm-删除数据"><a class="markdownIt-Anchor" href="#gorm-删除数据"></a> GORM 删除数据</h5><p>物理删除，硬删除，数据会被直接删除，执行的是删除操作。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据主键删除</span></span><br><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="number">10</span>) <span class="comment">// DELETE FROM users WHERE id = 10;</span></span><br><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="string">&quot;10&quot;</span>) <span class="comment">// DELETE FROM users WHERE id = 10;</span></span><br><span class="line">db.Delete(&amp;User&#123;&#125;, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;) <span class="comment">// DELETE FROM users WHERE id IN (1,2,3);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量删除</span></span><br><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%d%&quot;</span>).Delete(User&#123;&#125;) <span class="comment">// DELETE FROM users WHERE name LIKE &quot;%d%&quot;;</span></span><br><span class="line">db.Delete(User&#123;&#125;, <span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%d%&quot;</span>) <span class="comment">// DELETE FROM users WHERE name LIKE &quot;%d%&quot;;</span></span><br></pre></td></tr></table></figure><p>逻辑删除，软删除，数据实际上没有被删除，执行的实际上是更新操作。</p><p>GORM 提供了 gorm.DeletedAt 字段用于实现软删除，只需在 Model 结构体中添加这个字段即可。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID      <span class="type">int64</span></span><br><span class="line">    Name    <span class="type">string</span> <span class="string">`gorm:&quot;default:404&quot;`</span></span><br><span class="line">    Age     <span class="type">int64</span>  <span class="string">`gorm:&quot;default:18&quot;`</span></span><br><span class="line">    Deleted gorm.DeletedAt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拥有该字段的 Model 调用 Delete 方法时能够进行软删除，记录不会从数据库中真正删除。但 GORM 会将 DeletedAt 置为当前时间，并且无法通过正常的查询方法找到该记录。可以使用 Unscoped 方法查询被软删除的数据，也可以通过 Unscoped 方法来实现永久删除。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Unscoped().Where(<span class="string">&quot;age = 20&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line">db.Unscoped().Where(<span class="string">&quot;age = 20&quot;</span>).Delete(&amp;users) <span class="comment">// 数据被永久删除</span></span><br></pre></td></tr></table></figure><p>参考<a href="https://gorm.cn/zh_CN/docs/delete.html">删除 | GORM </a></p><h5 id="gorm-事务"><a class="markdownIt-Anchor" href="#gorm-事务"></a> GORM 事务</h5><p>GORM 提供了 Begin、Commit、Rollback 方法用于使用事务</p><p>开始事务</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tx := db.Begin()</span><br></pre></td></tr></table></figure><p>事务操作，注意这里应使用 tx 而不是 db</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := tx.Create(&amp;User&#123;Name: <span class="string">&quot;name&quot;</span>&#125;).Error</span><br></pre></td></tr></table></figure><p>事务回滚，遇到错误时放弃本次事务操作</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    tx.Rollback()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交事务，应用本次事务操作带来的修改</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tx.Commit()</span><br></pre></td></tr></table></figure><p>GORM 提供了 Transaction 方法用于自动提交事务，可以不用写Commit 和 Rollback 方法就能实现事务的自动管理。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Transaction(<span class="function"><span class="keyword">func</span><span class="params">(tx *gorm.DB)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := tx.Create(&amp;User&#123;Name: <span class="string">&quot;404&quot;</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 返回任何错误都会回滚事务</span></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := tx.Create(&amp;User&#123;Name: <span class="string">&quot;504&quot;</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 nil 提交事务</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>参考<a href="https://gorm.cn/zh_CN/docs/transactions.html">事务 | GORM </a></p><h5 id="gorm-hook"><a class="markdownIt-Anchor" href="#gorm-hook"></a> GORM Hook</h5><p>GORM 提供了 CURD 的 Hook 能力。</p><p>Hook 是在创建、查询、更新、删除等操作执行之前、之后自动调用的函数。如果 Hook 返回错误，GORM 将停止后续的操作并回滚事务。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> BeforeCreate(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> u.Age &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;can&#x27;t save invalid data&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> AfterCreate(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> tx.Create(&amp;User&#123;Name: <span class="string">&#x27;admin&#x27;</span>&#125;).Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考<a href="https://gorm.cn/zh_CN/docs/hooks.html">Hook | GORM </a></p><h5 id="gorm-性能提高"><a class="markdownIt-Anchor" href="#gorm-性能提高"></a> GORM 性能提高</h5><p>对于写操作（创建、更新、删除），为了确保数据的完整性，GORM 会将它们封装在事务内运行，但这会降低性能。可以使用 SkipDefaultTransaction 关闭默认事务。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;</span><br><span class="line">  SkipDefaultTransaction: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用 PrepareStmt 缓存预编译语句可以提高后续调用的速度</p><p>PrepareStmt 可以在连接数据库进行全局配置，也可以在事务操作中临时配置，详细可查阅 GORM 的文档</p><p>参考<a href="https://gorm.cn/zh_CN/docs/performance.html">性能 | GORM </a></p><h5 id="gorm-生态"><a class="markdownIt-Anchor" href="#gorm-生态"></a> GORM 生态</h5><p>GORM 拥有非常丰富的生态，以下是一些常用的扩展</p><ul><li><a href="https://github.com/go-gorm/gen">GORM 代码生成工具</a></li><li><a href="https://github.com/go-gorm/sharding">GORM 分片库方案</a></li><li><a href="https://github.com/go-gorm/hints">GORM 手动索引</a></li><li><a href="https://github.com/go-gorm/optimisticlock">GORM 乐观锁</a></li><li><a href="https://github.com/go-gorm/dbresolver">GORM 读写分离</a></li><li><a href="https://github.com/go-gorm/opentelemetry">GORM OpenTelemetry 扩展</a></li></ul><h4 id="kitex-的基本使用"><a class="markdownIt-Anchor" href="#kitex-的基本使用"></a> Kitex 的基本使用</h4><h5 id="安装-kitex-代码生成工具"><a class="markdownIt-Anchor" href="#安装-kitex-代码生成工具"></a> 安装 Kitex 代码生成工具</h5><p>Kitex 目前对 Windows 的支持不完善，建议使用 linux 系统或者<a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">安装 WSL | Microsoft Learn</a></p><p>安装代码生成工具</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go install github.com/cloudwego/kitex/tool/cmd/kitex@latest</span><br><span class="line">$ go install github.com/cloudwego/thriftgo@latest</span><br></pre></td></tr></table></figure><p>参考<a href="https://www.cloudwego.io/zh/docs/kitex/getting-started/">快速开始 | CloudWeGo</a></p><h5 id="定义-idl"><a class="markdownIt-Anchor" href="#定义-idl"></a> 定义 IDL</h5><p>IDL（Interface  description language），即接口描述语言。是跨平台开发的基础。</p><blockquote><p>对于RPC框架而言，IDL又不仅仅是一个接口描述语言。对于市面上绝大多数的RPC框架而言，IDL还是一个工具和一种使用过程，专指根据 IDL 描述文件，用指定的开发语言，生成对应的服务端接口模块，和客户端程序。这样的好处是，便于开发者快速开发。</p></blockquote><p>使用 IDL 定义服务与接口</p><p>要进行 RPC 远程过程调用，就需要知道对方的接口是什么，需要什么参数，需要知道返回值是什么样的。这就需要通过 IDL 来约定双方的协议，类似于函数签名，然后通过函数名调用函数。</p><p>关于 IDL 的具体编写有多种语法，可以参考以下资料</p><p>使用 Thrift 语法<a href="https://thrift.apache.org/docs/idl">Apache Thrift - Interface Description Language (IDL)</a></p><p>使用 proto3 语法<a href="https://developers.google.com/protocol-buffers/docs/proto3?hl=zh-cn">语言指南 (proto3)  | Protocol Buffers  | Google Developers</a>或者<a href="https://protobuf.dev/programming-guides/proto3/">Language Guide (proto 3) | Protocol Buffers Documentation (protobuf.dev)</a></p><p>这里以 thrift 语法为例，创建一个 echo.thrift</p><figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> go api</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="type">string</span> message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line"><span class="number">1</span>: <span class="type">string</span> message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Echo</span> </span>&#123;</span><br><span class="line">Response echo(<span class="number">1</span>: Request req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="kitex-生成代码"><a class="markdownIt-Anchor" href="#kitex-生成代码"></a> Kitex 生成代码</h5><p>在 IDL 的基础上通过运行以下命令生成代码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kitex -module example -service example echo.thrift</span><br></pre></td></tr></table></figure><p>上述命令中，<code>-module</code> 表示生成的该项目的 go module 名，<code>-service</code> 表明我们要生成一个服务端项目，后面紧跟的 <code>example</code> 为该服务的名字。最后一个参数则为该服务的 IDL 文件。</p><p>生成后的项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|-- build.sh</span><br><span class="line">|-- echo.thrift</span><br><span class="line">|-- handler.go</span><br><span class="line">|-- kitex_gen</span><br><span class="line">|   `-- api</span><br><span class="line">|       |-- echo</span><br><span class="line">|       |   |-- client.go</span><br><span class="line">|       |   |-- echo.go</span><br><span class="line">|       |   |-- invoker.go</span><br><span class="line">|       |   `-- server.go</span><br><span class="line">|       |-- echo.go</span><br><span class="line">|       `-- k-echo.go</span><br><span class="line">|-- main.go</span><br><span class="line">`-- script</span><br><span class="line">    |-- bootstrap.sh</span><br><span class="line">    `-- settings.py</span><br></pre></td></tr></table></figure><p><a href="http://build.sh">build.sh</a>：构建脚本。</p><p>kitex_gen：IDL 内容相关的生成代码，主要是基础的 Server/Client 代码。</p><p>main.go：程序入口。</p><p>handler.go：开发者在该文件里实现 IDL service 定义的方法。</p><h5 id="kitex-基本使用"><a class="markdownIt-Anchor" href="#kitex-基本使用"></a> Kitex 基本使用</h5><p>服务默认监听 8888 端口。</p><p>在 handler.go 中实现方法</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> EchoImpl <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EchoImpl)</span></span> Echo(ctx context.Context, req *api.Request) (resp *api.Response. err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> ...</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="kitex-client-发起请求"><a class="markdownIt-Anchor" href="#kitex-client-发起请求"></a> Kitex Client 发起请求</h5><p>新建一个 client 目录，创建 main.go，在 main.go 中实现方法</p><ul><li><p>创建 Client</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c, err := echo.NewClient(<span class="string">&quot;example&quot;</span>, client.WithHostPorts(<span class="string">&quot;0.0.0.0:8888&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发起请求</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">req := &amp;api.Request&#123;Message: <span class="string">&quot;my request&quot;</span>&#125;</span><br><span class="line">resp, err := c.Echo(context.Background(), req, callopt.WithRPCTimeout(<span class="number">3</span>*time.Second))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(resp)</span><br></pre></td></tr></table></figure></li></ul><h5 id="kitex-服务注册与发现"><a class="markdownIt-Anchor" href="#kitex-服务注册与发现"></a> Kitex 服务注册与发现</h5><p>目前 Kitex 的服务注册与发现已经对接了主流的服务注册与发现中心，如 ETCD，Nacos 等。详细信息参考<a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/service-governance/discovery/">服务发现 | CloudWeGo</a>。</p><h5 id="kitex-生态"><a class="markdownIt-Anchor" href="#kitex-生态"></a> Kitex 生态</h5><p>Kitex 拥有非常丰富的扩展生态，以下是一些常用的扩展</p><ul><li><a href="https://github.com/kitex-contrib/xds">XDS 扩展</a></li><li><a href="https://github.com/kitex-contrib/obs-opentelemetry">opentelemetry 扩展</a></li><li><a href="https://github.com/kitex-contrib/registry-etcd">ETCD 服务注册与发现扩展</a></li><li><a href="https://github.com/kitex-contrib/registry-nacos">Nacos 服务注册与发现扩展</a></li><li><a href="https://github.com/kitex-contrib/registry-zookeeper">Zookeeper 服务注册与发现扩展</a></li><li><a href="https://github.com/kitex-contrib/polaris">polaris 扩展</a></li><li><a href="https://github.com/cloudwego/kitex-examples/">丰富的示例代码与业务 Demo</a></li></ul><p>更多信息参考https://www.cloudwego.io/zh/docs/kitex</p><h4 id="hertz-的基本使用"><a class="markdownIt-Anchor" href="#hertz-的基本使用"></a> Hertz 的基本使用</h4><h5 id="hertz-基本使用"><a class="markdownIt-Anchor" href="#hertz-基本使用"></a> Hertz 基本使用</h5><p>使用 Hertz 实现，服务监听 8080 端口并注册了一个 GET 方法的路由函数。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    h := server.Default(server.WithHostPorts(<span class="string">&quot;127.0.0.1:8080&quot;</span>))</span><br><span class="line">    h.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c context.Context, ctx *app.RequestContext)</span></span> &#123;</span><br><span class="line">        ctx.JSON(consts.StatusOK, utils.H&#123;<span class="string">&quot;ping&quot;</span>: <span class="string">&quot;pong&quot;</span>&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    h.Spin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考<a href="https://www.cloudwego.io/zh/docs/hertz/getting-started/">快速开始 | CloudWeGo</a></p><h4 id="hertz-路由"><a class="markdownIt-Anchor" href="#hertz-路由"></a> Hertz 路由</h4><ul><li><p>Hertz 提供了 GET、POST、PUT、DELETE、ANY 等方法用于注册路由。</p></li><li><p>Hertz 提供了路由组（Group）的能力，用于支持路由分组的功能。</p></li><li><p>Hertz 提供了参数路由和通配路由，路由的优先级为：静态路由 &gt; 命名路由 &gt; 通配路由</p></li></ul><p>更多信息以及使用方法参考<a href="https://www.cloudwego.io/zh/docs/hertz/tutorials/basic-feature/route/">路由 | CloudWeGo</a>。</p><h5 id="hertz-参数绑定"><a class="markdownIt-Anchor" href="#hertz-参数绑定"></a> Hertz 参数绑定</h5><p>Hertz 提供了 Bind、Validate、BindAndValidate 函数用于进行参数绑定和校验</p><p>更多信息以及使用方法参考<a href="https://www.cloudwego.io/zh/docs/hertz/tutorials/basic-feature/binding-and-validate/">绑定与校验 | CloudWeGo</a></p><h5 id="hertz-中间件"><a class="markdownIt-Anchor" href="#hertz-中间件"></a> Hertz 中间件</h5><p>Hertz 的中间件主要分为客户端中间件与服务端中间件，如下是一个服务端中间件示例</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyMiddleware</span><span class="params">()</span></span> app.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx conext.Context, c *app.RequestContext)</span></span> &#123;</span><br><span class="line">        <span class="comment">// pre-handle</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;pre-handle&quot;</span>)</span><br><span class="line">        c.Next(ctx)</span><br><span class="line">        <span class="comment">// post-handle</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;post-handle&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    h := server.Default(server.WithHostPorts(<span class="string">&quot;127.0.0.1:8080&quot;</span>))</span><br><span class="line">    h.Use(MyMiddleware())</span><br><span class="line">    h.GET(<span class="string">&quot;/middleware&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, c *app.RequestContext)</span></span> &#123;</span><br><span class="line">        c.String(consts.StatusOK, <span class="string">&quot;Hello hertz!&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    h.Spin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终止中间件调用链的执行，可以使用 c.Abort、c.AbortWithMsg、c.AbortWithStatus 方法。</p><p>参考<a href="https://www.cloudwego.io/zh/docs/hertz/tutorials/basic-feature/middleware/">中间件概览 | CloudWeGo</a></p><h5 id="hertz-client"><a class="markdownIt-Anchor" href="#hertz-client"></a> Hertz Client</h5><p>Hertz 提供了 HTTP Client 用于发送 HTTP 请求。</p><p>示例</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c, err := client.NewClient()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get请求</span></span><br><span class="line">status, body, _ := c.Get(context.Background(), <span class="literal">nil</span>, <span class="string">&quot;http://example.com&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;status=%v body=%v\n&quot;</span>, status, <span class="type">string</span>(body))</span><br><span class="line"><span class="comment">// post请求</span></span><br><span class="line"><span class="keyword">var</span> postArgs protocol.Args</span><br><span class="line">postArgs.Set(<span class="string">&quot;arg&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">status, body, _ = c.Post(context.Background(), <span class="literal">nil</span>, <span class="string">&quot;http://example.com&quot;</span>, &amp;postArgs)</span><br><span class="line">fmt.Printf(<span class="string">&quot;status=%v body=%v\n&quot;</span>, status, <span class="type">string</span>(body))</span><br></pre></td></tr></table></figure><p>参考<a href="https://github.com/cloudwego/hertz-examples#client">cloudwego/hertz-examples: Examples for Hertz. </a></p><h5 id="hertz-代码生成工具"><a class="markdownIt-Anchor" href="#hertz-代码生成工具"></a> Hertz 代码生成工具</h5><p>Hertz 提供了代码生成工具 Hz ，通过定义 IDL 文件即可生成对应的基础服务代码。</p><p>参考<a href="https://www.cloudwego.io/zh/docs/hertz/tutorials/toolkit/toolkit/">hz 命令行工具使用 | CloudWeGo</a></p><h5 id="hertz-性能"><a class="markdownIt-Anchor" href="#hertz-性能"></a> Hertz 性能</h5><ul><li>网络库</li><li>Json 编解码 Sonic</li><li>使用 sync.Pool 复用对象协议层数据解析优化</li></ul><h5 id="hertz-生态"><a class="markdownIt-Anchor" href="#hertz-生态"></a> Hertz 生态</h5><p>Hertz 拥有非常丰富的扩展生态，以下是一些常用的扩展</p><ul><li><a href="https://github.com/hertz-contrib/http2">HTTP2 扩展</a></li><li><a href="https://github.com/hertz-contrib/obs-opentelemetry">opentelemetry 扩展</a></li><li><a href="https://github.com/hertz-contrib/i18n">国际化扩展</a></li><li><a href="https://github.com/hertz-contrib/reverseproxy">反向代理扩展</a></li><li><a href="https://github.com/hertz-contrib/jwt">JWT 鉴权扩展</a></li><li><a href="https://github.com/hertz-contrib/websocket">Websocket 扩展</a></li><li><a href="https://github.com/cloudwego/hertz-examples">丰富的示例代码与业务 Demo</a></li></ul><p>更多信息参考https://github.com/cloudwego/hertz#extensions</p><h3 id="3实战案例介绍"><a class="markdownIt-Anchor" href="#3实战案例介绍"></a> 3.实战案例介绍</h3><h4 id="项目介绍"><a class="markdownIt-Anchor" href="#项目介绍"></a> 项目介绍</h4><p>项目地址<a href="https://github.com/cloudwego/kitex-examples/tree/main/bizdemo/easy_note">cloudwego/kitex-examples </a></p><p>上面的笔记项目是一个使用 Hertz、Kitex、Gorm 搭建出来的具备一定业务逻辑的后端 API 项目。</p><table><thead><tr><th style="text-align:center">服务名称</th><th style="text-align:center">服务介绍</th><th style="text-align:center">传输协议</th><th style="text-align:center">主要技术栈</th></tr></thead><tbody><tr><td style="text-align:center">demoapi</td><td style="text-align:center">API 服务</td><td style="text-align:center">HTTP</td><td style="text-align:center">Gorm/Kitex/Hertz</td></tr><tr><td style="text-align:center">demouser</td><td style="text-align:center">用户数据管理</td><td style="text-align:center">Protobuf</td><td style="text-align:center">Gorm/Kitex</td></tr><tr><td style="text-align:center">demonote</td><td style="text-align:center">笔记数据管理</td><td style="text-align:center">Thrift</td><td style="text-align:center">Gorm/Kitex</td></tr></tbody></table><h4 id="功能介绍"><a class="markdownIt-Anchor" href="#功能介绍"></a> 功能介绍</h4><p>项目模块</p><ul><li>demoapi<ul><li>用户登录</li><li>用户注册</li><li>用户创建笔记</li><li>用户更新笔记</li><li>用户删除笔记</li><li>用户查询笔记</li></ul></li><li>demouser<ul><li>创建用户</li><li>查询用户</li><li>校验用户</li></ul></li><li>demonote<ul><li>创建笔记</li><li>更新笔记</li><li>删除笔记</li><li>查询笔记</li></ul></li></ul><h4 id="项目调用关系"><a class="markdownIt-Anchor" href="#项目调用关系"></a> 项目调用关系</h4><ul><li>demouser 和 demonote 的数据都存储在 MySQL 数据库中，从 MySQL 中获取数据。</li><li>demouser 和 demonote 使用 ETCD 服务注册。</li><li>demoapi 使用 proto 协议调用 demouser 操作用户数据，使用 thrift 协议调用 demonote 操作笔记数据。</li><li>demoapi 使用 ETCD 服务发现。</li><li>调用方通过 HTTP 请求调用demoapi。</li></ul><h4 id="idl-介绍"><a class="markdownIt-Anchor" href="#idl-介绍"></a> IDL 介绍</h4><p>参考项目文件<a href="https://github.com/cloudwego/kitex-examples/tree/main/bizdemo/easy_note/idl">kitex-examples/bizdemo/easy_note/idl</a></p><h4 id="技术栈介绍"><a class="markdownIt-Anchor" href="#技术栈介绍"></a> 技术栈介绍</h4><p>技术框架</p><ul><li>语言：GO</li><li>底层存储：MySQL</li><li>服务注册：ETCD</li><li>RPC 框架<ul><li>Kitex：registry-etcd 和 tracer-opentracing</li><li>Kitex 扩展</li></ul></li><li>ORM 框架<ul><li>GORM</li><li>GORM 扩展：gorm-mysql 和 gorm-opentracing</li></ul></li><li>HTTP 框架<ul><li>Hertz</li><li>Hertz 扩展：Hertz-Jwt</li></ul></li><li>链路追踪<ul><li>Jeager</li><li>opentracing</li></ul></li></ul><h4 id="创建笔记功能实现关键代码"><a class="markdownIt-Anchor" href="#创建笔记功能实现关键代码"></a> 创建笔记功能实现关键代码</h4><h5 id="hertz-关键代码"><a class="markdownIt-Anchor" href="#hertz-关键代码"></a> Hertz 关键代码</h5><p><a href="https://github.com/cloudwego/kitex-examples/blob/main/bizdemo/easy_note/cmd/api/handlers/create_note.go">kitex-examples/create_note.go</a></p><h5 id="kitex-client-关键代码"><a class="markdownIt-Anchor" href="#kitex-client-关键代码"></a> Kitex Client 关键代码</h5><p><a href="https://github.com/cloudwego/kitex-examples/blob/main/bizdemo/easy_note/cmd/api/rpc/note.go">kitex-examples/note.go</a></p><h5 id="kitex-server-关键代码"><a class="markdownIt-Anchor" href="#kitex-server-关键代码"></a> Kitex Server 关键代码</h5><p><a href="https://github.com/cloudwego/kitex-examples/blob/main/bizdemo/easy_note/cmd/note/service/create_note.go">kitex-examples/create_note.go</a></p><h5 id="gorm-关键代码"><a class="markdownIt-Anchor" href="#gorm-关键代码"></a> Gorm 关键代码</h5><p><a href="https://github.com/cloudwego/kitex-examples/blob/main/bizdemo/easy_note/cmd/note/dal/db/note.go">kitex-examples/note.go</a></p><h3 id="4总结与展望"><a class="markdownIt-Anchor" href="#4总结与展望"></a> 4.总结与展望</h3><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><ul><li>了解 Gorm/Kitex/Hertz 的基本概念</li><li>熟悉 Gorm/Kitex/Hertz 的基础用法</li><li>通过实战案例分析将三件套的使用联系起来</li></ul><h4 id="展望"><a class="markdownIt-Anchor" href="#展望"></a> 展望</h4><ul><li>进一步熟悉 Gorm/Kitex/Hertz 的使用，通过阅读<a href="https://www.cloudwego.io/">官方文档</a>熟悉框架更多的用法。</li><li>阅读笔记项目源码并在本地环境运行，使用 Gorm/Kitex/Hertz 进行项目开发。</li><li>参与 Gorm/Kitex/Hertz 的开源贡献，例如 Hertz 的 Windows 平台支持。</li><li><a href="https://github.com/cloudwego/hertz/issues">官方 issues | 问题 ·Cloudwego/Hertz</a></li></ul><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/374901408">什么是RPC？原理是什么？如何实现一个 RPC 框架？</a></p><p><a href="https://zhuanlan.zhihu.com/p/397060740">RPC框架的IDL与IDL-less </a></p><p><a href="https://gorm.cn/zh_CN/docs/">GORM 指南 | GORM </a></p><p><a href="https://blog.mazhuang.vip/database/mysql/upsert-f2f8bfbaba7a/">Mysql 的 upsert 操作 | Seeker (mazhuang.vip)</a></p><p><a href="https://www.cloudwego.io/zh/docs/kitex/getting-started/">Kitex 快速开始 | CloudWeGo</a></p><p><a href="https://juejin.cn/post/7174311695592980510">一文带你快速入门GolangHTTP框架Hertz - 掘金 (juejin.cn)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文已收录到&lt;a href=&quot;https://juejin.cn/post/7195211923154010168&quot;&gt;Go 框架三件套详解(Web/RPC/ORM) | 青训营笔记 - 掘金 (juejin.cn)&lt;/a&gt;，主要记录了对golang web开发框架三件套的学习</summary>
    
    
    
    <category term="golang" scheme="https://s-chance.github.io/categories/golang/"/>
    
    
    <category term="学习笔记" scheme="https://s-chance.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="青训营" scheme="https://s-chance.github.io/tags/%E9%9D%92%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言内存管理详解</title>
    <link href="https://s-chance.github.io/2023/01/30/golang-day4/"/>
    <id>https://s-chance.github.io/2023/01/30/golang-day4/</id>
    <published>2023-01-30T13:23:29.000Z</published>
    <updated>2023-02-01T09:17:11.657Z</updated>
    
    <content type="html"><![CDATA[<p>本文已收录到<a href="https://juejin.cn/post/7194838118955450428">Go 语言内存管理详解 | 青训营笔记 - 掘金 (juejin.cn)</a>，主要记录了对golang内存管理的学习<span id="more"></span></p><h2 id="内存管理详解"><a class="markdownIt-Anchor" href="#内存管理详解"></a> 内存管理详解</h2><h3 id="追求极致性能"><a class="markdownIt-Anchor" href="#追求极致性能"></a> 追求极致性能</h3><p>性能优化：提升软件系统处理能力，减少不必要的消耗，充分发掘计算机算力。</p><p>性能优化的目的</p><ul><li>用户体验：带来用户体验的提升</li><li>资源高效利用：降低成本。提高效率</li></ul><h3 id="性能优化的层面"><a class="markdownIt-Anchor" href="#性能优化的层面"></a> 性能优化的层面</h3><ul><li>业务层优化<ul><li>针对特定场景，具体问题具体分析</li><li>容易获得较大性能收益</li></ul></li><li>语言运行时优化<ul><li>解决更通用的性能问题</li><li>考虑更多场景</li><li>Tradeoffs权衡</li></ul></li><li>数据驱动<ul><li>自动化性能分析工具——pprof</li><li>依靠数据而非猜测</li><li>首先优化最大瓶颈</li></ul></li></ul><h3 id="性能优化与软件质量"><a class="markdownIt-Anchor" href="#性能优化与软件质量"></a> 性能优化与软件质量</h3><ul><li>软件质量至关重要</li><li>在保证接口稳定的前提下改进具体实现</li><li>测试用例：覆盖尽可能多的场景，方便回归</li><li>文档：做了什么，没做什么，能达到怎样的效果</li><li>隔离：通过选项控制是否开启优化</li><li>可观测：必要的日志输出</li></ul><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ul><li>性能优化的基本问题</li><li>性能优化的两个层面</li><li>性能优化的可维护性</li></ul><h3 id="1自动内存管理"><a class="markdownIt-Anchor" href="#1自动内存管理"></a> 1.自动内存管理</h3><h4 id="11-自动内存管理"><a class="markdownIt-Anchor" href="#11-自动内存管理"></a> 1.1 自动内存管理</h4><ul><li>动态内存<ul><li>程序在运行时根据需求动态分配的内存：malloc()</li></ul></li><li>自动内存管理（垃圾回收）：由程序语言的运行时系统管理动态内存<ul><li>避免手动内存管理，专注于实现业务逻辑</li><li>保证内存使用的正确性和安全性：double-free problem，use-after-free problem</li></ul></li><li>三个任务<ul><li>为新对象分配空间</li><li>找到存活对象</li><li>回收死亡对象的内存空间</li></ul></li></ul><p><strong>相关概念</strong></p><ul><li><p>Mutator：业务线程，分配新对象，修改对象的指向关系</p></li><li><p>Collector：GC线程，找到存活对象，回收死亡对象的内存空间</p></li><li><p>Serial GC：只有一个collector</p></li><li><p>Parallel GC：支持多个collector同时回收的GC算法</p></li><li><p>Concurrent GC：mutator(s)和collector(s)可以同时执行</p></li><li><p>Collectors必须感知对象指向关系的改变</p></li><li><p>评价GC算法</p><ul><li>安全性（Safety）：不能回收存活的对象。这是基本要求</li><li>吞吐率（Throughput）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>−</mo><mfrac><mrow><mi>G</mi><mi>C</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi></mrow><mrow><mi mathvariant="normal">程</mi><mi mathvariant="normal">序</mi><mi mathvariant="normal">执</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">总</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">1-\frac {GC时间}{程序执行总时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">程</span><span class="mord cjk_fallback mtight">序</span><span class="mord cjk_fallback mtight">执</span><span class="mord cjk_fallback mtight">行</span><span class="mord cjk_fallback mtight">总</span><span class="mord cjk_fallback mtight">时</span><span class="mord cjk_fallback mtight">间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback mtight">时</span><span class="mord cjk_fallback mtight">间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。花在GC上的时间</li><li>暂停时间（Pause time）：stop the world（STW）。业务是否感知</li><li>内存开销（Space overhead）：GC元数据开销</li></ul></li><li><p>追踪垃圾回收（Tracing garbage collection）</p></li><li><p>引用计数（Reference counting）</p></li></ul><h4 id="12-追踪垃圾回收"><a class="markdownIt-Anchor" href="#12-追踪垃圾回收"></a> 1.2 追踪垃圾回收</h4><ul><li><p>对象被回收的条件：指针指向关系不可达的对象</p></li><li><p>标记根对象</p><ul><li>静态变量、全局变量、常量、线程栈等</li></ul></li><li><p>标记：找到可达对象</p><ul><li>求指针指向关系的传递闭包：从根对象出发，找到所有可达对象</li></ul></li><li><p>清理：所有不可达对象</p><ul><li><p>将存活对象复制到另外的内存空间（Copying GC）</p><p>Copying GC：将对象复制到另外的内存空间</p></li><li><p>将死亡对象的内存标记为“可分配”（Mark-sweep GC）</p><p>Mark-sweep GC：使用free list管理空闲内存</p></li><li><p>移动并整理存活对象（Mark-compact GC）</p><p>Compact GC：原地整理对象</p></li></ul></li><li><p>根据对象的生命周期，使用不同的标记和清理策略</p></li></ul><h4 id="13-分代-gcgenerational-gc"><a class="markdownIt-Anchor" href="#13-分代-gcgenerational-gc"></a> 1.3 分代 GC（Generational GC）</h4><ul><li>分代假说（Generational hypothesis）：most objects die young</li><li>Intuition：很多对象在分配出来后很快就不在使用了</li><li>每个对象都有年龄：经历过GC的次数</li><li>目的：对年轻和年老的对象，制定不同的GC策略，降低整体内存管理的开销</li><li>不同年龄的对象处于heap的不同区域</li><li>年轻代（Young generation）<ul><li>常规的对象分配</li><li>由于存活对象很少，可以采用copying collection</li><li>GC吞吐率很高</li></ul></li><li>老年代（Old generation）<ul><li>对象趋向一直活着，反复复制开销较大</li><li>可以采用mark-sweep collection</li></ul></li></ul><h4 id="14-引用计数"><a class="markdownIt-Anchor" href="#14-引用计数"></a> 1.4 引用计数</h4><ul><li>每个对象都有一个与之关联的引用数目</li><li>对象存活的条件：当且仅当引用数大于0</li><li>优点<ul><li>内存管理的操作被平摊到程序执行过程中</li><li>内存管理不需要了解runtime的实现细节：C++智能指针（smart pointer）</li></ul></li><li>缺点<ul><li>维护引用计数的开销较大：通过原子操作保证对引用计数操作的原子性和可见性</li><li>无法回收环形数据结构——weak reference</li><li>内存开销：每个对象都引入的额外内存空间存储引用数目</li><li>回收内存时依然可能引发暂停</li></ul></li></ul><h4 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h4><ul><li>自动内存管理的背景和意义</li><li>概念和评价方法</li><li>追踪垃圾回收</li><li>引用计数</li><li>分代 GC</li><li>学术界和工业界一直致力于解决自动内存管理技术的不足之处<ul><li>相关信息<a href="https://pldi22.sigplan.org/details/pldi-2022-pldi/15/Low-Latency-High-Throughput-Garbage-Collection">Low-Latency, High-Throughput Garbage Collection (PLDI 2022 - PLDI Research Papers) </a></li><li>相关介绍<a href="https://zhuanlan.zhihu.com/p/525093935">PLDI’22 | June 13-17，编程语言顶级会议</a></li></ul></li></ul><h3 id="2go管理及优化"><a class="markdownIt-Anchor" href="#2go管理及优化"></a> 2.Go管理及优化</h3><h4 id="21-go-内存分配"><a class="markdownIt-Anchor" href="#21-go-内存分配"></a> 2.1 Go 内存分配</h4><p><strong>分块</strong></p><ul><li>目标：为对象在heap上分配内存</li><li>提前将内存分块<ul><li>调用系统调用 mmap() 向OS申请一大块内存，例如 4 MB</li><li>先将内存划分成大块，例如 8 KB，称作 mspan</li><li>再将大块继续划分成特定大小的小块，用于对象分配</li><li>noscan mspan：分配不包含指针的对象——GC 不需要扫描</li><li>scan mspan：分配包含指针的对象——GC 需要扫描</li></ul></li><li>对象分配：根据对象的大小，选择最合适的块返回</li></ul><p><strong>缓存</strong></p><ul><li>TCMalloc：thread caching</li><li>每个 p 包含一个 mcache 用于快速分配，用于为绑定于 p 上的 g 分配对象</li><li>mcache 管理一组 mspan</li><li>当 mcache 中的 mspan 分配完毕，向 mcentral 申请带有未分配块的 mspan</li><li>当 mspan 中没有分配的对象，mspan 会被缓存在 mcentral 中，而不是立刻释放并归还给 OS</li></ul><h4 id="22-go-内存管理优化"><a class="markdownIt-Anchor" href="#22-go-内存管理优化"></a> 2.2 Go 内存管理优化</h4><ul><li>对象分配是非常高频的操作：每秒分配 GB 级别的内存</li><li>小对象占比较高</li><li>Go 内存分配比较耗时<ul><li>分配路径长：g -&gt; m -&gt; p -&gt; mcache -&gt; mspan -&gt; memory block -&gt; return pointer</li><li>pprof：对象分配的函数是最频繁调用的函数之一</li></ul></li></ul><h4 id="23-优化方案balanced-gc"><a class="markdownIt-Anchor" href="#23-优化方案balanced-gc"></a> 2.3 优化方案：Balanced GC</h4><ul><li><p>每个 g 都绑定一大块内存（1KB），称作 goroutine allocation buffer（GAB）</p></li><li><p>GAB 用于 noscan 类型的小对象分配：&lt; 128 B</p></li><li><p>使用三个指针维护 GAB：base，end，top</p></li><li><p>Bump pointer（指针碰撞）风格对象分配</p><ul><li>无须和其他分配请求互斥</li><li>分配动作简单高效</li></ul></li><li><p>GAB 对于 Go 内存管理来说是一个大对象</p></li><li><p>本质：将多个小对象的分配合并成一次大对象的分配</p></li><li><p>问题：GAB的对象分配方式会导致内存被延迟释放</p></li><li><p>方案：移动 GAB 中存活的对象</p><ul><li>当 GAB 总大小超过一定阈值时，将 GAB 中存活的对象复制到另外分配的 GAB 中</li><li>原先的 GAB 可以释放，避免内存泄漏</li><li>本质：用 copying GC 的算法管理小对象。根据对象的生命周期，使用不同的标记和清理策略。</li></ul></li></ul><p><strong>性能收益</strong>（数据仅供参考）</p><ul><li>高峰期 CPU usage 降低 4.6%，核心接口时延下降 4.5%~7.7%</li></ul><h4 id="总结-3"><a class="markdownIt-Anchor" href="#总结-3"></a> 总结</h4><ul><li>Go 内存管理 — 分块</li><li>Go 内存管理 — 缓存</li><li>Go 对象分配的性能问题<ul><li>分配路径过长</li><li>小对象居多</li></ul></li><li>Balanced GC<ul><li>指针碰撞风格的对象分配</li><li>实现了 copying GC</li><li>性能收益</li></ul></li></ul><h3 id="3编译器和静态分析"><a class="markdownIt-Anchor" href="#3编译器和静态分析"></a> 3.编译器和静态分析</h3><h4 id="31-编译器的结构"><a class="markdownIt-Anchor" href="#31-编译器的结构"></a> 3.1 编译器的结构</h4><ul><li>重要的软件系统<ul><li>识别符号语法和非法的程序</li><li>生成正确且高效的代码</li></ul></li><li>分析部分（前端 front end）<ul><li>词法分析，生成词素（lexeme）</li><li>语法分析，生成语法树</li><li>语义分析，收集类型信息，进行语义检查</li><li>中间代码生成，生成intermediate representation（IR）</li></ul></li><li>综合部分（后端 back end）<ul><li>代码优化，机器无关优化，生成优化后的 IR</li><li>代码生成，生成目标代码</li></ul></li></ul><p>后端是优化重点，同时控制流和数据流分析是优化的基础。</p><h4 id="32-静态分析"><a class="markdownIt-Anchor" href="#32-静态分析"></a> 3.2 静态分析</h4><ul><li>静态分析：不执行程序代码，推导程序的行为，分析程序的性质。</li><li>控制流（Control flow）：程序执行的流程</li><li>数据流（Data flow）：数据在控制流上的传递</li><li>通过分析控制流和数据流，可以知道更多关于程序的性质（properties）</li><li>根据这些性质优化代码</li></ul><h4 id="33-过程内分析和过程间分析"><a class="markdownIt-Anchor" href="#33-过程内分析和过程间分析"></a> 3.3 过程内分析和过程间分析</h4><ul><li>过程内分析（Intra-procedural analysis）<ul><li>仅在函数内部进行分析</li></ul></li><li>过程间分析<ul><li>考虑函数调用时参数传递和返回值的数据流和控制流</li></ul></li><li>过程间分析是个问题<ul><li>需要通过数据流分析得知接口 i 的具体类型，才能知道有多个同名方法（比如<code>func (a *A) foo()</code>和<code>func (b *B) foo()</code>）存在时，接口 i 调用的是哪个<code>foo()</code></li><li>根据接口的具体类型，产生了新的控制流，<code>i.foo()</code>，分析继续</li><li>过程间分析需要同时分析控制流和数据流——联合求解，比较复杂</li></ul></li></ul><h4 id="总结-4"><a class="markdownIt-Anchor" href="#总结-4"></a> 总结</h4><ul><li>编译器的结构与编译的流程</li><li>编译器后端优化</li><li>数据流分析和控制流分析</li><li>过程内分析和过程间分析</li></ul><h3 id="4go编译器优化"><a class="markdownIt-Anchor" href="#4go编译器优化"></a> 4.Go编译器优化</h3><ul><li>为什么做编译器优化<ul><li>用户无感知，重新编译即可获得性能收益</li><li>通用性优化</li></ul></li><li>现状<ul><li>采用的优化少</li><li>编译时间较短，没有进行复杂的代码分析和优化</li></ul></li><li>编译优化的思路<ul><li>场景：面向后端长期执行任务</li><li>Tradeoff：用编译时间换取更高效的机器码</li></ul></li><li>Beast mode<ul><li>函数内联分析</li><li>逃逸分析</li><li>默认栈大小调整</li><li>边界检查消除</li><li>循环展开</li><li>…</li></ul></li></ul><h4 id="41-函数内联inlining"><a class="markdownIt-Anchor" href="#41-函数内联inlining"></a> 4.1 函数内联（Inlining）</h4><ul><li><p>内联：将被调用函数的函数体（callee）的副本替换到调用位置（caller）上，同时重写代码以反映参数的绑定</p></li><li><p>优点</p><ul><li>消除函数调用开销，例如传递函数、保存寄存器等</li><li>将过程间分析转化为过程内分析，帮助其他优化，例如逃逸分析</li></ul></li><li><p>函数内联对性能的影响程度——使用 micro-benchmark验证</p><p>示例</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkInline</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">x := genInteger()</span><br><span class="line">y := genInteger()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">addInline(x, y)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addInline</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkInlineDisabled</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">x := genInteger()</span><br><span class="line">y := genInteger()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">addNoInline(x, y)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addNoInline</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genInteger</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"><span class="keyword">return</span> rand.Intn(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的<code>//go:noinline</code>是一种编译指示，<code>noinline</code>表示不要内联，固定写法。这种编译指示类似于C语言中的<code>#include</code>。</p></li><li><p>使用 micro-benchmark快速验证和对比性能优化结果</p><p>使用以下命令进行性能测试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench .</span><br></pre></td></tr></table></figure></li><li><p>缺点</p><ul><li>函数体变大，instruction cache（icache）不友好</li><li>编译生成的 Go 镜像变大</li></ul></li><li><p>函数内联在大多数情况下是正向优化</p></li><li><p>内联策略</p><ul><li>调用和被函数的规模</li><li>…</li></ul></li></ul><h4 id="42-beast-mode"><a class="markdownIt-Anchor" href="#42-beast-mode"></a> 4.2 Beast Mode</h4><ul><li>Go 函数内联受到的限制较多<ul><li>语言特性，例如 interface，defer等，限制了函数内联</li><li>内联策略非常保守</li></ul></li><li>Beast Mode：调整函数内联的策略，使更多函数被内联<ul><li>降低函数调用的开销</li><li>增加了其他优化的机会：逃逸分析</li></ul></li><li>开销<ul><li>Go 镜像增加约 10%</li><li>编译时间增加</li></ul></li></ul><p><strong>性能收益</strong>（数据仅供参考）</p><ul><li>高峰期 CPU usage 降低 9%，时延降低 10%</li><li>内存使用降低 3%</li></ul><h4 id="43-逃逸分析"><a class="markdownIt-Anchor" href="#43-逃逸分析"></a> 4.3 逃逸分析</h4><p>逃逸分析：分析代码中指针的动态作用域，即指针在何处可以被访问</p><ul><li>大致思路<ul><li>从对象分配处出发，沿着控制流，观察对象的数据流</li><li>若发现指针 p 在当前作用域 s<ul><li>作为参数传递给其他函数</li><li>传递给全局变量</li><li>传递给其他的 goroutine</li><li>传递给已逃逸的指针指向的对象</li></ul></li><li>则指针 p 指向的对象逃逸出 s，反之则没有逃逸出 s</li></ul></li><li>Beast Mode：函数内联拓展了函数边界，更多对象不逃逸</li><li>优化：未逃逸的对象可以在栈上分配<ul><li>对象在栈上分配和回收很快：移动 sp</li><li>减少在 heap 上的分配，降低 GC 负担</li></ul></li></ul><h4 id="总结-5"><a class="markdownIt-Anchor" href="#总结-5"></a> 总结</h4><ul><li>Go 编译器优化问题</li><li>Beast Mode</li><li>函数内联</li><li>逃逸分析</li><li>通过 micro-benchmark 快速验证性能优化</li><li>性能收益</li></ul><h3 id="归纳"><a class="markdownIt-Anchor" href="#归纳"></a> 归纳</h3><ul><li>性能优化<ul><li>自动内存管理</li><li>Go 内存管理</li><li>编译器与静态分析</li><li>编译器优化</li></ul></li><li>实践<ul><li>Balanced GC 优化对象分配</li><li>Beast Mode 提升代码性能</li></ul></li><li>分析问题的方法与解决问题的思路，不仅适用于Go 语言，也适用于其他语言的优化</li></ul><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><p><a href="https://juejin.cn/post/7189525739836801085/">【后端专场 学习资料二】第五届字节跳动青训营 - 掘金 (juejin.cn)</a></p><p><a href="https://segmentfault.com/a/1190000016743220">Go 语言编译器的 “//go:” 详解 - Golang 攻略 - SegmentFault 思否</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文已收录到&lt;a href=&quot;https://juejin.cn/post/7194838118955450428&quot;&gt;Go 语言内存管理详解 | 青训营笔记 - 掘金 (juejin.cn)&lt;/a&gt;，主要记录了对golang内存管理的学习</summary>
    
    
    
    <category term="golang" scheme="https://s-chance.github.io/categories/golang/"/>
    
    
    <category term="学习笔记" scheme="https://s-chance.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="青训营" scheme="https://s-chance.github.io/tags/%E9%9D%92%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>Go 高质量编程与性能调优</title>
    <link href="https://s-chance.github.io/2023/01/28/golang-day3/"/>
    <id>https://s-chance.github.io/2023/01/28/golang-day3/</id>
    <published>2023-01-28T15:23:13.000Z</published>
    <updated>2023-02-01T07:04:35.846Z</updated>
    
    <content type="html"><![CDATA[<p>本文已收录到<a href="https://juejin.cn/post/7194132732492906551">golang高质量编程与性能调优 | 青训营笔记 - 掘金 (juejin.cn)</a>，主要记录了对golang高质量编程与性能调优的学习<span id="more"></span></p><h2 id="高质量编程与性能调优实战"><a class="markdownIt-Anchor" href="#高质量编程与性能调优实战"></a> 高质量编程与性能调优实战</h2><p>主要内容</p><ul><li>如何编写更简洁清晰的代码</li><li>常用Go语言程序的优化手段</li><li>熟悉Go程序性能分析工具</li><li>了解工程中性能优化的原则和流程</li></ul><h3 id="1高质量编程"><a class="markdownIt-Anchor" href="#1高质量编程"></a> 1.高质量编程</h3><h4 id="11-简介"><a class="markdownIt-Anchor" href="#11-简介"></a> 1.1 简介</h4><p>高质量代码：编写的代码能够达到正确可靠、简洁清晰的目标。</p><ul><li><p>正确性：考虑各种边界条件，能够处理错误的调用。</p></li><li><p>可靠性：异常情况或者错误处理的策略明确，依赖的服务出现异常能够及时处理。</p></li><li><p>简单：逻辑简单，后续调整功能或新增功能能够快速支持。</p></li><li><p>清晰：其他人在阅读代码时容易理解，重构或者修改功能不会出现无法预料的问题。</p></li></ul><p>编程的原则</p><p><strong>简单性</strong></p><p>消除“多余的复杂性”，以简单清晰的逻辑编写代码。复杂的逻辑难以重构和优化，无法明确预知其调整造成的影响范围，也难以在排查问题时定位。</p><p><strong>可读性</strong></p><p>从后期来看，大部分工作是对已有功能的完善和扩展，对应功能的代码会存在很长时间。维护是一个项目最漫长的周期，好的可读性可以降低维护的时间成本。</p><p><strong>生产力</strong></p><p>Go语言有特定的代码格式限制，甚至有专门的工具强制统一所有代码格式。遵循代码规范，能够避免常见的缺陷代码，降低后续联调、测试、验证、上线等各个节点出现问题的概率以及快速排查定位问题。</p><h3 id="12-编码规范"><a class="markdownIt-Anchor" href="#12-编码规范"></a> 1.2 编码规范</h3><h4 id="121-代码格式"><a class="markdownIt-Anchor" href="#121-代码格式"></a> 1.2.1 代码格式</h4><p>推荐使用gofmt自动格式化代码，gofmt是Go语言官方提供的工具，能够自动格式化GO语言代码为官方统一风格，常见的IDE都支持配置。</p><p>另外的，goimports会对依赖包进行管理，自动增删依赖包引用，按字母排序分类。</p><h4 id="122-注释"><a class="markdownIt-Anchor" href="#122-注释"></a> 1.2.2 注释</h4><p>注释有以下四种使用方式</p><ul><li><p>解释代码作用。</p><p>适合说明公共符号，比如对外提供的函数用注释描述它的功能和用途，除非函数的功能简单而明显时，才可省略注释。</p><p>对于显而易见的内容不需要注释。</p></li><li><p>解释代码如何实现</p><p>适合说明逻辑实现过程，解释复杂的不明显的逻辑。</p><p>不要解释显而易见的流程，避免增加冗余信息和造成误解。</p></li><li><p>解释代码实现的原因</p><p>适合解释代码的外部因素，为什么需要实现这个代码，提供上下文信息，说明这段代码在上下文中的意义。</p></li><li><p>解释代码出错的可能情况</p><p>适合解释代码的限制条件，一些潜在的限制条件或者无法处理的情况，例如性能隐患，输入的限制条件，可能出现的错误情况等。使阅读者在不需要了解代码实现细节的情况下弄清限制条件。</p></li></ul><p><strong>公共符号始终要注释</strong></p><ul><li>包中声明的每个公共符号：变量、常量函数以及结构都需要添加注释</li><li>任何既不明显又不简短的公共功能必须予以注释</li><li>无论长度或复杂程度如何，对库中的函数都必须进行注释</li><li>例外情况，不需要注释实现接口的方法。</li></ul><p>更多规范的注释可以参考golang的官方仓库源码<a href="https://github.com/golang/go/tree/master/src">golang/go</a></p><p><strong>小结</strong></p><ul><li>代码本身应该是最好的注释</li><li>注释应该提供代码未表达出的上下文信息</li></ul><h4 id="123-命名规范"><a class="markdownIt-Anchor" href="#123-命名规范"></a> 1.2.3 命名规范</h4><p>命名是代码编写中最常见的规范。</p><p><strong>variable</strong></p><ul><li><p>简洁胜于冗长</p></li><li><p>缩略词全大写，但当其位于变量开头且不需要对外提供时，使用全小写</p><p>例如，使用SeverHTTP而不是ServerHttp。使用XMLHTTPRequest或者xmlHTTPRequest。</p></li><li><p>变量距离其被使用的地方越远，则需要携带更多的上下文信息。</p><p>全局变量在其名字中需要更多的上下文信息，使得在不同的地方可以轻易辨认出其含义</p></li><li><p>几乎不影响理解的变量名变动，选择最简介的名称即可。</p></li><li><p>具有特定含义的变量名变动，选择意义最贴切的名称即可。</p></li></ul><p><strong>function</strong></p><ul><li><p>函数名不携带包名的上下文信息，因为包名和函数名总是成对出现</p><p>例如，使用time.Now()而不是time.NowTime()。</p></li><li><p>函数名尽量简短</p></li><li><p>当名为foo的包某个函数返回类型为Foo时，可以省略类型信息避免歧义</p></li><li><p>当名为foo的包某个函数返回类型为T时（T不是Foo），可以在函数名中加入类型信息</p><p>例如，parseInt</p></li></ul><p><strong>package</strong></p><ul><li>只由小写字母组成，不能包含大写字母和下划线等字符</li><li>简短并包含一定的上下文信息。例如schema</li><li>不要与标准库同名。例如不要使用sync或者strings</li></ul><p>以标准库包名为例</p><ul><li>不使用常用的变量名作为包名。例如使用bufio而不是buf</li><li>使用单数而不是复数。例如使用encoding而不是encodings</li><li>谨慎地使用缩写。例如使用fmt在不破坏上下文的情况下比format更加简短</li></ul><p><strong>小结</strong></p><ul><li>核心目标是降低阅读理解代码的成本</li><li>重点考虑上下文信息，设计简洁清晰的名称</li></ul><h4 id="124-控制流程"><a class="markdownIt-Anchor" href="#124-控制流程"></a> 1.2.4 控制流程</h4><p>流程控制经常用到的就是if else这种条件控制语句。</p><p><strong>避免嵌套，保持正常流程清晰</strong></p><p>一个简单的if else，如果两个分支都包含return语句，则可以去除冗余的else，方便后续维护。else一般就是表示正常流程，如果需要在正常流程中新增判断逻辑，则去除else可以避免分支嵌套。</p><p><strong>尽量保持正常代码路径为最小缩进</strong></p><ul><li><p>优先处理错误情况或特殊情况，尽早返回或继续循环来减少嵌套。</p><p>例如，使用<code>err != nil</code>而不是<code>err == nil</code>就是为了优先处理错误情况。</p></li></ul><p><strong>小结</strong></p><ul><li>线性原理，处理逻辑尽量走直线，避免复杂的嵌套分支</li><li>正常流程代码沿着屏幕向下移动</li><li>提升代码的可维护性和可读性</li><li>故障问题大多出现在复杂的条件语句和循环语句中</li></ul><h4 id="125-错误和异常处理"><a class="markdownIt-Anchor" href="#125-错误和异常处理"></a> 1.2.5 错误和异常处理</h4><p><strong>简单错误</strong></p><ul><li>简单的错误指的是仅出现一次的错误，且在其他地方不需要捕获该错误</li><li>优先使用errors.New来创建匿名变量直接表示简单错误</li><li>如果需要格式化错误信息，使用fmt.Errorf</li></ul><p><strong>错误的Wrap和Unwarp</strong></p><ul><li>错误的Wrap实际上是提供了一个error嵌套另一个error的能力，从而形成一个error的跟踪链</li><li>在fmt.Errorf中使用%w占位符来将一个错误关联至错误跟踪链中</li></ul><p><strong>错误判定</strong></p><ul><li>判断一个错误是否为特定错误，<a href="http://xn--errors-vt9i248w.Is">使用errors.Is</a></li><li>不同于使用==，使用该方法可以判断错误链上的所有错误中是否含有特定的错误</li><li>在错误链上获取特定种类的错误，<a href="http://xn--errors-vt9i248w.As">使用errors.As</a>。与errors.Is不同的是As会取出调用链中指定类型的错误，并将错误赋值给定义好的变量，方便后续处理</li></ul><p><strong>panic</strong></p><p>panic比错误更加严重，它的出现表示程序无法正常工作。</p><ul><li>不建议在业务代码中使用panic</li><li>panic发生后会向上传播至调用栈顶，如果当前goroutine中所有deferred函数都不包含recover就会造成整个程序崩溃</li><li>若问题可以被屏蔽或解决，建议使用error代替panic</li><li>特殊地，当程序启动阶段发生不可逆的错误时，可以在init或main函数中使用panic</li></ul><p><strong>recover</strong></p><p>panic的产生并不只在程序运行阶段。如果是引入其他库时产生的bug而导致的panic就需要使用recover。</p><p>注意recover的生效条件</p><ul><li>recover只能在被defer的函数中使用</li><li>在嵌套中无法生效</li><li>只在当前goroutine生效</li><li>defer的语句是先进后出</li></ul><p>如果需要更多的上下文信息，可以在recover后用log记录当前调用的栈，方便分析定位。</p><p><strong>小结</strong></p><ul><li>error尽可能提供简明的上下文信息链，方便定位问题</li><li>panic用于真正异常的情况，无法规避</li><li>recover生效范围，在当前goroutine的deferred函数中生效</li></ul><h3 id="13-性能优化建议"><a class="markdownIt-Anchor" href="#13-性能优化建议"></a> 1.3 性能优化建议</h3><p><strong>简介</strong></p><ul><li>性能优化的前提是满足正确可靠、简洁清晰等质量因素</li><li>性能优化是综合评估，时间效率和空间效率可能在某些情况下不能兼得</li><li>针对Go语言特性来介绍Go相关的性能优化建议</li></ul><h4 id="131-benchmark"><a class="markdownIt-Anchor" href="#131-benchmark"></a> 1.3.1 Benchmark</h4><p><strong>如何使用</strong></p><ul><li>性能表现需要实际数据衡量</li><li>Go语言提供了支持基准性能测试的benchmark工具</li></ul><p>通过以下命令进行性能测试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench=. -benchmem</span><br></pre></td></tr></table></figure><p><strong>结果说明</strong></p><ul><li>第一个参数如BenchmarkFib10-8对应被测试函数的名称，-8表示GOMAXPROCS的值为8</li><li>第二个参数如1855870表示一共执行1855870次，即b.N的值</li><li>第三个参数如602.5ns/op表示每次执行花费602.5ns</li><li>第四个参数如0B/op表示每次执行时申请的内存空间大小</li><li>第五个参数如0allocs/op表示每次执行时申请内存的次数</li></ul><h4 id="132-slice"><a class="markdownIt-Anchor" href="#132-slice"></a> 1.3.2 Slice</h4><p><strong>slice预分配内存</strong></p><ul><li><p>尽可能在使用make()初始化切片时提供容量信息</p></li><li><p>切片本质是一个数组片段的描述，包括数组指针、片段的长度、片段的容量（不改变内存分配情况下的最大长度）</p></li><li><p>切片操作并不复制切片指向的元素</p></li><li><p>而是创建一个新的切片复用原来切片的底层数组</p><p>以切片的append为例，append时有两种场景：</p><p>当append之后的长度小于等于容量，将会直接利用原底层数组剩余的空间。</p><p>当append之后的长度大于容量，则会分配一块更大的区域来容纳新的底层数组。</p></li></ul><p>因此，为了避免内存发生拷贝，如果能够明确最终的切片的大小，预先设置容量的值能够避免额外的内存分配，获得更好的性能。</p><p><strong>大内存未释放问题</strong></p><p>原切片由大量的元素构成，在原切片的基础上创建切片只使用了很小一段，但底层数组在内存中仍占据着大量空间，无法释放。</p><ul><li>在已有切片的基础上创建切片，不会创建新的底层数组</li><li>可以使用copy代替re-slice，因为通过copy会指向一个新的底层数组，原来的底层数组不再被引用之后，内存就会被回收。</li></ul><h4 id="133-map"><a class="markdownIt-Anchor" href="#133-map"></a> 1.3.3 Map</h4><p><strong>map预分配内存</strong></p><p>原理</p><ul><li>不断向map中添加元素的操作会触发map的扩容</li><li>提前分配好空间可以减少内存拷贝和Rehash的消耗</li><li>建议根据实际需求提前预估好需要的空间</li></ul><h4 id="134-字符串处理"><a class="markdownIt-Anchor" href="#134-字符串处理"></a> 1.3.4 字符串处理</h4><p><strong>使用strings.Builder</strong></p><ul><li><p>常见的字符串拼接方式就是使用+号直接拼接或者使用strings.Builder的方法拼接以及bytes.Buffer的方法拼接</p></li><li><p>使用+号拼接性能最差，strings.Builder和bytes.Buffer性能相近，strings.Builder更快。</p><p>当使用+拼接两个字符串时，生成一个新的字符串，那么就需要开辟一段新的空间，新空间的大小是原来两个字符串的大小之和。拼接第三个字符串时，再开辟一段新空间，新空间大小是三个字符串大小之和，以此类推。</p></li><li><p>分析</p><ul><li>字符串在Go语言中是不可变类型，占用内存大小是固定的</li><li>使用+每次都会重新分配内存</li><li>strings.Builder和bytes.Buffer底层都是[]byte数组</li><li>Builder和Buffer的内存扩容策略，不需要每次拼接重新分配内存</li></ul></li><li><p>Builder比Buffer快的原因</p><ul><li>bytes.Buffer转化为字符串时重新申请了一块空间</li><li>strings.Builder直接将底层的[]byte转换成了字符串类型返回</li></ul></li><li><p>在已知字符串长度的情况下，进一步提升Builder的拼接性能，使用预分配减少分配次数。优化后的Builder只需要一次内存分配，而优化后的Buffer有两次。</p></li></ul><h4 id="135-空结构体"><a class="markdownIt-Anchor" href="#135-空结构体"></a> 1.3.5 空结构体</h4><p><strong>使用空结构体节省内存</strong></p><ul><li><p>空结构体struct{}实例不占据任何内存空间</p></li><li><p>可做为各种场景下的占位符使用</p><ul><li>节省资源</li><li>空结构体本身具备很强的语义，不需要任何值就能作为占位符</li></ul></li><li><p>Set方法的实现，可以考虑用map来代替</p></li><li><p>对于这个场景，只需要用到map的键，不需要值</p></li><li><p>即使是将map的值设置为bool类型，也会多占据1个字节空</p><p>一个开源实现<a href="https://github.com/deckarep/golang-set/blob/main/threadunsafe.go">golang-set/threadunsafe.go</a>。</p></li></ul><h4 id="136-atomic包"><a class="markdownIt-Anchor" href="#136-atomic包"></a> 1.3.6 atomic包</h4><p>多线程编程场景下性能优化，保证线程安全。</p><p><strong>如何使用atomic包</strong></p><ul><li>锁的实现是通过操作系统来实现，属于系统调用</li><li>atomic操作是通过硬件实现，效率比锁高</li><li>sync.Mutex应该用来保护一段逻辑，不仅仅用于保护一个变量</li><li>对于非数值操作，可以使用atomic.Value，能承载一个interface{}</li></ul><h4 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h4><ul><li>避免常见的性能陷阱可以保证大部分程序的性能</li><li>普通应用代码，不要一味地追求程序的性能</li><li>越高级的性能优化手段越容易出现问题</li><li>在满足正确可靠、简洁清晰的质量要求的前提下提高程序性能</li></ul><h3 id="2性能调优实战"><a class="markdownIt-Anchor" href="#2性能调优实战"></a> 2.性能调优实战</h3><h3 id="21-简介"><a class="markdownIt-Anchor" href="#21-简介"></a> 2.1 简介</h3><p><strong>性能调优原则</strong></p><ul><li>要依靠数据而不是猜测</li><li>要定位最大瓶颈而不是细枝末节</li><li>不要过早优化</li><li>不要过度优化</li></ul><h3 id="22-性能分析工具-pprof"><a class="markdownIt-Anchor" href="#22-性能分析工具-pprof"></a> 2.2 性能分析工具 pprof</h3><p><strong>说明</strong></p><p>如果想知道应用在什么地方耗费了多少CPU、Memory。对于go程序有一个很方便的工具——pprof</p><h4 id="221-功能简介"><a class="markdownIt-Anchor" href="#221-功能简介"></a> 2.2.1 功能简介</h4><p>pprof是用于可视化和分析性能分析数据的工具</p><ul><li>分析-Profile：网页、可视化终端</li><li>工具-Tool：runtime/pprof、net/http/pprof</li><li>采样-Sample：CPU、堆内存-Heap、协程-Goroutine、锁-Mutex、阻塞-Block、线程创建-ThreadCreate</li><li>展示-View：Top、调用图-Graph、火焰图-FlameGraph、Peek、源码-Source、反汇编-Disassemble</li></ul><h4 id="222-排查实战"><a class="markdownIt-Anchor" href="#222-排查实战"></a> 2.2.2 排查实战</h4><p><strong>搭建pprof实践项目</strong></p><ul><li><p>项目地址<a href="https://github.com/wolfogre/go-pprof-practice">wolfogre/go-pprof-practice: go pprof practice.</a></p></li><li><p>该项目提前埋入了炸弹代码，能产生可观测的性能问题。windows可用任务管理器查看内存占用情况，启动项目前确保内存足够。</p></li><li><p>项目中引入了net/http/pprof包，在启动项目后可以通过浏览器访问pprof工具</p><p>main函数部分代码说明</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">runtime.GOMAXPROCS(<span class="number">1</span>)              <span class="comment">//限制CPU使用数</span></span><br><span class="line">runtime.SetMutexProfileFraction(<span class="number">1</span>) <span class="comment">//开启锁调用跟踪</span></span><br><span class="line">runtime.SetBlockProfileRate(<span class="number">1</span>)     <span class="comment">//开启阻塞调用跟踪</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 启动 http server</span></span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:6060&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></li></ul><p><strong>浏览器查看指标</strong></p><p>在项目启动成功后，访问http://localhost:6060/debug/pprof，可以看到pprof的计数页面。</p><p>页面上展示了可用的程序运行采样数据，分别是</p><ul><li>allocs:内存分配情况</li><li>blocks:阻塞操作情况</li><li>cmdline:程序启动命令及其参数</li><li>goroutine:当前所有协程的堆栈信息</li><li>heap:堆上内存使用情况</li><li>mutex:锁竞争操作情况</li><li>profile:CPU占用情况</li><li>threadcreate:当前所有常见的系统线程的堆栈信息</li><li>trace:程序运行跟踪情况</li></ul><p>cmdline可以显式运行进程的命令，找到问题来源的程序。threadcreate比较复杂，不透明。trace需要配合另外的工具解析，这里暂不深入。</p><p>炸弹主要在CPU、堆内存、goroutine、锁竞争和阻塞操作上，可以通过pprof工具分析</p><p><strong>CPU</strong></p><p>使用操作系统自带的工具查看CPU占用，发现该项目程序的异常占用。</p><p>pprof的采样结果是将一段时间内的信息汇总输出到文件中，所以需要获取这个profile文件。可以直接使用暴露的接口链接下载文件后使用，也可以直接用pprof工具连接这个接口下载需要的数据。</p><p>使用go tool pprof + 采样链接的命令来启动采样，例如</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof <span class="string">&quot;http://localhost:6060/debug/pprof/profile?seconds=10&quot;</span></span><br></pre></td></tr></table></figure><p>链接就是刚刚炸弹程序暴露出来的接口，链接结尾的profile代表采样的对象是CPU使用。如果在浏览器里直接打开链接会启动一个60秒的采样并在采样结束后下载文件到本地。这里加上seconds=10的参数，指定采样时间为10秒。文件下载保存的路径会在pprof终端展示。</p><p>pprof终端命令</p><ul><li><p>top命令用于查看占用资源最多的函数。top有以下参数指标</p><ul><li><p>flat:当前函数本身的执行耗时</p></li><li><p>flat%:flat占CPU总时间的比例</p></li><li><p>sum%:上面每一行flat%的总和</p></li><li><p>cum:指当前函数本身加上其调用函数的总耗时</p></li><li><p>cum%:cum占CPU总时间的比例</p></li></ul><p>默认展示资源占用最高的10个函数，如果只需要查看占用最高的N个函数，在top命令后加上一个数字N即可。</p><p>flat=cum的函数说明该函数没有调用其他函数</p><p>flat=0的函数说明该函数只有其他函数的调用</p><hr /></li><li><p>list命令会根据给出的正则表达式查找代码，并按行展示出每一行的占用</p><p>例如，在pprof终端输入list Eat，就能查看Eat函数每行的占用情况。这样就能定位到具体的代码。</p><hr /></li><li><p>web命令可以生成一张调用关系图，默认通过浏览器打开。该命令需要提前安装Graphviz并配置环境变量才能使用。官网下载<a href="https://graphviz.org/download/">Download | Graphviz</a></p><p>图中除了每个节点的资源占用以外，还会将它们的调用关系描述出来。资源占用最高的函数会比较明显地展示出来。</p></li></ul><p>退出pprof终端，输入q回车即可。将炸弹程序直接注释。</p><p><strong>Heap-堆内存</strong></p><p>注释问题代码后，重新启动项目。用系统工具（windows是任务管理器）查看CPU占用，可以发现进程的占用已经降下来了。但还有内存占用问题，接下来排查内存问题。</p><p>上面排查CPU问题时使用的是pprof终端，这里使用另一种展示方式，通过<code>-http=:8080</code>参数，开启pprof自带的web UI，以网页的形式来呈现性能指标。注意链接结尾是heap</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof -http=:8080 <span class="string">&quot;http://localhost:6060/debug/pprof/heap&quot;</span></span><br></pre></td></tr></table></figure><p>通过上面的命令启动pprof工具后，在采样完成后会自动打开浏览器，展示出web视图，同时展示的资源使用从CPU时间变成了内存占用。</p><p>通过页面顶端的View菜单可以切换不同的视图，初始默认是Graph视图。Top视图就类似于终端top命令的展示效果，Source视图就类似于终端list命令的展示效果。通过这些视图可以快速定位问题，注释掉问题代码，拆除第二个炸弹。</p><p>重新运行项目，查看内存占用，发现内存占用也大幅下降。但实际上前面解决的内存问题只是堆内存采样的四种指标之一的inuse_space。四种指标如下</p><ul><li>alloc_objects:程序累计申请的对象数</li><li>alloc_space:程序累计申请的内存大小</li><li>inuse_objects:程序当前持有的对象数</li><li>inuse_space:程序当前占用的内存大小</li></ul><p>默认展示视图就是inuse_space视图，只展示当前持有的内存，但对于已经释放的内存，inuse采样不会进行展示。通过页面顶端的Sample菜单切换到alloc_space指标，分析alloc的内存问题。定位到问题代码，注释掉。至此，内存部分炸弹已经被全部清理。</p><p><strong>goroutine协程</strong></p><p>Golang是一门自带垃圾回收的语言，一般情况下内存泄露是没那么容易发生的。但是有一种例外，goroutine是很容易泄露的，进而导致内存泄露。接下来运行项目，分析goroutine使用情况。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof -http=:8080 <span class="string">&quot;http://localhost:6060/debug/pprof/goroutine&quot;</span></span><br></pre></td></tr></table></figure><p>goroutine使用默认视图不方便分析，可以切换到Flame Graph火焰图更加直观。</p><p>火焰图的展示</p><ul><li>由上到下表示调用顺序，展示了各个函数调用之间的层级关系</li><li>每一行代表一个函数，条形越长代表占用的资源越多</li><li>火焰图是动态的，支持点击块进行分析</li></ul><p>火焰图是非常常用的性能分析工具，在程序逻辑复杂的情况下很有用。</p><p>切换到Source视图，在该视图下搜索火焰图中占用最高的函数名称。定位到问题代码，注释掉。重新启动访问pprof可以发现goroutine已下降到正常水平。</p><p><strong>mutex-锁</strong></p><p>启动pprof工具</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof -http=:8080 <span class="string">&quot;http://localhost:6060/debug/pprof/mutex&quot;</span></span><br></pre></td></tr></table></figure><p>观察web视图，分析锁操作，切换到Source视图定位到具体代码，注释掉。</p><p><strong>block-阻塞</strong></p><p>在程序中，除了锁的竞争会导致阻塞以外，还有很多逻辑(例如读取一个channel)也会导致阻塞。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof -http=:8080 <span class="string">&quot;http://localhost:6060/debug/pprof/block&quot;</span></span><br></pre></td></tr></table></figure><p>同理在Graph视图中定位到问题函数后，切换到Source视图定位到问题代码，注释掉。</p><p>但实际上，该示例项目在之前的计数页面上存在两个阻塞，上面只解决了其中一个阻塞。只展示了一个阻塞，是因为另一个阻塞操作的节点总用时小于总时长的千分之五而被省略掉。这是pprof的过滤策略，能够更加有效地突出重点问题信息，而省略相对没有问题的信息。如果没有过滤策略的话，对于一个复杂的程序，大量无关紧要的内容都会展示出来，不利于定位问题。</p><p>第二个阻塞操作，尽管不会在pprof工具中展示出来，但也会被pprof记录下来，可以通过暴露出来的接口地址http://localhost:6060/debug/pprof中的block链接直接访问。通过访问可以得知这个阻塞操作是符合预期的正常操作。</p><p><strong>小结</strong></p><ul><li>五种使用pprof采集的常用性能指标: CPU、堆内存、Goroutine、 锁竞争和阻塞;</li><li>两种展示方式:交互式终端和网页;</li><li>四种视图: Top、 Graph、 源码和火焰图。</li><li>pprof除了http的获取方式之外，也可以直接在运行时调用runtime/pprof包将指标数据输出到本地文件。</li><li>视图中还有一个更底层的「反汇编」视图。感兴趣的话可自行尝试。</li></ul><h4 id="223-pprof的采样过程和原理"><a class="markdownIt-Anchor" href="#223-pprof的采样过程和原理"></a> 2.2.3 pprof的采样过程和原理</h4><p><strong>CPU</strong></p><ul><li>采样对象：所有函数调用栈和它们的占用时间</li><li>采样率：100次/秒，固定值</li><li>采样时间：从手动启动到手动结束</li></ul><p>这个定时机制在unix或类unix系统上是依赖信号机制实现的。每次暂停都会接收到一个信号，通过系统计时器来保证这个信息是固定频率发送的。</p><p>开始采样——&gt;设定信号处理函数——&gt;开启定时器</p><p>停止采样——&gt;取消信号处理函数——&gt;关闭定时器</p><p>一共有三个相关角色：进程本身、操作系统和写缓冲。启动采样时，进程向OS注册一个定时器</p><ul><li><p>操作系统每10ms向进程发送一次SIGPROF信号</p></li><li><p>进程每次接收到SIGPROF信号后就会对当前的调用堆栈进行记录</p></li><li><p>与此同时，进程会启动一个写缓冲的goroutine，每隔100ms从进程中读取已经记录的堆栈信息，并写入到输出流。</p></li></ul><p>当采样停止时，进程向OS取消定时器，不再接收信号，写缓冲读取不到新的堆栈时，结束输出。</p><p><strong>Heap-堆内存</strong></p><p>pprof的内存采样是有局限性的，内存采样在实现上依赖了内存分配器的记录，所以只能记录在堆上分配且参与GC的内存，一些其他的内存分配，例如调用结束就会回收的栈内存、一些更底层使用cgo调用分配的内存，是不会被内存采样记录的。</p><ul><li>采样程序通过内存分配器记录在堆上分配和释放的内存，记录分配和释放的大小和数量</li><li>采样率：每分配512KB记录一次，可在运行开头修改，设置为1则表示每次分配都会记录</li><li>采样时间：从程序运行开始到获取采样结果时</li><li>采样指标：alloc_space, alloc_objects, inuse_space, inuse_objects。</li><li>计算方式：inuse = alloc - free</li></ul><p><strong>Goroutine-协程和ThreadCreate-线程创建</strong></p><p>goroutine和threadcreate这两个采样指标在概念上和实现上都比较相似。</p><ul><li><p>Goroutine</p><p>记录所有用户发起且在运行中的goroutine（即入口非runtime开头的）以及runtime.main函数中的调用栈信息</p><p>Stop The World——&gt;遍历allg切片——&gt;输出创建g的堆栈——&gt;Start The World</p></li><li><p>ThreadCreate</p><p>记录程序创建的所有系统线程的信息</p><p>Stop The World——&gt;遍历allm切片——&gt;输出创建m的堆栈——&gt;Start The World</p></li><li><p>它们在实现上非常相似，都是在Stop The World之后遍历所有goroutine/所有线程的列表(上面的m就是 GMP模型中的m,在golang中和线程一一对应）并输出堆栈，最后Start The World继续运行。这个采样是立刻触发的全量记录，可以通过比较两个时间点的差值来得到某一时间段的指标。</p></li></ul><p><strong>Block-阻塞和Mutex-锁</strong></p><p>阻塞和锁竞争这两种采样指标在流程和原理上也非常相似，这两个采样记录的都是对应操作发生的调用栈、次数和耗时，不过这两个指标的采样率含义并不相同。</p><ul><li>阻塞操作<ul><li>采样阻塞操作的次数和耗时</li><li>采样率：阻塞耗时超过阈值时间的阻塞操作才会被记录，设置运行参数为1表示每次操作都会记录。</li></ul></li><li>锁竞争<ul><li>采样争抢锁的次数和耗时</li><li>采样率：只记录固定比例的锁操作，设置运行参数为1表示每次加锁都会记录。</li></ul></li><li>它们在实现上也是基本相同的，都是一个「主动上报」的过程<ul><li>在阻塞操作或锁操作发生时，会计算出消耗的时间，连同调用栈一起主动上报给采样器，采样器会根据采样率可能会丢弃一些记录。 例如时间未达阈值或者比例未命中。</li><li>在采样时，采样器会遍历已经记录的信息，统计出具体操作的次数、调用栈和总耗时。和堆内存一样， 可以对比两个时间点的差值计算出这段时间内的操作指标。</li></ul></li></ul><h4 id="小结-2"><a class="markdownIt-Anchor" href="#小结-2"></a> 小结</h4><ul><li>掌握常用pprof工具功能</li><li>灵活运用pprof工具分析解决性能问题</li><li>了解pprof的采样过程和工作原理</li></ul><h3 id="23-性能调优案例"><a class="markdownIt-Anchor" href="#23-性能调优案例"></a> 2.3 性能调优案例</h3><p><strong>简介</strong></p><p>介绍实际业务服务性能优化的案例。对逻辑相对复杂的程序进行性能调优。</p><ul><li><p>业务服务优化</p><p>业务服务一般指直接提供功能的服务，比如用户评论系统</p></li><li><p>基础库优化</p><p>基础库一般指提供通用功能的程序，主要是针对业务服务提供功能，比如监控组件，用于收集业务服务的运行指标</p></li><li><p>Go语言优化</p><p>对Go语言本身进行的优化项</p></li></ul><h4 id="231-业务服务优化"><a class="markdownIt-Anchor" href="#231-业务服务优化"></a> 2.3.1 业务服务优化</h4><p><strong>基本概念</strong></p><ul><li>服务：能单独部署，承载一定功能的程序</li><li>依赖：Service A的功能实现依赖Service B的响应结果，称为Service A依赖Service B</li><li>调用链路：能支持一个接口请求的相关服务集合及其相互之间的依赖关系</li><li>基础库：公共的工具包、中间件</li></ul><p><strong>流程</strong></p><ul><li>建立服务性能评估手段。</li><li>分析性能数据，定位性能瓶颈。用pprof采样性能数据、分析服务。</li><li>重点优化项改造。重构代码、使用更高效的组件等。</li><li>优化效果验证。通过压测对比和正确性验证之后，上线服务进行实际收益评估。</li></ul><p><strong>建立服务性能评估手段</strong></p><ul><li>服务性能评估方式<ul><li>单独的benchmark无法满足复杂逻辑分析</li><li>不同负载情况下性能表现有所差异</li></ul></li><li>请求流量构造<ul><li>不同请求参数覆盖逻辑不同</li><li>线上真实流量情况</li></ul></li><li>压测范围<ul><li>单机压测</li><li>集群压测</li></ul></li><li>性能数据采集<ul><li>单机性能数据</li><li>集群性能数据</li></ul></li></ul><p>最后表现为一个服务的性能指标分析报告</p><p><strong>分析性能数据，定位性能瓶颈</strong></p><p>常见性能问题</p><ul><li><p>使用库不规范</p><ul><li>基础组件不规范，一般是代码编写逻辑问题，比如提供了缓存机制，但是代码中没有开启。</li><li>日志使用不规范，一般是线上服务环境导致某一调用链路数据量剧增，日志量随之剧增，影响性能。</li></ul></li><li><p>高并发场景优化不足</p><p>例如同步请求造成的性能瓶颈，影响到了业务逻辑处理，后续可改造成异步请求提升性能。</p></li></ul><p><strong>重点优化项改造</strong></p><ul><li><p>性能优化的前提是保证正确性，在变动较大的性能优化上线之前，还需要进行正确性验证。由于线上的场景和流程太多，所以一般会借助自动化手段来保证优化后程序的正确性。</p></li><li><p>响应数据diff</p><ul><li><p>线上请求数据录制回放</p><p>不仅包含请求参数录制，还有线上的返回内容录制</p></li><li><p>新旧逻辑接口数据diff</p><p>重放时对比线上的返回内容和优化后服务的返回内容进行正确性验证</p></li></ul></li></ul><p><strong>优化效果验证</strong></p><ul><li>重复压测验证</li><li>上线评估优化效果<ul><li>关注服务监控</li><li>逐步放量</li><li>收集性能数据</li></ul></li></ul><p>压测并不能保证和线上表现完全一致，有时还要通过线上的表现再进行分析改进，是个长期的过程。</p><p><strong>进一步优化，服务整体链路分析</strong></p><ul><li>规范上游服务调用接口，明确场景需求</li><li>分析链路，通过业务流程优化提升服务性能</li></ul><h4 id="232-基础库优化"><a class="markdownIt-Anchor" href="#232-基础库优化"></a> 2.3.2 基础库优化</h4><p><strong>AB实验SDK的优化</strong></p><blockquote><p>A/B测试（也称为<strong>分割测试</strong>或<strong>桶测试</strong>）是一种将网页或应用程序的两个版本相互比较以确定哪个版本的性能更好的方法。AB测试本质上是一个实验，其中页面的两个或多个变体随机显示给用户，统计分析确定哪个变体对于给定的转换目标（指标如CTR）效果更好。</p></blockquote><ul><li>分析基础库核心逻辑和性能瓶颈<ul><li>设计完善改造方案</li><li>数据按需获取</li><li>数据序列化协议优化</li></ul></li><li>内部压测验证</li><li>推广业务服务落地验证</li></ul><h4 id="233-go语言优化"><a class="markdownIt-Anchor" href="#233-go语言优化"></a> 2.3.3 Go语言优化</h4><p><strong>编译器和运行时优化</strong></p><ul><li>优化内存分配策略</li><li>优化代码编译流程，生成更高效的程序</li><li>内部压测验证</li><li>推广业务服务落地验证</li></ul><p>优点</p><ul><li>接入简单，只需要调整编译配置</li><li>通用性强</li></ul><h3 id="24-总结"><a class="markdownIt-Anchor" href="#24-总结"></a> 2.4 总结</h3><ul><li>性能调优原则<ul><li>要依靠数据而不是猜测</li></ul></li><li>性能分析工具pprof<ul><li>熟练使用pprof工具排查性能问题并了解其基本原理</li></ul></li><li>性能调优<ul><li>保证正确性</li><li>定位主要瓶颈</li></ul></li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://go.dev/doc/tutorial/add-a-test">Add a test - The Go Programming Language</a></p><p><a href="https://pkg.go.dev/testing#hdr-Benchmarks">testing package - testing - Go Packages</a></p><p><a href="https://geektutu.com/post/hpg-slice.html">切片(slice)性能及陷阱 | Go 语言高性能编程 | 极客兔兔 </a></p><p><a href="https://cloud.tencent.com/developer/article/1496302">什么是A/B test？有哪些流程？有什么用？ - 腾讯云开发者社区-腾讯云</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文已收录到&lt;a href=&quot;https://juejin.cn/post/7194132732492906551&quot;&gt;golang高质量编程与性能调优 | 青训营笔记 - 掘金 (juejin.cn)&lt;/a&gt;，主要记录了对golang高质量编程与性能调优的学习</summary>
    
    
    
    <category term="golang" scheme="https://s-chance.github.io/categories/golang/"/>
    
    
    <category term="学习笔记" scheme="https://s-chance.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="青训营" scheme="https://s-chance.github.io/tags/%E9%9D%92%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>Go 工程进阶</title>
    <link href="https://s-chance.github.io/2023/01/26/golang-day2/"/>
    <id>https://s-chance.github.io/2023/01/26/golang-day2/</id>
    <published>2023-01-26T10:01:52.000Z</published>
    <updated>2023-01-30T13:29:21.864Z</updated>
    
    <content type="html"><![CDATA[<p>本文已收录到<a href="https://juejin.cn/post/7193685237723824187">golang工程进阶 | 青训营笔记 - 掘金 (juejin.cn)</a>，主要记录了对golang工程开发的学习<span id="more"></span></p><h2 id="语言进阶"><a class="markdownIt-Anchor" href="#语言进阶"></a> 语言进阶</h2><h3 id="1并发-vs-并行"><a class="markdownIt-Anchor" href="#1并发-vs-并行"></a> 1.并发 VS 并行</h3><ul><li>并发：多线程程序在一个核的CPU上运行</li><li>并行：多线程程序在多个核的CPU上运行</li></ul><p>go语言可以充分发挥多核优势，高效运行</p><h4 id="11-goroutine"><a class="markdownIt-Anchor" href="#11-goroutine"></a> 1.1 Goroutine</h4><ul><li>线程：用户态，轻量级线程，栈MB级别</li><li>协程：内核态，线程跑多个协程，栈KB级别</li></ul><p><strong>关于用户态和内核态的区别</strong></p><p>用户态和内核态是操作系统的两种运行级别。</p><p>当程序运行在3级特权级上时，就可以称之为运行在用户态，这是最低特权级，是普通用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态。</p><p>当程序运行在0级特权级上时，就可以称之为运行在内核态。</p><p>运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。用户态下的程序在其需要操作系统帮助完成某些它没有权限和能力完成的工作时就会切换到内核态，比如操作硬件。</p><p>这两种状态的主要差别是</p><ul><li>处于用户态执行时，进程所能访问的内存空间和对象受到限制，其处于占用的处理器是可被抢占的</li><li>处于内核态执行时，能够访问使用的内存空间和对象，且所占有的处理器是不允许被抢占的</li></ul><p><strong>快速打印</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello goroutine: &quot;</span> + fmt.Sprint(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloGoRoutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            hello(j)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-csp"><a class="markdownIt-Anchor" href="#12-csp"></a> 1.2 CSP</h4><p>CSP(Communicating Sequential Processes)是一种并发模型。在go语言中提倡通过通信共享内存而不是通过共享内存而实现通信（像Java、C++、Python等都是通过共享内存来实现通信），go语言通过goroutine和channel实现通过通信共享内存，这是go语言的独特优势。</p><h4 id="13-channel"><a class="markdownIt-Anchor" href="#13-channel"></a> 1.3 Channel</h4><p>通道channel是用来传递数据的一个数据结构。通道可用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;-用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。</p><p>创建通道，通道分为无缓冲通道和有缓冲通道，在创建时指定参数即可。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">//无缓冲通道</span></span><br><span class="line">buf := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>) <span class="comment">//有缓冲通道,缓冲区大小为100</span></span><br></pre></td></tr></table></figure><p>通道的基本使用</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">//把v发送到通道ch</span></span><br><span class="line">v := &lt;- ch <span class="comment">//从通道ch接收数据,并赋值给v</span></span><br></pre></td></tr></table></figure><p>一个示例</p><ul><li><p>一个子协程发送0~9数字</p></li><li><p>另一个子协程计算输入数字的平方</p></li><li><p>主协程输出结果</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CalSqrt</span><span class="params">()</span></span> &#123;</span><br><span class="line">    src := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    dest := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(src)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            src &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(dest)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> src &#123;</span><br><span class="line">            dest &lt;- i * i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dest &#123;</span><br><span class="line">        <span class="built_in">println</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="14-并发安全-lock"><a class="markdownIt-Anchor" href="#14-并发安全-lock"></a> 1.4 并发安全 Lock</h4><p>对变量执行大量重复操作，使用多个协程并发执行，利用锁来保证最终结果的正确性</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">x    <span class="type">int64</span></span><br><span class="line">    lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addWithLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++ &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        lock.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> addWithLock()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    <span class="built_in">println</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-waitgroup"><a class="markdownIt-Anchor" href="#15-waitgroup"></a> 1.5 WaitGroup</h4><p>waitgroup是go语言应用开发过程中经常使用的并发控制技术。其内部通过一个计数器来统计协程，这个计数器的值需要在启动协程之前用Add方法初始化，在结束一个协程的时候使用Done方法将计数器-1</p><p>当开启一个协程时，计数器+1；当一个协程执行完时，计数器-1；主线程会一直阻塞直到计数器为0。</p><p>改造前面的协程快速打印的示例，使用waitgroup实现协程的同步阻塞。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoWait</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">5</span>)  <span class="comment">//先初始化计数器再启动协程</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            hello(j) <span class="comment">//hello函数参考前面的例子</span></span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖管理"><a class="markdownIt-Anchor" href="#依赖管理"></a> 依赖管理</h2><p>go语言依赖管理的演进路线和go module实践。</p><p>依赖指各种开发包或者库，利用已经封装好的、经过验证的开发组件或工具，能够大大提升开发效率。</p><p>对于简单的程序来说，只需要依赖原生的SDK即可。对于实际工程来说，更多的是关注业务逻辑的实现，涉及框架、日志、驱动driver以及collection等一系列依赖都会通过sdk的方式引入，因此就需要对依赖包进行管理。</p><p>go依赖管理的演进主要经历了3个阶段，从GOPATH到Go Vendor再到目前被广泛应用的Go Module。主要围绕实现两个目标来迭代发展</p><ul><li>不同环境（项目）依赖的版本不同</li><li>控制依赖库的版本</li></ul><h3 id="gopath"><a class="markdownIt-Anchor" href="#gopath"></a> GOPATH</h3><p>GOPATH是go语言支持的一个环境变量，是go项目的工作区。根目录有以下结构</p><ul><li>src：存放go项目的源码</li><li>pkg：存放编译的中间产物，加快编译速度</li><li>bin：存在go项目编译生成的二进制文件</li></ul><p><strong>GOPATH的弊端</strong></p><p>GOPATH无法实现package的多版本控制。同一个pkg，存在两个版本，有两个项目依赖不同的版本，但是src下只能存放一个版本，那么就无法保证两个版本的项目都能通过编译。就是说在GOPATH管理模式下，如果多个项目依赖同一个库，则该库只能是同一份代码，无法实现多个项目依赖同一个库的不同版本。于是Go Vendor应运而生。</p><h3 id="go-vendor"><a class="markdownIt-Anchor" href="#go-vendor"></a> Go Vendor</h3><p>Go Vendor在GOPATH的基础上增加了vendor目录，用于存放当前项目依赖的副本。在Vendor机制下，如果当前目录存在vendor目录，则会优先使用该目录下的依赖，如果依赖不存在，再从GOPATH中寻找。这样，通过每个项目引入一份依赖副本，解决了多个项目需要同一个package依赖的冲突问题。但是vendor无法很好解决依赖包版本变动问题和一个项目依赖同一个包的不同版本的问题。实质上，vendor并不能很清晰地标识依赖的版本概念，无法控制依赖的版本，更新项目又可能导致依赖冲突、编译出错。于是又诞生了Go Module。</p><h3 id="go-module"><a class="markdownIt-Anchor" href="#go-module"></a> Go Module</h3><p>Go Module是go语言官方推出的依赖管理系统，解决了之前依赖管理系统存在的诸多问题。Go Module在go语言1.11版本开始引入，在go语言1.16版本默认开启。习惯上将Go Module称为go mod。</p><ul><li>通过go.mod文件管理依赖包版本</li><li>通过go get/go mod指令工具管理依赖包</li></ul><p>go mod最终目标是定义版本规则和管理项目依赖关系。（相当于Java中的Maven）</p><h3 id="依赖管理三要素"><a class="markdownIt-Anchor" href="#依赖管理三要素"></a> 依赖管理三要素</h3><table><thead><tr><th style="text-align:center">要素</th><th style="text-align:center">对应工具</th></tr></thead><tbody><tr><td style="text-align:center">配置文件，描述依赖</td><td style="text-align:center">go.mod</td></tr><tr><td style="text-align:center">中心仓库管理依赖库</td><td style="text-align:center">Proxy</td></tr><tr><td style="text-align:center">本地工具</td><td style="text-align:center">go get / go mod</td></tr></tbody></table><h3 id="依赖配置go-mod"><a class="markdownIt-Anchor" href="#依赖配置go-mod"></a> 依赖配置——go mod</h3><p>使用模块路径来标识一个模块，从模块路径找到该模块，如果是github前缀则表示可以从github仓库中找到该模块，依赖包的源代码由github托管，如果项目的子包需要被单独引用，则通过单独的init go.mod文件进行管理。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">module example/project/app <span class="comment">//依赖管理基本单元</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.16</span> <span class="comment">//原生sdk版本</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    <span class="comment">// 单元依赖</span></span><br><span class="line">    <span class="comment">// 依赖标识:模块路径+版本</span></span><br><span class="line">example/lib1 v1<span class="number">.0</span><span class="number">.2</span></span><br><span class="line">    example/lib2 v1<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="依赖配置version"><a class="markdownIt-Anchor" href="#依赖配置version"></a> 依赖配置——version</h3><p>GOPATH和Go Vendor都是源码副本形式的依赖，没有版本规则的概念，而go mod为了方便管理定义了版本规则，分为语义化版本和基于commit的伪版本。</p><ul><li><p>语义化版本有三个部分<code>$&#123;MAJOR&#125;.$&#123;MINOR&#125;.$&#123;PATCH&#125;</code>，如v1.3.0，v2.3.0</p><p>不同的MAJOR版本表示是不兼容的API，所以即使是同一个库，MAJOR版本不同也会被认为是不同的模块。</p><p>MINOR版本通常是新增函数或功能，向后兼容。</p><p>PATCH版本一般是修复bug。</p></li><li><p>基于commit的伪版本也有三个部分<code>vX.0.0-yyyymmddhhmmss-abcdefgh1234</code></p><p>基础版本前缀和语义化版本是一样的。</p><p>时间戳，也就是提交commit的时间。</p><p>最后是校验码，包含12位的哈希前缀。每次commit后go都会默认生成一个伪版本号。</p></li></ul><h3 id="依赖配置indirect"><a class="markdownIt-Anchor" href="#依赖配置indirect"></a> 依赖配置——indirect</h3><p>依赖单元中的特殊标识符，indirect后缀，表示go.mod对应的当前模块没有直接导入该依赖模块的包，也就是间接依赖。</p><h3 id="依赖配置incompatible"><a class="markdownIt-Anchor" href="#依赖配置incompatible"></a> 依赖配置——incompatible</h3><p>在主版本为v2及以上的模块后面会有+incompatible后缀，这让go mod能够按照不同的模块来处理同一个项目不同主版本的依赖。由于go mod是在go1.11版本才开始引入，在这个更新之前已经有一些仓库打上了v2或者更高的版本tag。为了兼容这部分仓库，对于没有go.mod文件且MAJOR主版本在v2及以上的依赖，会在版本号后面加上<code>+incompatible</code>的后缀，表示可能存在不兼容的源代码。</p><h3 id="依赖配置依赖图"><a class="markdownIt-Anchor" href="#依赖配置依赖图"></a> 依赖配置——依赖图</h3><p>如果一个主项目依赖A、B两个项目，A、B分别依赖C项目v1.3、v1.4的两个版本，则最终编译时所使用的C项目版本为最低的兼容版本，即v1.4。</p><h3 id="依赖分发回源"><a class="markdownIt-Anchor" href="#依赖分发回源"></a> 依赖分发——回源</h3><p>依赖分发，也就是指go mod从哪里下载，如何下载。</p><p>Go Modules系统中定义的依赖最终可以对应到多版本代码管理系统中某一项目的特定提交或版本，这样的话，对于go.mod中定义的依赖，则直接可以从对应仓库中下载指定软件依赖，从而完成依赖分发。</p><p>但直接使用版本管理仓库下载依赖，存在诸多问题</p><ul><li>无法保证构建确定性，软件作者可以直接在代码平台 增加/修改/删除 软件版本，导致下次构建时使用另外版本的依赖或者找不到依赖版本。</li><li>无法保证依赖可用性，依赖软件作者可以直接在代码平台删除软件，导致依赖不可用。</li><li>增加第三方压力，每次从第三方代码托管平台下载依赖时都会增加第三方代码托管平台的压力。</li></ul><h3 id="依赖分发proxy"><a class="markdownIt-Anchor" href="#依赖分发proxy"></a> 依赖分发——Proxy</h3><p>Go Proxy就是解决上述的依赖分发问题。Go Proxy是一个服务站点，它会缓存源站中的软件内容，缓存的软件版本不会改变，并且在源站软件删除之后依然能够下载，从而实现了immutability（不变性）和available（可用的）的依赖分发。</p><p>使用Go Proxy之后，构建时会直接从Go Proxy站点拉取依赖。</p><h3 id="依赖分发变量-goproxy"><a class="markdownIt-Anchor" href="#依赖分发变量-goproxy"></a> 依赖分发——变量 GOPROXY</h3><p>Go Modules通过GOPROXY环境变量使用Go Proxy服务。GOPROXY是一个Go Proxy站点URL列表，可以使用&quot;direct&quot;表示源站。</p><p>示例配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GOPROXY=<span class="string">&quot;https://proxy1.cn, https://proxy2.cn, direct&quot;</span></span><br></pre></td></tr></table></figure><p>对于以上配置，整体的依赖寻址路径会先从proxy1下载，如果proxy1不存在，再从proxy2寻找，如果proxy2不存在，则回源到源站直接下载依赖，并缓存到proxy站点中。</p><h3 id="工具go-get"><a class="markdownIt-Anchor" href="#工具go-get"></a> 工具——go get</h3><p>go get是Go Module的两个重要工具之一。</p><p>go get使用命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get example.org/pkg...</span><br></pre></td></tr></table></figure><p>以上命令后面接不同的指令，这些指令具有不同的作用</p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">@update</td><td style="text-align:center">默认</td></tr><tr><td style="text-align:center">@none</td><td style="text-align:center">删除依赖</td></tr><tr><td style="text-align:center">@v1.1.2</td><td style="text-align:center">下载指定tag版本，语义版本</td></tr><tr><td style="text-align:center">@23dfdd5</td><td style="text-align:center">特定的commit</td></tr><tr><td style="text-align:center">@master</td><td style="text-align:center">分支的最新commit</td></tr></tbody></table><h3 id="工具go-mod"><a class="markdownIt-Anchor" href="#工具go-mod"></a> 工具——go mod</h3><p>go mod也是Go Module中的重要工具。</p><p>go mod 使用命令</p><p>初始化，创建go.mod文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod init</span><br></pre></td></tr></table></figure><p>下载模块到本地缓存</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod download</span><br></pre></td></tr></table></figure><p>增加需要的依赖，删除不需要的依赖</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><p>在实际开发中，建议在向仓库提交代码之前执行<code>go mod tidy</code>，可以减少构建时无效依赖包的拉取。</p><p><strong>使用go mod前的一些注意事项</strong></p><ul><li>设置GO111MODULE=on，表示只使用Go Module而不会使用GOPATH。具体配置参考<a href="https://goproxy.cn/">七牛云 - Goproxy.cn</a></li><li>清空IDE中的所有的GOPATH。go mod和GOPATH不能并存，开启go mod之后需要在IDE中把项目从GOPATH移除，否则可能会出错。</li><li>在项目中创建go.mod文件，如果已经存在则不需要重新创建。创建完go.mod文件后先执行<code>go mod tidy</code>来增加项目启动所需的最小依赖。</li></ul><h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2><p>在实际工程开发中，除了依赖管理，还有另一个重要概念就是单元测试，包括单元测试规范、Mock测试、基准测试。测试关系着系统的质量，质量决定线上系统的稳定性，一旦出现问题就会引起事故。测试就是为了避免这些事故。</p><p>测试一般分为回归测试，集成测试和单元测试。回归测试一般是手动通过终端回归一些固定的主流场景，集成测试是对系统功能维度做测试验证，而单元测试阶段，开发者对单独的函数、模块做功能验证，层级至上而下，测试成本逐渐降低，测试覆盖率逐步上升。因此单元测试的覆盖率一定程度上决定了代码的质量。</p><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><p>单元测试主要包括输入、测试单元、输出，以及校对。单元的概念比较广泛，包括接口、函数、模块等。最后的校对用于保证代码的功能符合预期。单元测试一方面可以保证质量，在整体覆盖率足够的情况下，一定程度上即保证了新功能本身的正确性，又保护了原有代码的完整性；另一方面可以提升效率，在代码存在bug的情况下，通过单元测试，可以在较短周期内定位和修复问题。</p><h4 id="规则"><a class="markdownIt-Anchor" href="#规则"></a> 规则</h4><p>单元测试的一些基本规范</p><ul><li>所有测试文件名称以_test.go结尾</li><li>所有用于测试的函数声明为<code>func TestXxx(t *testing.T)</code></li><li>初始化逻辑放到TestMain函数中实现</li></ul><p>这样就很好地区分了源代码和测试代码。</p><h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h4><p>源代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloTom</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHelloTom</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    output := HelloTom()</span><br><span class="line">    expectOutput := <span class="string">&quot;Tom&quot;</span></span><br><span class="line">    <span class="keyword">if</span> output != expectOutput &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;Expected %s do not match actual %s&quot;</span>, expectOutput, output)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h4><p>运行查看结果</p><h4 id="assert"><a class="markdownIt-Anchor" href="#assert"></a> assert</h4><p>assert包提供了对代码测试的支持，能够快速方便地进行代码测试</p><p>获取assert包，在当前项目中使用以下命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/stretchr/testify/assert</span><br></pre></td></tr></table></figure><p>改造原来的测试代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHelloTom</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    output := HelloTom()</span><br><span class="line">    expectOutput := <span class="string">&quot;Tom&quot;</span></span><br><span class="line">    assert.Equal(t, expectOutput, output)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行查看结果，使用assert测试能够输出更加详细的信息。</p><h4 id="覆盖率"><a class="markdownIt-Anchor" href="#覆盖率"></a> 覆盖率</h4><p>代码覆盖率用于衡量代码是否经过了足够的测试，评价项目的测试水准，评估项目是否达到了高水准测试等级。</p><p><strong>示例代码</strong></p><p>judgment.go</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JudgePassLine</span><span class="params">(score <span class="type">int16</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> score &gt;= <span class="number">60</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>judgment_test.go</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestJudgePassLineTrue</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    isPass := JudgePassLine(<span class="number">70</span>)</span><br><span class="line">    assert.Equal(t, <span class="literal">true</span>, isPass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用以下命令进行测试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> judgment_test.go judgment.go --cover</span><br></pre></td></tr></table></figure><p>通过指定cover参数，可以看到覆盖率，表示执行到的代码行数占实际代码总行数。</p><p><strong>提升覆盖率</strong></p><p>可以在测试代码中增加其他的情况，重新执行所有单元测试，最终使覆盖率达到100%</p><p>新增测试函数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestJudgePassLineFail</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    isPass := JudgePassLine(<span class="number">50</span>)</span><br><span class="line">    assert.Equal(t, <span class="literal">false</span>, isPass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新执行测试命令，指定cover参数，查看测试结果。</p><h4 id="tips"><a class="markdownIt-Anchor" href="#tips"></a> Tips</h4><ul><li>实际项目中，一般要求覆盖率是50%~60%，对于资金型服务，覆盖率要求达到80%以上。</li><li>在进行单元测试时，要求测试分支相互独立、全面覆盖。</li><li>测试单元粒度足够小，函数职责单一，即要求函数体足够小，这样能比较简单地提升覆盖率，也符合函数设计的单一职责。</li></ul><h3 id="mock测试"><a class="markdownIt-Anchor" href="#mock测试"></a> Mock测试</h3><p>工程中复杂的项目一般会依赖File、DB、Cache等外部依赖，而单元测试需要保证稳定性和幂等性。稳定性指相互隔离，能在任何时间、任何环境下运行测试；幂等是指每次测试运行都应该产生与之前一样的结果。而实现这些目的就需要Mock机制。</p><h4 id="文件处理"><a class="markdownIt-Anchor" href="#文件处理"></a> 文件处理</h4><p>将测试文件进行删除，进行单元测试，测试通过，但单元测试需要依赖本地的文件，如果文件被修改或者删除测试就会失败，也就是说删除文件的测试普通情况下只能测试一次。为了保证测试case的稳定性，需要对删除文件函数进行mock，屏蔽对文件的依赖。</p><h4 id="快速mock函数"><a class="markdownIt-Anchor" href="#快速mock函数"></a> 快速Mock函数</h4><p>这里提供了一个开源的mock测试库<a href="https://github.com/bouk/monkey">Monkey patching in Go</a>，可以对函数或者实例的方法进行mock测试，原理是反射和指针赋值。这里引入了一个打桩的概念，桩或者桩代码就是指用来代替关联代码或者未实现代码的代码，目的主要是隔离、补齐、控制。</p><p>快速Mock函数能为一个函数打桩或为一个方法打桩。Monkey Patch的作用域在Runtime，在运行时通过Go的unsafe包，能够将内存中函数的地址替换为运行时函数的地址，将待打桩函数或方法的实现跳转到运行时。</p><h4 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h4><p>通过patch对ReadFirstLine进行打桩mock，通过defer卸载mock，使整个测试函数脱离了对本地文件的依赖。</p><p>源代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFirstLine</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    open, err := os.Open(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> open.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    scanner := bufio.NewScanner(open)</span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        <span class="keyword">return</span> scanner.Text()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessFirstLine</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    line := ReadFirstLine()</span><br><span class="line">    destLine := strings.ReplaceAll(line, <span class="string">&quot;11&quot;</span>, <span class="string">&quot;00&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> destLine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestProcessFirstLine</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    firstLine := ProcessFirstLine()</span><br><span class="line">    assert.Equal(t, <span class="string">&quot;line00&quot;</span>, firstLine)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试文件内容</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">line11</span><br><span class="line">line22</span><br><span class="line">line33</span><br><span class="line">line44</span><br><span class="line">line55</span><br></pre></td></tr></table></figure><p>monkey的部分源代码实现，主要通过这些函数实现打桩</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Patch</span><span class="params">(target, replacement <span class="keyword">interface</span>&#123;&#125;)</span></span> *PatchGuard &#123;</span><br><span class="line">    t := reflect.ValueOf(target)</span><br><span class="line">    r := reflect.ValueOf(replacement)</span><br><span class="line">    patchValue(t, r)</span><br><span class="line">    <span class="keyword">return</span> &amp;PatchGuard&#123;t, r&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unpatch</span><span class="params">(target <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unpatchValue(reflect.ValueOf(target))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造测试代码增加函数实现打桩，通过patch对ReadFirstLine进行打桩mock，使其默认返回line110</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReadFirstLineWithMock</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">monkey.Patch(ReadFirstLine, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;line110&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">defer</span> monkey.Unpatch(ReadFirstLine)</span><br><span class="line">line := ProcessFirstLine()</span><br><span class="line">assert.Equal(t, <span class="string">&quot;line000&quot;</span>, line)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样即使没有本地文件，也能够模拟读取、修改或删除文件的测试。</p><h3 id="基准测试"><a class="markdownIt-Anchor" href="#基准测试"></a> 基准测试</h3><p>go语言还提供了基准测试框架，基准测试是指测试一段程序的运行性能及耗费CPU的程度。在实际项目开发中，经常会遇到代码性能瓶颈，为了定位问题经常要对代码做性能分析，这就用到了基准测试。</p><h4 id="示例-3"><a class="markdownIt-Anchor" href="#示例-3"></a> 示例</h4><p>服务器负载均衡问题。</p><p>源代码，假设有10台服务器，每次随机选择其中1台执行。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitServerIndex</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">ServerIndex[i] = i + <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Select</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ServerIndex[rand.Intn(<span class="number">10</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码，基准测试以Benchmark开头，参数类型是testing.B，用b中的N值反复递增循环测试。基准测试对于一个测试用例的默认测试时间是1秒，当测试用例函数返回时还不到1秒，那么testing.B中的N值将按1、2、5、10、20、50…递增，并以递增后的值重新进行用例函数测试。</p><p>ResetTimer重置计时器，在重置之前的初始化或其他准备操作，不属于基准测试的范围，通过选择重置的时间点来跳过不必要的测试。</p><p>RunParallel是多协程并发测试。执行两个基准测试，可以发现代码在并发情况下存在劣化，主要原因是rand包为了保证全局的随机性和并发安全，使用了全局锁。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSelect</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">InitServerIndex()</span><br><span class="line">b.ResetTimer()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">Select()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSelectParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">InitServerIndex()</span><br><span class="line">b.ResetTimer()</span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">Select()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行-2"><a class="markdownIt-Anchor" href="#运行-2"></a> 运行</h4><p>在IDE中使用<code>gobench benchmark</code>选项进行测试，不要直接运行。</p><h4 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h4><p>为了解决上述的随机性能瓶颈问题，有一个开源的高性能随机数方法fastrand，仓库地址<a href="https://github.com/bytedance/gopkg">bytedance/gopkg</a>。主要思路是牺牲了一定的数列一致性来换取性能，在大多数场景下适用，相比原始方法的性能有大幅提升。</p><p>引入fastrand</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/bytedance/gopkg</span><br></pre></td></tr></table></figure><p>将源代码中的rand替换为fastrand即可。</p><h2 id="项目实战"><a class="markdownIt-Anchor" href="#项目实战"></a> 项目实战</h2><p>在并发编程，依赖管理以及单元测试的基础上，通过项目实践来理解项目开发的思路和流程，主要包括需求设计，代码开发和测试运行。</p><h3 id="需求设计"><a class="markdownIt-Anchor" href="#需求设计"></a> 需求设计</h3><h4 id="需求背景"><a class="markdownIt-Anchor" href="#需求背景"></a> 需求背景</h4><p>开发一个类似掘金社区的服务端小功能。</p><h4 id="需求描述"><a class="markdownIt-Anchor" href="#需求描述"></a> 需求描述</h4><p>社区话题页面</p><ul><li>展示话题（标题、文字描述）和回帖列表</li><li>暂不考虑前端页面实现，仅仅实现一个本地web服务</li><li>话题和回帖数据用文件存储</li></ul><h4 id="需求用例"><a class="markdownIt-Anchor" href="#需求用例"></a> 需求用例</h4><p>主要涉及用户浏览消费，页面的展示，包括话题内容和回帖的列表。可以先抽象出两个实体，话题内容和回帖列表，分析它们所具有的属性以及联系，定义出结构体。</p><h4 id="er-图entity-relationship-diagram"><a class="markdownIt-Anchor" href="#er-图entity-relationship-diagram"></a> ER 图——Entity Relationship Diagram</h4><p>ER图用于描述现实世界的概念模型。有了模型实体、属性以及联系，就能进入下一步，思考代码结构设计。</p><p>参考ER图设计：Topic话题有id、titile、content、create_time四个属性。Post帖子有id、topic_id、content、create_time四个属性，其中id和topic_id和Topic相联系。</p><p>这里采用典型的分层结构设计。</p><h3 id="代码开发"><a class="markdownIt-Anchor" href="#代码开发"></a> 代码开发</h3><h4 id="分层结构"><a class="markdownIt-Anchor" href="#分层结构"></a> 分层结构</h4><p>分层结构整体分为三层，repository数据层，service逻辑层，controller视图层。</p><ul><li>数据层关联底层数据模型，也就是model，封装外部数据的增删改查。这里的数据存储在本地文件，通过文件操作拉取话题，帖子数据。</li><li>数据层面向逻辑层，也就是对service层透明，屏蔽下游数据差异，即逻辑层不需要考虑数据的来源是本地文件、数据库还是微服务等。逻辑层只处理核心业务逻辑，接口模型保持不变，计算打包业务实体Entity，对应需求并上传给视图层。</li><li>视图层controller负责处理与外部交互的逻辑，以view视图的形式返回给客户端。这里只考虑封装为json格式化的请求结果，通过API形式访问即可。</li></ul><h4 id="组件工具"><a class="markdownIt-Anchor" href="#组件工具"></a> 组件工具</h4><p>开发涉及的基础组件工具。Gin：开源的高性能go web框架，源地址<a href="https://github.com/gin-gonic/gin">gin-gonic</a>。这里基于gin搭建web服务器，本项目主要涉及路由分发的概念，不涉及其他复杂概念。</p><p>使用web框架，需要用Go Module依赖管理。先用go mod init初始化go.mod管理配置文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod init main</span><br><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><p>下载gin依赖</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><p>在框架依赖的基础上，只需要关注业务本身的实现，从repository到service再到controller逐步实现。</p><h4 id="repository"><a class="markdownIt-Anchor" href="#repository"></a> Repository</h4><h5 id="struct"><a class="markdownIt-Anchor" href="#struct"></a> struct</h5><p>根据之前的ER图定义结构体</p><h5 id="index"><a class="markdownIt-Anchor" href="#index"></a> index</h5><p>查询数据可以使用全扫描遍历的方式，但是效率不高，所以这里引入索引的概念。</p><p>索引就像书的目录，可以快速查找定位到需要的结果。这里利用map实现内存索引，在服务对外暴露前，利用文件元数据初始化全局内存索引，实现O(1)时间复杂度的查找操作。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">topicIndexMap <span class="keyword">map</span>[<span class="type">int64</span>]*Topic</span><br><span class="line">    postIndexMap  <span class="keyword">map</span>[<span class="type">int64</span>][]*Post</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>具体实现，打开文件，基于file初始化scanner，通过迭代器方式遍历数据行，转化为结构体存储至内存map，完成初始化话题内存索引。同理实现帖子的内存索引初始化</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initTopicIndexMap</span><span class="params">(filePath <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    open, err := os.Open(filePath + <span class="string">&quot;topic&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    scanner := bufio.NewScanner(open)</span><br><span class="line">    topicTmpMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]*Topic)</span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        text := scanner.Text()</span><br><span class="line">        <span class="keyword">var</span> topic Topic</span><br><span class="line">        <span class="keyword">if</span> err := json.Unmarshal([]<span class="type">byte</span>(text), &amp;topic); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        topicTmpMap[topic.Id] = &amp;topic</span><br><span class="line">    &#125;</span><br><span class="line">    topicIndexMap = topicTmpMap</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h5><p>实现查询操作，直接查询key获取map中的value。这里使用了sync.Once，主要适用于高并发的情况下只执行一次的场景。基于Once的实现模式就是单例模式，减少存储的浪费。</p><p>topic查询实现，这里的topic结构体自行设计。同理实现post的查询</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TopicDao <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">topicDao  *TopicDao</span><br><span class="line">    topicOnce sync.Once</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTopicDaoInstance</span><span class="params">()</span></span> *TopicDao &#123;</span><br><span class="line">    topicOnce.Do(</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            topicDao = &amp;TopicDao&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">return</span> topicDao</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*TopicDao)</span></span> QueryTopicById(id <span class="type">int64</span>) *Topic &#123;</span><br><span class="line">    <span class="keyword">return</span> topicIndexMap[id]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="service"><a class="markdownIt-Anchor" href="#service"></a> Service</h4><p>实现了repository层之后就是service层。</p><p>定义service层实体</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PageInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Topic *repository.Topic</span><br><span class="line">    PostList []*repository.Post</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现流程是参数校验、准备数据、组装实体。</p><p>代码流程编排，通过err控制流程退出，正常的话会返回页面信息。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *QueryPageInfoFlow)</span></span> Do() (*PageInfo, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> err := f.checkParam(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := f.prepareInfo(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := f.packPageInfo(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f.pageInfo, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prepareInfo方法实现，由于话题和回帖信息的获取都需要topicId，这就可以考虑并行执行，提高效率。并行可以充分利用多核CPU的资源，降低接口耗时。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *QueryPageInfoFlow)</span></span> prepareInfo() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;...&#125; <span class="comment">//获取topic信息</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;...&#125; <span class="comment">//获取post列表</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="controller"><a class="markdownIt-Anchor" href="#controller"></a> Controller</h4><p>service层之后是controller层。定义一个view对象，通过code msg打包业务状态信息，用data承载业务实体信息。</p><p>参考代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PageData <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code <span class="type">int64</span>       <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">    Msg  <span class="type">string</span>      <span class="string">`json:&quot;msg&quot;`</span></span><br><span class="line">    Data <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QueryPageInfo</span><span class="params">(topicIdStr <span class="type">string</span>)</span></span> *PageData &#123;</span><br><span class="line">    topicId, err := strconv.ParseInt(topicIdStr, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;...&#125;</span><br><span class="line">    pageInfo, err := service.QueryPageInfo(topicId)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;PageData&#123;</span><br><span class="line">        Code: <span class="number">0</span>,</span><br><span class="line">        Msg: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">        Data: <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>&#123;</span><br><span class="line">            <span class="string">&quot;post_id&quot;</span>: postId,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="router"><a class="markdownIt-Anchor" href="#router"></a> Router</h4><p>最后是web服务的引擎配置，包括</p><ul><li>初始化数据索引</li><li>初始化引擎配置</li><li>构建路由</li><li>启动服务</li></ul><p>path映射到具体的controller，通过path变量传递话题id。</p><p>参考写法</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := Init(<span class="string">&quot;./data/&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        os.Exit(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/community/page/get/:id&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        topicId := c.Param(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">        data := controller.QueryPageInfo(topicId)</span><br><span class="line">        c.JSON(<span class="number">200</span>, data)</span><br><span class="line">    &#125;)</span><br><span class="line">    err := r.Run()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试运行"><a class="markdownIt-Anchor" href="#测试运行"></a> 测试运行</h3><p>通过go run命令运行本地web服务，main.go是这里main方法所在的go文件，文件名称可以自定义</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure><p>通过curl命令请求服务暴露的接口，查看结果。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --location --request GET <span class="string">&quot;http://0.0.0.0:8080/community/get/1&quot;</span> | json</span><br></pre></td></tr></table></figure><p>这里的json命令是通过nodejs的npm安装的，用于格式化curl输出的json信息。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g json</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://www.cnblogs.com/gizing/p/10925286.html">用户态和内核态的区别 - Gizing - 博客园 (cnblogs.com)</a></p><p><a href="https://segmentfault.com/a/1190000018150987">Go goroutine理解 - golang开发笔记 - SegmentFault 思否</a></p><p><a href="https://www.runoob.com/go/go-concurrent.html">Go 并发 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://juejin.cn/post/7181812988461252667">深入理解 go sync.Waitgroup - 掘金 (juejin.cn)</a></p><p><a href="https://blog.csdn.net/Sihang_Xie/article/details/124851399">【Go语言入门】一文搞懂Go语言的最新依赖管理：go mod的使用</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文已收录到&lt;a href=&quot;https://juejin.cn/post/7193685237723824187&quot;&gt;golang工程进阶 | 青训营笔记 - 掘金 (juejin.cn)&lt;/a&gt;，主要记录了对golang工程开发的学习</summary>
    
    
    
    <category term="golang" scheme="https://s-chance.github.io/categories/golang/"/>
    
    
    <category term="学习笔记" scheme="https://s-chance.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="青训营" scheme="https://s-chance.github.io/tags/%E9%9D%92%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>Go语言基础</title>
    <link href="https://s-chance.github.io/2023/01/26/golang-day1/"/>
    <id>https://s-chance.github.io/2023/01/26/golang-day1/</id>
    <published>2023-01-25T18:24:18.000Z</published>
    <updated>2023-01-30T13:28:53.275Z</updated>
    
    <content type="html"><![CDATA[<p>本文已收录到<a href="https://juejin.cn/post/7192662401240531004">golang基础学习 | 青训营笔记 - 掘金 (juejin.cn)</a>，主要记录了对golang的初步学习<span id="more"></span></p><h2 id="11-什么是go语言"><a class="markdownIt-Anchor" href="#11-什么是go语言"></a> 1.1 什么是Go语言</h2><h3 id="1高性能-高并发"><a class="markdownIt-Anchor" href="#1高性能-高并发"></a> 1.高性能、高并发</h3><p>拥有和C++、Java媲美的性能，拥有对高并发的支持，不需要额外的第三方库，只需要使用标准库或者基于标准库的第三方库就能进行高并发开发</p><h3 id="2语法简单-学习曲线平缓"><a class="markdownIt-Anchor" href="#2语法简单-学习曲线平缓"></a> 2.语法简单、学习曲线平缓</h3><p>语法风格类似C语言，且在C语言的基础上进行了大幅度简化，例如去掉了不必要的表达式括号，循环只有for循环一种方式就能实现各种数值、键值遍历</p><p>一个基于Go的简单的Http服务器demo</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(http.Dir(<span class="string">&quot;.&quot;</span>)))</span><br><span class="line">    http.ListenAndServer(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3丰富的标准库"><a class="markdownIt-Anchor" href="#3丰富的标准库"></a> 3.丰富的标准库</h3><p>拥有及其丰富、功能完善、质量可靠的标准库。在很多情况下，不需要借助第三方库就可以完成大部分基础功能的开发，大大降低了学习和使用成本。最关键的是，标准库具有很高的稳定性和兼容性保障，还能持续享受语言迭代所带来的性能优化。这是第三方库所不具备的</p><h3 id="4完善的工具链"><a class="markdownIt-Anchor" href="#4完善的工具链"></a> 4.完善的工具链</h3><p>拥有丰富的工具链，编译、代码格式化、错误检查、帮助文档、包管理以及代码补全提示。Go还内置了完整的单元测试框架，支持单元测试、性能测试、代码覆盖率、数据键增检测、性能优化，保障代码能够正确稳定运行</p><h3 id="5静态链接"><a class="markdownIt-Anchor" href="#5静态链接"></a> 5.静态链接</h3><p>在Go语言中所有的编译结构默认为静态链接，只需要编译后的唯一一个可执行文件不需要附加任何其它东西，即可部署运行。在线上的容器环境中运行，镜像体积可以控制得非常小，部署非常方便快捷。不同于C++，需要一堆动态链接库（linux下表现为.so文件，win下是.dll文件以及由.dll生成的.lib文件）才可以正确运行，文本不正确的话就会崩溃。Java则需要附加一个庞大的JRE才能运行</p><h3 id="6快速编译"><a class="markdownIt-Anchor" href="#6快速编译"></a> 6.快速编译</h3><p>Go语言拥有静态语言中几乎最快的编译速度，增量编译完成。这个速度对C++开发来说不可想象</p><h3 id="7跨平台"><a class="markdownIt-Anchor" href="#7跨平台"></a> 7.跨平台</h3><p>Go语言能在常见的linux、windows、macos，也能够开发android、ios软件，还能在一些硬件设备上运行，例如路由器、树莓派。Go还拥有很方便的交叉编译特性，能够轻松在笔记本上编译出二进制文件拷贝到路由器中运行，而无需配置交叉编译环境</p><h3 id="8垃圾回收"><a class="markdownIt-Anchor" href="#8垃圾回收"></a> 8.垃圾回收</h3><p>Go语言自带垃圾回收机制，和Java类似，在开发的时候无需考虑内存的分配和释放，可以专注于业务逻辑</p><h2 id="12-哪些公司在使用go语言"><a class="markdownIt-Anchor" href="#12-哪些公司在使用go语言"></a> 1.2 哪些公司在使用Go语言</h2><p>ByteDance字节跳动、Google谷歌、Tencent腾讯、facebook脸书、bilibili哔哩哔哩等</p><p>在云计算、微服务、大数据、区块链、物联网等领域广泛发展，尤其在云计算、微服务领域产出了大量的云原生组件</p><h2 id="13-为什么选择go语言"><a class="markdownIt-Anchor" href="#13-为什么选择go语言"></a> 1.3 为什么选择Go语言</h2><ol><li>随着业务体量的不断增长，Python对于Web业务存在性能瓶颈</li><li>C++的特性使其不太适合在线Web业务</li><li>Go的学习难度低于Java</li><li>Go的性能比较好</li><li>Go的部署简单，学习成本低（没有Python的依赖库版本问题）</li><li>基于Go研发的内部RPC框架和HTTP框架，推动了业务重构</li></ol><h2 id="21-开发环境"><a class="markdownIt-Anchor" href="#21-开发环境"></a> 2.1 开发环境</h2><h3 id="安装golang"><a class="markdownIt-Anchor" href="#安装golang"></a> 安装Golang</h3><p><a href="https://go.dev/">Golang官网</a></p><p><a href="https://studygolang.com/dl">Golang镜像</a></p><p><a href="https://goproxy.cn/">Golang第三方包代理加速下载</a></p><h3 id="配置集成开发环境"><a class="markdownIt-Anchor" href="#配置集成开发环境"></a> 配置集成开发环境</h3><p>以下三种方案选其一即可</p><ol><li><p><a href="https://code.visualstudio.com/">Visual Studio Code</a></p></li><li><p><a href="https://www.jetbrains.com.cn/go/promo">Goland</a></p><p>关于Goland控制台输出#gosetup的多余信息，影响观察。快捷键Ctrl+Alt+shift+/，打开Registry，取消勾选go.run.processes.with.pty。之后#gosetup的信息会被折叠，方便直接观察程序输出结果</p></li><li><p><a href="https://www.gitpod.io/">云开发环境Gitpod</a></p></li></ol><h2 id="22-基础语法"><a class="markdownIt-Anchor" href="#22-基础语法"></a> 2.2 基础语法</h2><h3 id="1hello-world"><a class="markdownIt-Anchor" href="#1hello-world"></a> 1.Hello World</h3><p>main.go文件</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>package main代表这个文件属于main包，main包是程序的入口包</p></li><li><p>fmt包是标准库里的包，主要用于输入输出字符串，格式化字符串</p></li><li><p>func main就是go语言main函数的声明，需要注意的是 <strong>花括号{</strong> 必须和func main写在同一行，否则会报错</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">.\test.go:6:1: syntax error: unexpected semicolon or newline before &#123;</span><br></pre></td></tr></table></figure></li><li><p>在main函数里用fmt.Println调用了fmt包中的Println函数，需要注意的是import的包必须要在程序中使用到，不能只是import这个包而不去使用，会报错</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">.\test.go:3:8: imported and not used: <span class="string">&quot;fmt&quot;</span></span><br></pre></td></tr></table></figure></li></ul><p>编译运行命令（在文件的同级目录下run或者build后执行）</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line">go build main.go</span><br><span class="line">./main</span><br></pre></td></tr></table></figure><ul><li>go run 直接运行go文件</li><li>go build会生成一个exe文件，运行exe文件得到结果</li></ul><h3 id="2变量"><a class="markdownIt-Anchor" href="#2变量"></a> 2.变量</h3><p>go语言是一门强类型语言，每个变量都有各自的变量类型。</p><p>常见的变量类型：字符串、整型、浮点型、布尔型等。</p><p>go语言的字符串是内置类型，可以直接通过+号拼接，也能够直接使用==去比较两个字符串（不同于Java需要使用equals方法去比较）。</p><p>go语言大部分运算符的使用和优先级和C/C++类似。</p><h4 id="变量声明"><a class="markdownIt-Anchor" href="#变量声明"></a> 变量声明</h4><p>在go语言中变量的声明方式有两种</p><p>一种是通过var name string = &quot;&quot;这种方式来声明变量，声明变量的时候一般会自动推导变量的类型，有需要也可以显式写明变量类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;hello&quot;</span>  <span class="comment">//自动推导变量类型</span></span><br><span class="line"><span class="keyword">var</span> t1,t2 <span class="type">int</span>  <span class="comment">//可以声明多个相同类型的变量</span></span><br></pre></td></tr></table></figure><p>另一种变量声明是短声明，使用 变量 := 值 的格式。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">name := <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>需要注意的是使用var声明过的变量名，不能用短声明重复声明。</p><p>go语言的常量，就是用const关键字替代var关键字声明。需要注意的是，go语言中的常量没有一个确定的类型，它会根据上下文来自动确定类型。</p><h3 id="3if-else"><a class="markdownIt-Anchor" href="#3if-else"></a> 3.if else</h3><p>go语言中的if else不同于其他语言</p><p>go语言中if后面没有小括号()</p><p>go语言中if后面必须要有大括号{}，没有C/C++那种缺省大括号写在同一行的写法</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if-else</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">7</span>%<span class="number">22</span>==<span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;7 is even&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;7 is odd&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if后可以加上短声明和判断</span></span><br><span class="line"><span class="keyword">if</span> num := <span class="number">9</span>; num &lt; <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(num, <span class="string">&quot;is negative&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> num &lt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(num, has <span class="number">1</span> digit)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(num, <span class="string">&quot;has multiple digits&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4循环"><a class="markdownIt-Anchor" href="#4循环"></a> 4.循环</h3><p>go语言中没有while循环、do while循环，只有唯一的一种for循环。</p><p>最简单的for循环就是只有for没有循环条件，代表死循环。</p><p>循环中途可以用break跳出，也可以使用经典的循环（初值，阈值，步长），这三段中的任何一段都可以省略。</p><p>在循环里面还可以用continue直接进入下一个循环（在满足循环条件的情况下）</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无条件循环(死循环),使用break跳出循环</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;loop&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 经典循环写法</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">7</span>; j &lt; <span class="number">9</span>; j++ &#123;</span><br><span class="line">    fmt.Println(j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// continue跳过本轮循环,直接进入下一轮循环</span></span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">5</span>; n++ &#123;</span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赋值、判断、增值分开写</span></span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5switch"><a class="markdownIt-Anchor" href="#5switch"></a> 5.switch</h3><p>go语言中的switch分支结构，也类似于C/C++。同样地，go语言的switch后面不需要小括号。</p><p>但是和C/C<ins>的switch不同，在C</ins>里面，switch case后面如果不显式加break会继续执行后面的case；go语言则不需要break，如果要执行后面的case还需要显式加fallthrough关键字。</p><p>相比C/C++，go语言的switch功能更加强大，可以使用任意的变量类型，甚至可以取代任意的if else语句。不在switch后面加任何的变量，在case里面写条件分支，相比多个if else语句，代码逻辑更加清晰</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// switch</span></span><br><span class="line">a := <span class="number">2</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;one&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;two&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;three&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>,<span class="number">5</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;four or five&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6数组"><a class="markdownIt-Anchor" href="#6数组"></a> 6.数组</h3><p>数组是一个具有编号且长度固定的元素序列。</p><p>对于一个数组，可以很方便地取特定索引的值或者在特定索引存储值，但实际开发中，很少直接使用数组，因为其长度是固定的，使用更多的是切片。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组声明,未初始化默认值为0(对于int类型数组)</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line"><span class="comment">// 对索引为4的元素赋值</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(<span class="string">&quot;get:&quot;</span>, a[<span class="number">2</span>]) <span class="comment">//a[2]未初始化,默认是0</span></span><br><span class="line">fmt.Println(<span class="string">&quot;len:&quot;</span>, <span class="built_in">len</span>(a)) <span class="comment">//获取数组a的长度5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 短声明,直接赋值</span></span><br><span class="line">b := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组,可直接赋值,也可以用嵌套循环赋值</span></span><br><span class="line"><span class="keyword">var</span> twoD [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure><h3 id="7切片"><a class="markdownIt-Anchor" href="#7切片"></a> 7.切片</h3><p>切片slice不同于数组array，可以任意更改长度，拥有更多数组不具备的操作。可以使用make来创建切片，使用append来追加元素（注意append的用法，需要把结果返回给原数组）。</p><p>slice的原理是存储了一个长度和一个容量，以及一根指向一个数组的指针。</p><p>在执行append操作时，如果容量不够，就会扩容并返回新的slice。</p><p>slice拥有类似python的切片操作，但不支持负数索引。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 短声明一个string类型的切片,初始化长度为3,容量默认和长度相等</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">3</span>)</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&quot;a&quot;</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="comment">// append追加元素,需要把结果返回给原数组</span></span><br><span class="line"><span class="comment">// 如果容量不够的话,会进行扩容</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>)</span><br><span class="line"><span class="comment">// 复制切片</span></span><br><span class="line">c := <span class="built_in">make</span>([]<span class="type">string</span>,<span class="built_in">len</span>(s))</span><br><span class="line"><span class="built_in">copy</span>(c,s) <span class="comment">//[a b c d e f]</span></span><br><span class="line"><span class="comment">// 切片索引操作</span></span><br><span class="line">fmt.Println(s[<span class="number">2</span>:<span class="number">5</span>]) <span class="comment">// [c d e]</span></span><br><span class="line">fmt.Println(s[:<span class="number">5</span>]) <span class="comment">// [a b c d e]</span></span><br><span class="line">fmt.Println(s[<span class="number">2</span>:]) <span class="comment">// [c d e f]</span></span><br><span class="line"><span class="comment">// 其他初始化方式</span></span><br><span class="line">str := []<span class="type">string</span>&#123;<span class="string">&quot;s&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;r&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="8map"><a class="markdownIt-Anchor" href="#8map"></a> 8.map</h3><p>map在其他语言里又可能被称为哈希或者字典，是实际开发中使用最频繁的数据结构。</p><p>map也可以使用make来创建，创建时需要提供两个类型，key的类型和value的类型。</p><p>map可以存储键值对形式的数据，可以通过delete删除键值对。</p><p>go语言的map是完全无序的，遍历的时候是随机顺序。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 短声明一个key为string类型,value为int类型的map</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">m[<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br><span class="line"><span class="comment">// 删除键值对</span></span><br><span class="line"><span class="built_in">delete</span>(m,<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment">// 其他初始化方式</span></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> m3 = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="9range"><a class="markdownIt-Anchor" href="#9range"></a> 9.range</h3><p>range能够用于快速遍历slice和map，并且代码简洁。</p><p>range遍历数组时会返回两个字，第一个是索引，第二个是对应的值。如果不需要索引可以用下划线来忽略。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">2</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;index:&quot;</span>, i, <span class="string">&quot;num:&quot;</span>, num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;B&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10函数"><a class="markdownIt-Anchor" href="#10函数"></a> 10.函数</h3><p>go语言其他语言不同的是，go语言中函数的变量类型是后置的，且go函数原生支持多个返回值。实际开发中，几乎所有的函数都返回两个值，第一个是真正的返回结果，第二个是错误信息。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断map的值是否存在,返回值和错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exists</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, k <span class="type">string</span>)</span></span> (v <span class="type">string</span>, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    v, ok = m[k]</span><br><span class="line">    <span class="keyword">return</span> v, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11指针"><a class="markdownIt-Anchor" href="#11指针"></a> 11.指针</h3><p>go语言也支持指针，但指针操作相对于C/C++的指针比较局限。指针主要的用途就是对传入参数进行修改。</p><p>使用指针传参和不使用指针传参，主要区别就是有无拷贝的所带来开销以及能否直接修改数据。对于大型结构体来说，开销更大。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span> <span class="params">(n *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *n += <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := <span class="number">5</span></span><br><span class="line">    add(&amp;n)</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12结构体"><a class="markdownIt-Anchor" href="#12结构体"></a> 12.结构体</h3><p>结构体是带类型的字段的集合。可以用结构体的名称作为结构体类型去初始化一个结构体变量，构造的时候需要传入每个字段的初始值。也可以用这种键值对的方式只对一部分字段进行初始化。</p><p>结构体也支持指针，并且使用指针修改结构体能避免结构体的拷贝开销。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name    <span class="type">string</span></span><br><span class="line">    passwd  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化结构体的几种方式</span></span><br><span class="line">    a := user&#123;name: <span class="string">&quot;a&quot;</span>, passwd: <span class="string">&quot;123&quot;</span>&#125;</span><br><span class="line">    b := user&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;123&quot;</span>&#125;</span><br><span class="line">    c := user&#123;name: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">    c.passwd = <span class="string">&quot;123&quot;</span></span><br><span class="line">    <span class="keyword">var</span> d user</span><br><span class="line">    d.name = <span class="string">&quot;a&quot;</span></span><br><span class="line">    d.passwd = <span class="string">&quot;123&quot;</span></span><br><span class="line">    fmt.Println(check(&amp;a, <span class="string">&quot;456&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(u *user, passwd <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> u.passwd == passwd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13结构体方法"><a class="markdownIt-Anchor" href="#13结构体方法"></a> 13.结构体方法</h3><p>结构体方法类似于其他语言中的类成员函数。结构体方法可以选择带指针或不带指针，带指针的话，就是能够去修改结构体，不带指针的话，就是只能获取结构体数据不能修改数据。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对照上面12的user结构体和check函数</span></span><br><span class="line"><span class="comment">// 结构体方法不同于函数,在一开始就指明了结构体类型</span></span><br><span class="line"><span class="comment">// 不需要改动数据时,不带指针操作即可</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span></span> checkPasswd(passwd <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> u.passwd == passwd</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要改动数据时,带指针操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span></span> reset(passwd <span class="type">string</span>) &#123;</span><br><span class="line">    u.passwd = passwd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14错误处理"><a class="markdownIt-Anchor" href="#14错误处理"></a> 14.错误处理</h3><p>错误处理在go语言中的语言习惯做法就是使用一个单独的返回值来传递错误信息。</p><p>不同于Java的异常处理，go语言的处理方式能够很清晰地知道哪个函数返回了错误，并且能用简单的if else来处理错误。</p><p>在函数的返回值类型里面加上error，就代表这个函数可能返回错误。在函数实现的时候，如果出错的话，就可以返回一个nil和error，如果没有出错，就返回原本的结果和nil。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以12的user结构体为例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUser</span><span class="params">(users []user, name <span class="type">string</span>)</span></span> (v *user, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> _, u := <span class="keyword">range</span> users &#123;</span><br><span class="line">        <span class="keyword">if</span> u.name == name  &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;u, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;not found&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15字符串操作"><a class="markdownIt-Anchor" href="#15字符串操作"></a> 15.字符串操作</h3><p>在标准库strings包里面有很多常用的字符串工具函数。</p><ul><li>contains：判断一个字符串里面是否包含另一个字符串</li><li>count：统计字符串中某个字符或字符子串出现的次数</li><li>index：查找某个字符串第一次出现的位置</li><li>join：连接多个字符串，将两个字符串用字符连接起来</li><li>repeat：重复多个字符串</li><li>replace：替换字符串</li></ul><h3 id="16字符串格式化"><a class="markdownIt-Anchor" href="#16字符串格式化"></a> 16.字符串格式化</h3><p>在标准库的fmt包里面有很多字符串格式相关的方法。</p><p>go语言的printf类似C语言的printf，不同的是，在go语言中，可以用%v占位符来打印任意类型的变量，而不需要区分数字、字符串，可以用%+v打印详细结果，也可以用%#v打印得更详细。</p><h3 id="17json处理"><a class="markdownIt-Anchor" href="#17json处理"></a> 17.JSON处理</h3><p>go语言的JSON操作非常简单，对于一个结构体，只要保证每个字段的首字母大写（公开字段，相当于Java中的public），那么这个结构体就能用JSON.marshal序列化成JSON字符串。</p><p>序列化之后的字符串也可以用JSON.unmarshal反序列化到一个空变量中。</p><p>默认序列化的字符串风格是大写字母开头，不是下划线，可以用json tag等语法来修改输出结果的字段名。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> userInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name   <span class="type">string</span></span><br><span class="line">    Age    <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">    Hobby  []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := userInfo&#123;Name: <span class="string">&quot;a&quot;</span>, Age: <span class="number">11</span>, Hobby: []<span class="type">string</span>&#123;<span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Typescript&quot;</span>&#125;&#125;</span><br><span class="line">    buf, err := json.Marshal(a) <span class="comment">// 序列化</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="type">string</span>(buf))</span><br><span class="line">    </span><br><span class="line">    buf, err = json.MarshalIndent(a, <span class="string">&quot;&quot;</span>, <span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="type">string</span>(buf))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b userInfo</span><br><span class="line">    err = json.Unmarshal(buf, &amp;b) <span class="comment">// 反序列化到空变量中</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18时间处理"><a class="markdownIt-Anchor" href="#18时间处理"></a> 18.时间处理</h3><p>go语言时间处理最常用的就是用time.now()来获取当前时间，也可以用time.date去构造一个带时区的时间。</p><p>使用sub对两个时间进行减法得到时间差，可以查看它们具体相差多少小时、多少分钟、多少秒。</p><p>在系统交互时，经常会使用到时间戳，可以使用UNIX方法生成时间戳。</p><p>需要注意的是使用format或者parse来处理时间时，都需要使用<code>2006-01-02 15:04:05</code>这个固定参数才能得到正确的时间。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    now := time.Now()</span><br><span class="line">    t := time.Date(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">    t2 := time.Date(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">13</span>, <span class="number">45</span>, <span class="number">30</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">    fmt.Println(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute())</span><br><span class="line">    fmt.Println(t.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">    diff := t2.Sub(t)</span><br><span class="line">    fmt.Println(diff)</span><br><span class="line">    fmt.Println(diff.Minutes(), diff.Seconds())</span><br><span class="line">    t3, err := time.Parse(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2023-01-20 12:30:30&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(now.Unix())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19数字解析"><a class="markdownIt-Anchor" href="#19数字解析"></a> 19.数字解析</h3><p>在go语言中可以通过strconv这个包来进行字符串和数字类型之间的转换。</p><p>可以使用parseInt或parseFloat来解析一个数字字符串，使用atoi将一个十进制字符串转换为数字，使用itoa将数字转换为字符串。如果转换的数据不合法就会返回error。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, _ := strconv.ParseFloat(<span class="string">&quot;1.234&quot;</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(f)</span><br><span class="line">    </span><br><span class="line">    n, _ := strconv.ParseInt(<span class="string">&quot;111&quot;</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    </span><br><span class="line">    n, _ = strconv.ParseInt(<span class="string">&quot;0x1000&quot;</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    </span><br><span class="line">    n2, _ := strconv.Atoi(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">    fmt.Println(n2)</span><br><span class="line">    </span><br><span class="line">    n2, err := strconv.Atoi(<span class="string">&quot;AAA&quot;</span>)</span><br><span class="line">    fmt.Println(n2, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20进程信息"><a class="markdownIt-Anchor" href="#20进程信息"></a> 20.进程信息</h3><p>在go语言中能够通过os.args来获取程序执行时指定的命令行参数。可以用os.getenv获取环境变量。exec.command用于执行系统的命令。</p><p>以下部分代码在windows系统下可能会报错，需要在linux系统运行才能获取正确信息。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(os.Args)</span><br><span class="line">    fmt.Println(os.Getenv(<span class="string">&quot;PATH&quot;</span>))</span><br><span class="line">    fmt.Println(os.Setenv(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    buf, err := exec.Command(<span class="string">&quot;grep&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;/etc/hosts&quot;</span>).CombineOutput()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="type">string</span>(buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用go run加参数运行，例如<code>go run main.go a b c d</code></p><h2 id="31-猜谜游戏"><a class="markdownIt-Anchor" href="#31-猜谜游戏"></a> 3.1 猜谜游戏</h2><h3 id="1生成随机数"><a class="markdownIt-Anchor" href="#1生成随机数"></a> 1.生成随机数</h3><p>需要math/rand包用于生成随机数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">maxNum := <span class="number">100</span> <span class="comment">//最大范围</span></span><br><span class="line">random := rand.Intn(maxNum) <span class="comment">//生成0-100之间的随机整数</span></span><br></pre></td></tr></table></figure><p>注意到以上代码多次生成的数都是同一个数。查看这个包的官方文档可得知使用之前需要设置随机数种子用于生成随机数序列，否则每次生成的随机数序列都是相同的。习惯上用时间戳来初始化随机数种子。</p><p>在生成随机数之前用时间戳初始化随机数种子即可</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rand.Seed(time.Now().UnixNano())</span><br></pre></td></tr></table></figure><h3 id="2读取用户输入"><a class="markdownIt-Anchor" href="#2读取用户输入"></a> 2.读取用户输入</h3><p>每个程序执行时都会打开几个文件，stdin、stdou、stderr等。stdin可通过os.Stdin获取，但直接操作文件很不方便。</p><p>go语言中的bufio包提供了读取用户输入的方法，newReader方法能够将一个文件转换成一个reader变量，reader变量上拥有很多流的操作。使用ReadString方法读取一行，返回结果中包含结尾的换行符。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line">input, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">//读取</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;An error occured while reading input. Please try again&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 去掉换行符</span></span><br><span class="line">input = strings.Trim(input, <span class="string">&quot;\n&quot;</span>) <span class="comment">//这里根据不同的操作系统可能需要换成\r\n或其他参数</span></span><br><span class="line"><span class="comment">// 转换为数字</span></span><br><span class="line">guess, err := strconv.Atoi(input)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Invalid input. Please enter an integer value&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3实现判断逻辑"><a class="markdownIt-Anchor" href="#3实现判断逻辑"></a> 3.实现判断逻辑</h3><p>正常情况下，只有三种结果，过大、过小以及相等。使用简单的if else即可。</p><h3 id="4实现游戏循环"><a class="markdownIt-Anchor" href="#4实现游戏循环"></a> 4.实现游戏循环</h3><p>由于无法确定固定的循环次数，使用for循环配合continue和break，在读取和转换字符串失败用continue继续循环，在猜中数字时用break退出循环即可。</p><h2 id="32-在线词典"><a class="markdownIt-Anchor" href="#32-在线词典"></a> 3.2 在线词典</h2><p>通过调用第三方API查询单词的翻译并打印出来。</p><p>学会如何使用go语言来发送HTTP请求，解析json数据以及学习如何使用代码生成来提高开发效率。</p><h3 id="1抓包"><a class="markdownIt-Anchor" href="#1抓包"></a> 1.抓包</h3><p>以彩云APIhttps://fanyi.caiyunapp.com/为例，在在线翻译页面打开浏览器的开发者工具。</p><p>使用一次翻译，同时捕获查询单词的post请求，在预览里面找到具体的查询结果。</p><h3 id="2代码生成"><a class="markdownIt-Anchor" href="#2代码生成"></a> 2.代码生成</h3><p>在go语言里构造一个请求用于请求API，由于请求比较复杂，用代码构造麻烦。可以直接在浏览器中复制为cURL（bash）在linux终端或复制为powershell在windows的powershell下测试，成功的话就会返回一大堆json字符串。</p><p>在一个在线代码生成网站<a href="https://curlconverter.com/go/">Convert curl to Go</a>里粘贴cURL，就可以看到生成的go语言代码。直接将代码粘贴到编辑器里即可。</p><p><strong>部分代码解读</strong></p><p>创建HTTP client，可以指定很多参数进行创建，如请求超时时间以及是否使用cookie等。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">client := &amp;http.Client&#123;&#125;</span><br></pre></td></tr></table></figure><p>创建请求，使用http包中的NewRequest方法创建一个post请求，第一个参数指定请求类型，第二个参数指定URL，第三个参数指定请求体。其中请求体可能很大，为了支持流式发送，使用strings.NewReader将字符串转换为一个只读流存放在data变量中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">req, err := http.NewRequest(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;https://api.interpreter.caiyunai.com/v1/dict&quot;</span>, data)</span><br></pre></td></tr></table></figure><p>设置请求头，往往需要设置很多个参数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">req.Header.Set(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>) <span class="comment">//填写请求体的各种参数</span></span><br></pre></td></tr></table></figure><p>发起请求，使用HTTP client发起请求，获取结果。如果请求失败便会打印错误信息并退出进程。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resp, err := client.Do(req)</span><br></pre></td></tr></table></figure><p>读取响应，body同样是一个流，为了避免资源泄露，需要使用defer来手动关闭流，defer会在函数运行结束后执行。使用ioutil.ReadAll读取流，获取整个body的信息。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">bodyText, err := ioutil.ReadAll(resp.Body)</span><br></pre></td></tr></table></figure><p>目前已经能够成功发送请求，但是上面生成的代码是固定输入的。需要使用JSON序列化来实现手动输入请求参数。</p><h3 id="3生成request-body"><a class="markdownIt-Anchor" href="#3生成request-body"></a> 3.生成request body</h3><p>在go语言中，要生成一段JSON，常用的方式就是先构造一个对应json结构的结构体。注意结构体字段首字母一定要大写，否则无法访问该字段。</p><p>结构体中的字段对应了请求负载中的字段</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DictRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    TransType <span class="type">string</span> <span class="string">`json:&quot;trans_type&quot;`</span></span><br><span class="line">    Source    <span class="type">string</span> <span class="string">`json:&quot;source&quot;`</span></span><br><span class="line">    UserID    <span class="type">string</span> <span class="string">`json:&quot;user_id&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>json反序列化为字节数组，使用byte.NewReader来构造request body</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    request := DictRequest&#123;TransType: <span class="string">&quot;en2zh&quot;</span>, Source: <span class="string">&quot;good&quot;</span>&#125;</span><br><span class="line">    buf, err := json.Marshal(request)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> data = bytes.NewReader(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以此实现通过一个变量来发送HTTP请求。</p><h3 id="4解析response-body"><a class="markdownIt-Anchor" href="#4解析response-body"></a> 4.解析response body</h3><p>在js/python这些脚本语言中，body是一个字典或者map的结构，可以直接取值。但go语言是一个强类型语言，不适合这种直接取值的做法。常用的方式就是通过结构体，将json反序列化到结构体中。但是API返回的结构也比较复杂，可以借助代码生成工具<a href="https://oktools.net/json2go">JSON转Golang Struct - 在线工具 - OKTools</a>用于快速生成对应的代码，将响应的json数据通过代码生成工具生成对应的结构体。如果不需要对返回结果进行精细处理，转换为嵌套结构体即可。</p><p>得到response结构体后，使用json.Unmarshal把body反序列化到结构体中，再打印出来。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dictResponse DictResponse <span class="comment">//DictResponse是生成的结构体的名称</span></span><br><span class="line">err = json.Unmarshal(bodyText, &amp;dictResponse) <span class="comment">//bodyText存储了body原始信息,反序列化到空变量中</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, dictResponse)</span><br></pre></td></tr></table></figure><p>之后就是打印特定字段的信息。</p><h3 id="5打印结果"><a class="markdownIt-Anchor" href="#5打印结果"></a> 5.打印结果</h3><p>在以上的API响应例子中，需要用到的信息是在<code>Dictionary.explanations</code>里面。</p><p>可以使用for range迭代并打印信息</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> dictResponse.Dictionary.Explanations &#123;</span><br><span class="line">    fmt.Println(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6完善代码"><a class="markdownIt-Anchor" href="#6完善代码"></a> 6.完善代码</h3><p>将代码主体改造成一个query函数，把需要查询的单词作为参数传递。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">`usage: simpleDict WORD</span></span><br><span class="line"><span class="string">        example: simpleDict hello`</span>)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    word := os.Args[<span class="number">1</span>]</span><br><span class="line">    query(word)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过命令行输入参数运行，使用<code>go run main.go</code>接需要查询的单词即可。</p><h2 id="33-socks5代理"><a class="markdownIt-Anchor" href="#33-socks5代理"></a> 3.3 SOCKS5代理</h2><p>编写一个socks5代理服务器。socks5协议都是明文传输，这个协议历史久远，诞生于互联网早期。它的用途就是在防火墙保证数据安全性时提供socks5协议的端口给授权的用户以便访问内部资源。</p><h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3><p>正常浏览器访问一个网站，如果不经过代理服务器，就是先和目标网站的服务器建立TCP连接，完成三次握手后发起HTTP请求，然后服务器返回HTTP响应。</p><p>如果设置了代理服务器，那么流程会变得复杂一些。首先是浏览器和sock5代理建立TCP连接，代理再和真正的服务器建立TCP连接。可以分成四个阶段，握手阶段、认证阶段、请求阶段、relay阶段。</p><p>第一个握手阶段，浏览器会向socks5代理发送请求，数据包的内容包括一个协议的版本号、支持认证的种类，socks5服务器会选择一个认证方式，返回给浏览器。如果返回的是00则代表不需要认证，返回其他结果则开始认证流程。</p><p>第二个认证阶段参考https://wiyi.org/socks5-protocol-in-deep.html</p><p>第三个请求阶段，认证通过之后浏览器会向socks5发起请求。主要信息包括版本号，请求的类型（一般是connection请求，表示代理服务器要和某个域名或者某个IP地址的某个端口建立TCP连接）。代理服务器收到响应后会真正和后端服务器建立连接，然后返回一个响应。</p><p>第四个relay阶段，此时浏览器会正常发送请求，然后代理服务器接收到请求之后直接转发给真正的服务器，真正的服务器返回的响应也经过代理服务器转发到浏览器这边。socks5代理服务器实际上并不关系流量的细节，可以是HTTP流量也可以是其他的TCP流量。</p><h3 id="1tcp-echo-server"><a class="markdownIt-Anchor" href="#1tcp-echo-server"></a> 1.TCP echo server</h3><p>在go语言中实现一个简单的TCP echo server。使用简单的逻辑，发送什么就返回什么，方便测试。</p><p>在main函数中使用net.listen监听一个端口，返回一个server。然后在一个死循环中反复accept请求，成功之后就会返回一个连接。接下来在一个process函数里处理这个连接。</p><p>process函数的实现，先添加一个defer connection.close防止资源泄露，接下来使用bufio.NewReader来创建一个带缓冲的只读流，带缓冲的流可以减少底层系统的调用次数，且具有更多的工具函数可以读取数据，可以使用readbyte来读取单个字节，再写进去连接。</p><p>main函数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    server, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:1080&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        client, err := server.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Accept failed %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> process(client) <span class="comment">//go关键字代表启动一个goroutine,这里的goroutine可暂时类比为一个子线程,但是开销比子线程小很多,能够轻松处理上万的并发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>process函数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    reader := bufio.NewReader(conn)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        b, err := reader.ReadByte()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        _, err = conn.Write([]<span class="type">byte</span>&#123;b&#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行nc命令测试服务器，nc是linux系统下的命令，windows系统需要额外安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc 127.0.0.1 1080</span><br></pre></td></tr></table></figure><p>输入什么服务器就会返回什么。</p><h3 id="2auth"><a class="markdownIt-Anchor" href="#2auth"></a> 2.auth</h3><p>认证阶段，这一部分会比较复杂。实现一个空的auth函数，在process函数里调用。</p><p>认证阶段的逻辑，第一步，浏览器会向代理服务器发送一个包。这个包有三个字段</p><p>第一个字段version，协议版本号，固定是5。</p><p>第二个字段methods，认证的方法数目。</p><p>第三个字段，每个method的编码，0表示不需要认证，2表示用户名密码认证。</p><p>使用readbyte读取版本号，不是socks5直接返回报错，再读取method size（同样是一个字节）。创建一个相应长度的slice，用io.ReadFull填充信息。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> socks5Ver = <span class="number">0x05</span> <span class="comment">//socks5的版本号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">auth</span><span class="params">(reader *bufio.Reader, conn net.Conn)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">    ver, err := reader.ReadByte()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read ver failed:%w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ver != socks5Ver &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;not supported ver:%v&quot;</span>, ver)</span><br><span class="line">    &#125;</span><br><span class="line">    methodSize, err := reader.ReadByte()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read methodSize failed:%w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    method := <span class="built_in">make</span>([]<span class="type">byte</span>, methodSize)</span><br><span class="line">    _, err = io.ReadFull(reader, method)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read method failed:%w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">&quot;ver&quot;</span>, ver, <span class="string">&quot;method&quot;</span>, method)</span><br><span class="line">    _, err = conn.Write([]<span class="type">byte</span>&#123;socks5Ver, <span class="number">0x00</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;write failed:%w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，代理服务器还需要返回一个response，返回包有两个字段，一个是version，一个是method，也就是鉴传方式。当前只考虑实现不需要鉴传的方式，即00。可以使用curl命令测试效果。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --socks5 127.0.0.1:1080 -v http://www.baidu.com</span><br></pre></td></tr></table></figure><p>curl命令还不能成功，因为协议还没有完善。查看日志，version和method可以正常打印，说明目前协议实现正确。</p><h3 id="3请求阶段"><a class="markdownIt-Anchor" href="#3请求阶段"></a> 3.请求阶段</h3><p>请求阶段，读取携带URL或者IP地址+端口的包。实现一个和auth函数类似的connect函数，同样在process中调用。</p><p>请求阶段的逻辑，浏览器会发送一个包，包里有如下6个字段</p><p>version版本号，是5。command请求类型，这边只支持connection请求，也就是让代理服务器建立新的TCP连接。RSV保留字段，不需要理会。atype目标地址类型，可能是IPv4 IPv6或者域名。addr地址，这个地址的长度受atype的类型的影响会有不同。port端口号，两个字节，需要逐个读取。</p><p>前四个字段共四个字节，可以一次性读取，定义一个长度为4的buffer。读取完后，第0个就是version，判断是否为socks5，第1个就是cmd，判断是否为1（1表示connection请求），第3个就是atype，如果是IPv4，则再次读取到buffer，将buffer的字节逐个以IP地址的格式保存到addr变量中。如果是host，需要先读取长度，再创建一个相应长度的buf进行填充，转换成字符串保存到addr变量。IPv6目前不考虑支持。</p><p>最后的port有两个字节，读取后按协议规定的大端字节序转换成数字。前面的buffer不会再被其他变量使用，可以直接复用内存，创建一个临时slice，长度为2。接下来把IP地址和端口号打印出来。</p><p>收到浏览器的请求包之后，需要返回一个包。这个包里有很多字段，但大部分不会使用。</p><p>第一个是版本号socks5，第二个是返回类型，成功的话就返回0，第三个是保留字段，填0即可，第四个字段是atype地址类型，填1。第五、六个字段暂时用不到，都填0。一共是4+4+2个字节。</p><p>编写完connect函数后，使用curl重新测试，看到IP地址和端口信息被打印出来，说明当前协议实现正确。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --socks5 127.0.0.1:1080 -v http://www.baidu.com</span><br></pre></td></tr></table></figure><p>最后一步就是和端口建立连接，实现双向转发数据。</p><h3 id="4relay阶段"><a class="markdownIt-Anchor" href="#4relay阶段"></a> 4.relay阶段</h3><p>直接使用net.dial建立一个TCP连接。建立连接之后，不要忘记使用defer来关闭连接。</p><p>实现浏览器和下游服务器的双向数据转发。标准库的io.copy可以实现一个单向数据转发，那么可以使用两个goroutine实现双向转发。</p><p>此时存在一个问题，connect函数会立即返回并关闭连接，需要等待任意一个方向copy出错后再返回connect函数。可以使用标准库的context机制，用contextWithCancel来创建一个context，在最后等待ctx.Done，只要cancel被调用，ctx.Done就会立即返回，然后在两个goroutine里各调用一次cancal即可。</p><p>在connect函数中添加</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dest, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;%v:%v&quot;</span>, addr, port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Errorf(<span class="string">&quot;dial dst failed:%w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> dest.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在写入数据完成之后</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Backgrond())</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _, _ = io.Copy(dest, reader)</span><br><span class="line">    cancel()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _, _ = io.Copy(conn, dest)</span><br><span class="line">    cancel()</span><br><span class="line">&#125;()</span><br><span class="line">&lt;-ctx.Done()</span><br></pre></td></tr></table></figure><p>执行curl测试，返回成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --socks5 127.0.0.1:1080 -v http://www.baidu.com</span><br></pre></td></tr></table></figure><p>还可以在浏览器中测试代理，需要安装switchyomega插件。新建情景模式，代理服务器socks5，端口1080，保存并启用。访问网站，可以在代理服务器这边看到浏览器版本的域名和端口。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://github.com/wangkechun/go-by-example/">源代码</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文已收录到&lt;a href=&quot;https://juejin.cn/post/7192662401240531004&quot;&gt;golang基础学习 | 青训营笔记 - 掘金 (juejin.cn)&lt;/a&gt;，主要记录了对golang的初步学习</summary>
    
    
    
    <category term="golang" scheme="https://s-chance.github.io/categories/golang/"/>
    
    
    <category term="学习笔记" scheme="https://s-chance.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="青训营" scheme="https://s-chance.github.io/tags/%E9%9D%92%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>关于个人Hexo博客的搭建历史</title>
    <link href="https://s-chance.github.io/2023/01/17/blog-by-https/"/>
    <id>https://s-chance.github.io/2023/01/17/blog-by-https/</id>
    <published>2023-01-17T06:06:17.000Z</published>
    <updated>2023-01-18T06:32:47.351Z</updated>
    
    <content type="html"><![CDATA[<p>仅以此文回顾过去搭建Hexo博客的历程<span id="more"></span></p><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>在早期笔者一直是通过github pages服务来运行博客网站，从而省略了对<strong>域名解析</strong>、<strong>nginx反向代理</strong>以及<strong>SSL证书的申请与HTTPS服务的开启</strong>这些配置</p><p>于是后期，笔者租赁了一台纯净Ubutun20.04LTS系统的轻量应用服务器，从零开始基于命令行配置hexo博客以及HTTPS服务的开启</p><h2 id="hexo博客的搭建"><a class="markdownIt-Anchor" href="#hexo博客的搭建"></a> Hexo博客的搭建</h2><h3 id="本地环境搭建"><a class="markdownIt-Anchor" href="#本地环境搭建"></a> 本地环境搭建</h3><h4 id="git环境"><a class="markdownIt-Anchor" href="#git环境"></a> Git环境</h4><ol><li><p>访问git官网<a href="https://git-scm.com/download">Git - Downloads (git-scm.com)</a>或寻找镜像站<a href="https://mirrors.tuna.tsinghua.edu.cn/github-release/git-for-windows/git/">清华大学开源软件镜像站 | git for windows</a>下载对应系统的版本</p></li><li><p>安装Git，除了安装路径可选择C盘或D盘，其它均可直接下一步</p></li><li><p>配置环境变量，在系统环境变量的<strong>Path变量下</strong>增加变量值</p><p>参考变量值：D:\Program Files\Git\cmd</p></li><li><p>win+r输入powershell打开查看git版本信息</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git <span class="literal">-v</span></span><br></pre></td></tr></table></figure><p>显示出了版本号，则说明git配置完成</p></li></ol><h4 id="nodejs环境"><a class="markdownIt-Anchor" href="#nodejs环境"></a> Nodejs环境</h4><ol><li><p>访问nodejs官网<a href="https://nodejs.org/en/download/">Download | Node.js (nodejs.org)</a>下载对应系统的nodejs版本。（linux系统可直接使用命令行下载而不需要手动配置，使用其它方式则需要手动添加环境变量或者软链接）</p></li><li><p>windows下载完nodejs后需要配置环境变量（注意不要使用中文路径和带有空格的路径，默认路径中的<code>Program Files</code>中的空格会导致命令无法识别）</p><p>windows参考配置</p><ol><li><p>执行下载的nodejs的msi文件，选择安装路径<code>D:\nodejs</code></p></li><li><p>配置<strong>系统环境变量</strong>，在<strong>Path变量</strong>下添加 D:\nodejs\ （这一步nodejs可能会自动配置好）</p></li><li><p>应用配置，保存关闭。win+r输入powershell打开命令提示符，输入</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看nodejs版本</span></span><br><span class="line">node <span class="literal">-v</span></span><br><span class="line"><span class="comment"># 查看包管理器npm的版本(npm是nodejs默认安装的包管理器)</span></span><br><span class="line">npm <span class="literal">-v</span></span><br></pre></td></tr></table></figure><p>以上命令检测到两个版本号后说明配置完成</p></li><li><p>完成以上步骤后基本就能够使用nodejs来搭建hexo。后续为<strong>非必须步骤</strong>，如果使用过程中存在一些问题可参考以下步骤解决</p></li><li><p>如果npm下载失败或下载速度缓慢，可能是由于默认服务器在海外的缘故，可指定国内镜像源下载或配置npm的国内镜像源</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定镜像源下载,下载时加上--registry的参数,每次下载需要指定</span></span><br><span class="line">npm install <span class="literal">-g</span> 包名 <span class="literal">--registry</span>=https://registry.npm.taobao.org</span><br><span class="line"><span class="comment"># 设置镜像源,将npm的默认源更换为镜像源</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line"><span class="comment"># 检测镜像站是否可用</span></span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure></li><li><p>按以上步骤nodejs安装在了D盘，但下载的包仍在C盘，这里的配置是将包从C盘迁移到D盘以减少C盘的占用</p><p>在nodejs的根目录下，创建两个文件夹命名为node_global和node_cache，在文件夹的属性——安全里更改所有组或用户的权限为完全控制（防止权限不足而无法下载的问题）</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置全局安装路径(路径根据实际情况填写)</span></span><br><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">&quot;D:\nodejs\node_global&quot;</span></span><br><span class="line"><span class="comment"># 设置全局缓存路径(路径根据实际情况填写)</span></span><br><span class="line">npm config <span class="built_in">set</span> cache <span class="string">&quot;D:\nodejs\node_cache&quot;</span></span><br><span class="line"><span class="comment"># 以上命令会在C盘用户文件夹下产生一个.npmrc配置文件由于保存上面的配置信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加系统环境变量,在Path变量下新增变量值,变量值就是全局安装路径,否则新安装的命令工具无法执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测全局安装路径</span></span><br><span class="line">npm root <span class="literal">-g</span></span><br><span class="line"><span class="comment"># 查看配置信息</span></span><br><span class="line">npm config list</span><br></pre></td></tr></table></figure><p>以上配置完成后，之后下载的包都会放到<strong>node_global/node_modules</strong>下</p></li></ol></li><li><p>nodejs环境搭建完成</p></li></ol><h4 id="hexo环境"><a class="markdownIt-Anchor" href="#hexo环境"></a> Hexo环境</h4><ol><li><p>在完成了搭建git和nodejs的环境的基础上，就能够快速使用Hexo</p></li><li><p>在powershell中执行以下命令</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局安装Hexo命令行工具</span></span><br><span class="line">npm install <span class="literal">-g</span> hexo<span class="literal">-cli</span></span><br><span class="line"><span class="comment"># 查看Hexo版本信息</span></span><br><span class="line">hexo version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个合适的文件夹作为Hexo框架的存放目录(这里假设使用一个demo的空文件夹)</span></span><br><span class="line"><span class="comment"># 执行以下3条命令就搭建好了基本的框架</span></span><br><span class="line">hexo init demo</span><br><span class="line"><span class="built_in">cd</span> demo</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在本地运行Hexo</span></span><br><span class="line">hexo server <span class="comment"># 或简写为hexo s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些常用的Hexo命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一篇文章(文章内包含了Hexo的一些格式信息)</span></span><br><span class="line">hexo new <span class="string">&quot;first blog&quot;</span> <span class="comment"># 会在_posts目录下生成一个markdown初始文件,标题为first blog</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一篇草稿(草稿不会在网站上展示)</span></span><br><span class="line">hexo new draft <span class="string">&quot;my draft&quot;</span> <span class="comment"># 会在_drafts目录下生成相应的初始文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建导航页(导航页主要是展示文章分类、标签、作者简介、友情链接等信息)</span></span><br><span class="line">hexo new page <span class="literal">--path</span> about/me <span class="string">&quot;About me&quot;</span> <span class="comment"># 个人简介,这里是固定写法。默认情况下还需要修改配置文件才能生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态文件(一般是在新建文章并完成写作后使用或者在修改了文章的内容后使用)</span></span><br><span class="line">hexo generate <span class="comment"># 可简写为hexo g</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务器(用于预览网页效果)</span></span><br><span class="line">hexo server <span class="comment"># 可简写为hexo s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署网站(需要配置远程服务器地址,部署之前需要先生成静态文件)</span></span><br><span class="line">hexo deploy <span class="comment"># 可简写为hexo d</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除缓存文件(一般是更换Hexo主题未生效时使用)</span></span><br><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>更详细的介绍请移步官网<a href="https://hexo.io/zh-cn/">Hexo</a></p></li></ol><h3 id="远程环境搭建"><a class="markdownIt-Anchor" href="#远程环境搭建"></a> 远程环境搭建</h3><h4 id="创建git仓库"><a class="markdownIt-Anchor" href="#创建git仓库"></a> 创建Git仓库</h4><p>先安装openssh，之后就可以通过ssh客户端远程连接服务器而不需要在浏览器上操作</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装SSH服务端</span></span><br><span class="line">sudo apt install openssh-server</span><br><span class="line"><span class="comment"># 查看SSH服务是否启动</span></span><br><span class="line">ps -e | grep ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个blog用户管理Hexo(默认的root用户权限过高,容易影响到系统)</span></span><br><span class="line">adduser blog</span><br><span class="line"><span class="comment"># 给予blog用户权限</span></span><br><span class="line">vim /etc/sudoers</span><br><span class="line"><span class="comment"># 找到User privilege specification这一段,在下面添加以下内容</span></span><br><span class="line">blog    ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到blog用户(密码可在网页服务器控制台那边重置密码获得)</span></span><br><span class="line">su blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装git</span></span><br><span class="line">sudo apt install git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入根目录,在/var/repo目录下创建一个名为hexo_static的裸仓库</span></span><br><span class="line"><span class="built_in">cd</span> /</span><br><span class="line">sudo <span class="built_in">mkdir</span> /var/repo/</span><br><span class="line">sudo <span class="built_in">chown</span> -R <span class="variable">$USER</span>:<span class="variable">$USER</span> /var/repo/</span><br><span class="line">sudo <span class="built_in">chmod</span> -R 755 /var/repo/</span><br><span class="line"><span class="built_in">cd</span> /var/repo/</span><br><span class="line"><span class="comment"># 创建裸仓库</span></span><br><span class="line">git init --bare hexo_static.git</span><br><span class="line"><span class="comment"># 裸仓库不同于普通仓库,裸仓库是专门的共享仓库,不会存储文件,只保存历史提交的版本信息</span></span><br><span class="line"><span class="comment"># 实际上裸仓库就相当于普通仓库中隐藏的.git文件夹</span></span><br></pre></td></tr></table></figure><h4 id="配置nginx反向代理"><a class="markdownIt-Anchor" href="#配置nginx反向代理"></a> 配置Nginx反向代理</h4><h5 id="安装nginx及可能遇到的问题"><a class="markdownIt-Anchor" href="#安装nginx及可能遇到的问题"></a> 安装Nginx及可能遇到的问题</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装nginx</span></span><br><span class="line">sudo apt install nginx</span><br><span class="line"><span class="comment"># 查看版本信息,注意大小写</span></span><br><span class="line">nginx -V</span><br><span class="line"><span class="comment"># 注意这一步如果没有看到with-http_ssl_module字样的参数信息(如果有就跳过后续步骤),则需要从源码编译安装(已经安装了也没有关系,停止服务后替换配置文件即可)</span></span><br><span class="line"><span class="comment"># 如果想卸载也可以执行以下命令</span></span><br><span class="line">sudo apt --purge autoremove nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># Nginx 官网 https://nginx.org/en/download.html</span></span><br><span class="line"><span class="comment"># /usr/local/src目录通常用于存放用户手动编译程序的源码包</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/</span><br><span class="line"><span class="comment"># 这里使用wget下载nginx的源码包</span></span><br><span class="line"><span class="comment"># 如果已经安装并配置了nginx,又不想重新配置,使用nginx -v命令查看已安装的nginx版本并替换掉以下命令中的版本号</span></span><br><span class="line">wget https://nginx.org/download/nginx-1.22.1.tar.gz</span><br><span class="line"><span class="comment"># 解压提取包并进入解压目录</span></span><br><span class="line">tar -zxvf nginx-1.22.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> nginx-1.22.1</span><br><span class="line"><span class="comment"># 查看原有的nginx安装目录</span></span><br><span class="line"><span class="built_in">which</span> nginx</span><br><span class="line"><span class="comment"># 停止nginx的运行</span></span><br><span class="line">nginx -s stop</span><br><span class="line"><span class="comment"># 查看原有nginx的配置参数,注意大小写</span></span><br><span class="line">nginx -V</span><br><span class="line"><span class="comment"># 在原有参数的基础上附加--with-http_ssl_module的参数配置SSL模块(下面只给出了一部分参数,完整参数由nginx -V显示的参数拼接SSL模块的参数而成)</span></span><br><span class="line">sudo ./configure --prefix=/usr/local/nginx --with-http_ssl_module</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这一步可能会缺少一些库,使用以下命令下载到相关库后重新编译</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺少PCRE的相关库,如果不缺这个库就跳过</span></span><br><span class="line">sudo apt install libpcre3 libpcre3-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺少zlib的库,如果不缺这个库就跳过</span></span><br><span class="line"><span class="comment"># 访问zlib官网http://zlib.net/下载zlib,这里直接用wget下载到当前的src目录</span></span><br><span class="line">wget http://zlib.net/zlib-1.2.13.tar.gz</span><br><span class="line">./configure --prefix=/usr/local/zlib</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺少openssl的相关库,如果不缺这个库就跳过</span></span><br><span class="line">sudo apt install openssl libssl-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新编译nginx</span></span><br><span class="line">sudo make</span><br><span class="line"><span class="comment"># 如果没有安装过nginx或者已经卸载了nginx则执行以下2条命令覆盖安装后即可跳过后续步骤</span></span><br><span class="line">sudo make install</span><br><span class="line"><span class="comment"># 配置软链接使得在任意目录下能通过nginx的名称直接运行nginx的命令</span></span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/local/nginx/sbin/nginx /usr/sbin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换原有nginx的文件</span></span><br><span class="line"><span class="comment"># 备份原有nginx安装目录下的文件(这里以安装文件位于/usr/sbin/目录下为例)</span></span><br><span class="line"><span class="built_in">cp</span> /usr/sbin/nginx /usr/sbin/nginx.bak</span><br><span class="line"><span class="comment"># 将编译好的nginx文件覆盖掉原有的nginx</span></span><br><span class="line"><span class="built_in">cp</span> ./objs/nginx /usr/sbin/</span><br><span class="line"><span class="comment"># 重新查看nginx参数信息</span></span><br><span class="line">nginx -V</span><br><span class="line"><span class="comment"># 看到了--with-http_ssl_module的参数,SSL模块配置完成</span></span><br></pre></td></tr></table></figure><h5 id="配置nginx托管文件目录"><a class="markdownIt-Anchor" href="#配置nginx托管文件目录"></a> 配置Nginx托管文件目录</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建/var/www/hexo目录用于存放Hexo生成的静态文件,修改目录所有权</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /var/www/hexo</span><br><span class="line">sudo <span class="built_in">chown</span> -R <span class="variable">$USER</span>:<span class="variable">$USER</span> /var/www/hexo</span><br><span class="line">sudo <span class="built_in">chmod</span> -R 755 /var/www/hexo</span><br><span class="line"><span class="comment"># 修改/etc/nginx/sites-enabled/default,使nginx的root目录指向hexo目录</span></span><br><span class="line"><span class="comment"># 在server里面添加以下配置</span></span><br><span class="line">root /var/www/hexo;</span><br><span class="line"><span class="comment"># 重启nginx服务</span></span><br><span class="line">sudo systemctl restart nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置git钩子,用于实现本地Hexo生成的静态文件推送到指定目录</span></span><br><span class="line">vim /var/repo/hexo_static.git/hooks/post-receive</span><br><span class="line"><span class="comment"># 添加以下配置内容并保存退出</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">git --work-tree=/var/www/hexo --git-dir=/var/repo/hexo_static.git checkout -f</span><br><span class="line"><span class="comment"># 给予可执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x /var/repo/hexo_static.git/hooks/post-receive</span><br></pre></td></tr></table></figure><h3 id="ssh远程连接配置"><a class="markdownIt-Anchor" href="#ssh远程连接配置"></a> SSH远程连接配置</h3><p>在windows上搭建SSH客户端</p><ol><li><p>使用powershell运行以下命令在用户文件夹的.ssh文件夹下生成密钥</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ssh<span class="literal">-keygen</span> <span class="literal">-t</span> rsa</span><br></pre></td></tr></table></figure></li><li><p>将生成的公钥id_rsa.pub中的内容拷贝到服务器的/home/blog/.ssh/authorized_keys文件上</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> .ssh</span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line">sudo <span class="built_in">touch</span> authorized_keys</span><br><span class="line">sudo vim .ssh/authorized_keys</span><br></pre></td></tr></table></figure></li></ol><h3 id="hexo部署到服务器"><a class="markdownIt-Anchor" href="#hexo部署到服务器"></a> Hexo部署到服务器</h3><ol><li><p>编辑hexo根目录中的config.yml文件，在deploy处配置参数</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="comment"># server_ip为服务器的公网ip</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">blog@server_ip:/var/repo/hexo_static.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li><li><p>执行以下命令部署Hexo</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li><li><p>查看服务器的/var/www/hexo目录，能够看到上传的静态文件</p></li><li><p>访问服务器IP地址查看页面，如果访问失败则检查服务器内部是否开放了80端口并去浏览器控制台查看服务器厂商提供的安全组规则或外部防火墙是否开放了80端口。确认都开放之后重新访问</p></li></ol><h3 id="域名解析配置"><a class="markdownIt-Anchor" href="#域名解析配置"></a> 域名解析配置</h3><p>域名的购买很简单，到这里笔者已经提前购买好了一年期域名，重点就是配置域名解析。如果租赁域名的地方和租赁服务器的地方不是同一个地方，则域名解析需要在租赁域名的地方进行配置</p><p>参考配置</p><p>主机记录一般就是填<strong>www</strong>，记录类型为A，记录值为公网IP地址，其它的参数默认即可</p><p>之后就可以通过www.域名来访问页面，如果想直接通过一级域名访问，也可以再添加一条主机记录为@，记录类型为A，记录值为公网IP地址的解析</p><h3 id="ssl证书申请"><a class="markdownIt-Anchor" href="#ssl证书申请"></a> SSL证书申请</h3><p>这里笔者找了一个能申请90天免费SSL证书的网站<a href="https://ourl.co/zerossl">https://ourl.co/zerossl</a>。具体的操作参考<a href="https://www.landiannews.com/archives/93605.html">SSL证书申请</a></p><h3 id="https服务开启"><a class="markdownIt-Anchor" href="#https服务开启"></a> HTTPS服务开启</h3><p><strong>Nginx配置SSL证书</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将下载到windows上的证书文件上传至服务器</span></span><br><span class="line"><span class="comment"># 指定一个目录用于存放证书文件(目录可自行选择,以下仅供参考)</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /ssh/cert &amp;&amp; <span class="built_in">cd</span> /ssh/cert</span><br><span class="line"><span class="comment"># 使用远程文件传输上传文件至服务器</span></span><br><span class="line"><span class="comment"># 将证书文件信息合并</span></span><br><span class="line"><span class="built_in">cat</span> ca_bundle.crt &gt;&gt; certificate.crt</span><br></pre></td></tr></table></figure><p><strong>Nginx配置参考</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name example.com;</span><br><span class="line">        rewrite ^/(.*) https://$server_name<span class="variable">$request_uri</span>? permanent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen   443   ssl;</span><br><span class="line">        ssl_certificate /ssh/cert/certificate.crt;</span><br><span class="line">        ssl_certificate_key /ssh/cert/private.key;</span><br><span class="line">        server_name example.com; <span class="comment">#填写域名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ssl验证相关配置</span></span><br><span class="line">        ssl_session_timeout  5m;    <span class="comment">#缓存有效期</span></span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    <span class="comment">#加密算法</span></span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    <span class="comment">#安全链接可选的加密协议</span></span><br><span class="line">        ssl_prefer_server_ciphers on;   <span class="comment">#使用服务器端的首选算法</span></span><br><span class="line">        </span><br><span class="line">        root /var/www/hexo; <span class="comment">#Hexo项目目录</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add index.php to the list if you are using PHP</span></span><br><span class="line">        index index.html index.htm index.nginx-debian.html;</span><br><span class="line">        location / &#123;</span><br><span class="line">                <span class="comment"># First attempt to serve request as file, then</span></span><br><span class="line">                <span class="comment"># as directory, then fall back to displaying a 404.</span></span><br><span class="line">                try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ =404;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此HTTPS服务配置完成，在访问笔者的页面时可以看到https开头的URL</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://hexo.io/zh-cn/">Hexo官网</a></p><p><a href="https://cloud.tencent.com/developer/article/1945550">Hexo部署至服务器</a></p><p><a href="https://www.landiannews.com/archives/93605.html">SSL证书申请</a></p><p><a href="https://help.zerossl.com/hc/en-us/articles/360058295894">在NGINX上安装SSL证书 - 零SSL和 (zerossl.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;仅以此文回顾过去搭建Hexo博客的历程</summary>
    
    
    
    
    <category term="生活记录" scheme="https://s-chance.github.io/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>IDEA插件配置</title>
    <link href="https://s-chance.github.io/2023/01/14/IDEA-plugins/"/>
    <id>https://s-chance.github.io/2023/01/14/IDEA-plugins/</id>
    <published>2023-01-14T10:11:56.000Z</published>
    <updated>2023-01-16T11:22:55.310Z</updated>
    
    <content type="html"><![CDATA[<p>作为IntelliJ IDEA的用户之一，原始的IDE已经能够满足大部分需求，但IDE插件提供了更多拓展性的功能，使得开发者能够工作在适宜的“开发环境”中，提高开发效率，提升开发者体验。那么以下是笔者在使用过程中所搜寻到的一些插件，请注意其中部分插件并不能直接提升开发效率，另外过多的插件反而会造成开发效率的低下，请悉知。读者可自行选择感兴趣的插件进行配置<span id="more"></span></p><h3 id="视觉体验"><a class="markdownIt-Anchor" href="#视觉体验"></a> 视觉体验</h3><h4 id="background-image-plus"><a class="markdownIt-Anchor" href="#background-image-plus"></a> Background Image Plus +</h4><p>Background Image Plus +是一款<strong>编辑器背景</strong>图插件，是Background Image Plus的功能增强版。支持<strong>每隔指定时间随机切换背景图片</strong>（需要有包含多个图片文件的背景图片文件夹，部分图片文件格式无法显示）</p><h4 id="material-theme-ui"><a class="markdownIt-Anchor" href="#material-theme-ui"></a> Material Theme UI</h4><p>Material Theme UI是一款主题美化插件</p><h4 id="rainbow-brackets"><a class="markdownIt-Anchor" href="#rainbow-brackets"></a> Rainbow Brackets</h4><p>Rainbow Brackets彩虹括号插件，对代码排错有一定帮助</p><h4 id="nyan-progress-bar"><a class="markdownIt-Anchor" href="#nyan-progress-bar"></a> Nyan Progress Bar</h4><p>Nyan Progress Bar彩虹猫进度条样式插件</p><hr /><h3 id="代码跳转与快速浏览"><a class="markdownIt-Anchor" href="#代码跳转与快速浏览"></a> 代码跳转与快速浏览</h3><h4 id="codeglance-pro"><a class="markdownIt-Anchor" href="#codeglance-pro"></a> CodeGlance Pro</h4><p>CodeGlance Pro是一款<strong>快速浏览代码</strong>的插件，是CodeGlance的最新版。提供了<strong>代码缩略图</strong>，并能对缩略图中的部分代码进行<strong>放大浏览</strong>以及<strong>快速跳转</strong>到指定的代码</p><hr /><h3 id="代码编辑"><a class="markdownIt-Anchor" href="#代码编辑"></a> 代码编辑</h3><h4 id="string-manipulation"><a class="markdownIt-Anchor" href="#string-manipulation"></a> String Manipulation</h4><p>String Manipulation用于代码大小写转换、驼峰命名转换、去除空格等</p><h4 id="ideavim"><a class="markdownIt-Anchor" href="#ideavim"></a> IdeaVim</h4><p>Ideavim是一个Vim仿真插件，用于在IDAE上实现Vim操作。（适用于习惯Vim操作的开发者，部分快捷键与IDEA自带快捷键存在冲突，需要手动配置）</p><h3 id="代码生成"><a class="markdownIt-Anchor" href="#代码生成"></a> 代码生成</h3><h4 id="easy-code"><a class="markdownIt-Anchor" href="#easy-code"></a> Easy Code</h4><p>Easy Code是一款能够根据数据表直接生成entity、controller、service、dao、mapper的代码，非常方便</p><h4 id="easy-code-mybatiscodehelperpro"><a class="markdownIt-Anchor" href="#easy-code-mybatiscodehelperpro"></a> Easy Code-MybatisCodeHelperPro</h4><p>为了与MybatisCodeHelperPro兼容而的推出的Easy Code版本</p><hr /><h3 id="代码简化"><a class="markdownIt-Anchor" href="#代码简化"></a> 代码简化</h3><h4 id="lombok"><a class="markdownIt-Anchor" href="#lombok"></a> Lombok</h4><p>Lombok能够通过注解实现实体类的方法，简化、减少代码的编写</p><hr /><h3 id="代码规范"><a class="markdownIt-Anchor" href="#代码规范"></a> 代码规范</h3><h4 id="checkstyle"><a class="markdownIt-Anchor" href="#checkstyle"></a> CheckStyle</h4><p>Java代码格式规范插件，能够自定义不同的规范</p><h4 id="alibaba-java-coding-guidelines"><a class="markdownIt-Anchor" href="#alibaba-java-coding-guidelines"></a> Alibaba Java Coding Guidelines</h4><p>Alibaba Java Coding Guidelines阿里巴巴的代码规范插件，用于开发者规范自己的代码编写，改善代码质量</p><h4 id="sonarlint"><a class="markdownIt-Anchor" href="#sonarlint"></a> SonarLint</h4><p>SonarLint是一个代码质量检测器插件，用于培养开发者良好的开发习惯以及提高代码质量</p><hr /><h3 id="git提交规范"><a class="markdownIt-Anchor" href="#git提交规范"></a> Git提交规范</h3><h4 id="git-commit-template"><a class="markdownIt-Anchor" href="#git-commit-template"></a> Git Commit Template</h4><p>Git Commit Template用于规范git提交信息</p><hr /><h3 id="代码测试"><a class="markdownIt-Anchor" href="#代码测试"></a> 代码测试</h3><h4 id="junitgenerator-v20"><a class="markdownIt-Anchor" href="#junitgenerator-v20"></a> JUnitGenerator V2.0</h4><p>JUnitGenerator V2.0用于快速生成代码测试模块</p><hr /><h3 id="项目架构分析"><a class="markdownIt-Anchor" href="#项目架构分析"></a> 项目架构分析</h3><h4 id="plantuml-integration"><a class="markdownIt-Anchor" href="#plantuml-integration"></a> PlantUML Integration</h4><p>PlantUML Integration是一款用于快速创建UML（统一建模语言）图形的插件，能够通过绘制图形来系统性地分析和设计项目</p><h4 id="sequencediagram"><a class="markdownIt-Anchor" href="#sequencediagram"></a> SequenceDiagram</h4><p>SequenceDiagram用于生成项目类调用关系与执行流程的时序图</p><hr /><h3 id="云部署"><a class="markdownIt-Anchor" href="#云部署"></a> 云部署</h3><h4 id="alibaba-cloud-toolkit"><a class="markdownIt-Anchor" href="#alibaba-cloud-toolkit"></a> Alibaba Cloud Toolkit</h4><p>Alibaba Cloud Toolkit用于高效开发并部署适合在云端运行的应用</p><hr /><h3 id="json辅助工具"><a class="markdownIt-Anchor" href="#json辅助工具"></a> Json辅助工具</h3><h4 id="json-parser"><a class="markdownIt-Anchor" href="#json-parser"></a> Json Parser</h4><p>Json Parser是一款json解析器插件，是一个用于<strong>验证和格式化JSON字符串</strong>的轻量级插件</p><h4 id="gsonformatplus"><a class="markdownIt-Anchor" href="#gsonformatplus"></a> GsonFormatPlus</h4><p>GsonFormat能够将json数据直接转换为Java的类，提高效率</p><hr /><h3 id="翻译工具"><a class="markdownIt-Anchor" href="#翻译工具"></a> 翻译工具</h3><h4 id="translation"><a class="markdownIt-Anchor" href="#translation"></a> Translation</h4><p>Translation是一款中英文翻译插件，用于在IDEA内部快速实现中英文翻译</p><hr /><h3 id="maven辅助工具"><a class="markdownIt-Anchor" href="#maven辅助工具"></a> Maven辅助工具</h3><h4 id="maven-helper"><a class="markdownIt-Anchor" href="#maven-helper"></a> Maven Helper</h4><p>Maven Helper是一款maven依赖冲突分析的插件，主要提供图形化操作来替代命令行操作</p><hr /><h3 id="mybatis辅助工具"><a class="markdownIt-Anchor" href="#mybatis辅助工具"></a> Mybatis辅助工具</h3><p>注意部分MyBatis插件和MybatisPlus插件可能会产生冲突</p><h4 id="mybatis-log"><a class="markdownIt-Anchor" href="#mybatis-log"></a> Mybatis Log</h4><p>Mybatis Log是一款Mybatis的<strong>日志处理</strong>工具，将Mybatis框架日志中的SQL信息转换可直接执行的SQL语句，节省时间。其历史版本不需要付费，最新版本需要付费使用</p><h4 id="mybatiscodehelperpro"><a class="markdownIt-Anchor" href="#mybatiscodehelperpro"></a> MybatisCodeHelperPro</h4><p>MybatisCodeHelperPro是一款MyBatis的强大辅助插件（不少开发者对此给出很高的评价），提供免费版和付费版，免费版提供的功能基本能够满足日常需求。（可能会与其它插件产生冲突）</p><hr /><h3 id="mybatisplus辅助工具"><a class="markdownIt-Anchor" href="#mybatisplus辅助工具"></a> MybatisPlus辅助工具</h3><h4 id="mybatisx"><a class="markdownIt-Anchor" href="#mybatisx"></a> MybatisX</h4><p>MybatisX是MybatisPlus的强大辅助插件。（可能会与Mybatis的部分插件产生冲突）</p><hr /><h3 id="restful辅助工具"><a class="markdownIt-Anchor" href="#restful辅助工具"></a> Restful辅助工具</h3><h4 id="restfultoolkit"><a class="markdownIt-Anchor" href="#restfultoolkit"></a> Restfultoolkit</h4><p>Restfultoolkit是一款针对Restful服务开发的辅助工具，能够根据URL快速跳转到对应的方法接口，提供了一个接口列表窗口，内置一个简单的Http请求工具（相当于一个简化的测试工具，类似于postman和apifox等）</p><hr /><h3 id="k8s辅助工具"><a class="markdownIt-Anchor" href="#k8s辅助工具"></a> K8s辅助工具</h3><h4 id="kubernetes"><a class="markdownIt-Anchor" href="#kubernetes"></a> Kubernetes</h4><p>Kubernetes插件用于检测管理Kubernetes系统</p><hr />]]></content>
    
    
    <summary type="html">&lt;p&gt;作为IntelliJ IDEA的用户之一，原始的IDE已经能够满足大部分需求，但IDE插件提供了更多拓展性的功能，使得开发者能够工作在适宜的“开发环境”中，提高开发效率，提升开发者体验。那么以下是笔者在使用过程中所搜寻到的一些插件，请注意其中部分插件并不能直接提升开发效率，另外过多的插件反而会造成开发效率的低下，请悉知。读者可自行选择感兴趣的插件进行配置</summary>
    
    
    
    
    <category term="配置优化" scheme="https://s-chance.github.io/tags/%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>在linux终端显示系统信息</title>
    <link href="https://s-chance.github.io/2022/12/30/screenfetch-neofetch/"/>
    <id>https://s-chance.github.io/2022/12/30/screenfetch-neofetch/</id>
    <published>2022-12-29T16:14:15.000Z</published>
    <updated>2022-12-30T06:17:11.492Z</updated>
    
    <content type="html"><![CDATA[<p>在linux操作系统的桌面用户群体中, 一个能够打印linux发行版logo以及相关系统信息的命令, 一定程度上能够使不同用户的linux系统更加个性化。基于Ubuntu22.04LTS, 下面介绍两个相关命令<span id="more"></span></p><h3 id="screenfetch命令"><a class="markdownIt-Anchor" href="#screenfetch命令"></a> screenfetch命令</h3><h4 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install screenfetch</span><br></pre></td></tr></table></figure><h4 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h4><p>直接在终端输入以下命令即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screenfetch</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/s-chance/firgure-bed/img/screenfetch-202212300156995.png" alt="image-20221230014403780" /></p><h4 id="可能出现的问题"><a class="markdownIt-Anchor" href="#可能出现的问题"></a> 可能出现的问题</h4><p>Ubuntu22.04LTS直接使用screenfetch可能会出现操作数问题, 从而导致部分信息无法正确显示。可以根据提示信息找到对应脚本文件进行修改</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/bin/screenfetch</span><br></pre></td></tr></table></figure><p>找到提示的配置文件所在行</p><p><img src="https://cdn.jsdelivr.net/gh/s-chance/firgure-bed/img/screenfetch202212300215987.png" alt="image-20221230021511877" /></p><p><strong>经过测试实际上是awk命令识别错误</strong></p><p>使用free命令查看相关信息, 配合awk查看输出情况</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -b</span><br><span class="line">free -b | awk <span class="string">&#x27;&#123;print $1&quot;-&quot;$6&#125;&#x27;</span></span><br><span class="line">free -b | awk <span class="string">&#x27;&#123;print $2&quot;-&quot;$7&#125;&#x27;</span></span><br><span class="line">free -b | awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;NR==2&#123;print $1&#125;&#x27;</span> | awk <span class="string">&#x27;&#123;print $2&quot;-&quot;$7&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/s-chance/firgure-bed/img/screenfetch202212300228383.png" alt="image-20221230022845310" /></p><p>修改脚本文件中的命令</p><p>将原本的<code>free -b | awk -F ':' 'NR==2&#123;print $2&#125;' | awk '&#123;print $1&quot;-&quot;$6&#125;'</code>替换为<code>free -b | awk -F ':' 'NR==2&#123;print $1&#125;' | awk '&#123;print $2&quot;-&quot;$7&#125;'</code></p><p><img src="https://cdn.jsdelivr.net/gh/s-chance/firgure-bed/img/screenfetch202212300256553.png" alt="image-20221230025640469" /></p><p>重新运行screenfetch, 效果如下, 所有信息都能正常输出</p><p><img src="https://cdn.jsdelivr.net/gh/s-chance/firgure-bed/img/screenfetch202212300258212.png" alt="image-20221230025832144" /></p><h3 id="neofetch命令"><a class="markdownIt-Anchor" href="#neofetch命令"></a> neofetch命令</h3><p>neofetch相对于screenfetch可定制性更高, 推荐使用</p><h4 id="安装-2"><a class="markdownIt-Anchor" href="#安装-2"></a> 安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install neofetch</span><br></pre></td></tr></table></figure><h4 id="手动编译安装"><a class="markdownIt-Anchor" href="#手动编译安装"></a> 手动编译安装</h4><p>从github克隆下来的源代码编译安装, 可使用最新版本的neofetch</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/dylanaraps/neofetch</span><br><span class="line"><span class="built_in">cd</span> neofetch</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h4 id="使用-2"><a class="markdownIt-Anchor" href="#使用-2"></a> 使用</h4><p>直接在终端输入以下命令即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">neofetch</span><br></pre></td></tr></table></figure><p>效果如下(这里我使用了kde环境)</p><p><img src="https://cdn.jsdelivr.net/gh/s-chance/firgure-bed/img/neofetch202212300318461.png" alt="image-20221230031810370" /></p><p>注意neofetch默认不显示Disk信息, 可修改配置文件来显示Disk信息</p><p>编辑配置文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.config/neofetch/config.conf</span><br></pre></td></tr></table></figure><p>添加如下的Disk配置即可, 同理其它信息显示也可以通过类似配置实现输出</p><p><img src="https://cdn.jsdelivr.net/gh/s-chance/firgure-bed/img/neofetch202212300326391.png" alt="image-20221230032639272" /></p><h4 id="其他用法"><a class="markdownIt-Anchor" href="#其他用法"></a> 其他用法</h4><h5 id="显示另一个发行版的标志"><a class="markdownIt-Anchor" href="#显示另一个发行版的标志"></a> 显示另一个发行版的标志</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># neofetch --ascii_distro distroname</span></span><br><span class="line">neofetch --ascii_distro <span class="built_in">arch</span></span><br><span class="line">neofetch --ascii_distro debian</span><br><span class="line"><span class="comment"># 在发行版名称后面加上后缀_small可输出对应发行版的迷你标志</span></span><br><span class="line">neofetch --ascii_distro arch_small</span><br><span class="line">neofetch --ascii_distro debian_small</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/s-chance/firgure-bed/img/neofetch202212300335106.png" alt="image-20221230033519980" /></p><h5 id="隐藏logo信息"><a class="markdownIt-Anchor" href="#隐藏logo信息"></a> 隐藏logo信息</h5><p>只输出系统信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">neofetch --off</span><br></pre></td></tr></table></figure><h5 id="隐藏系统信息"><a class="markdownIt-Anchor" href="#隐藏系统信息"></a> 隐藏系统信息</h5><p>只输出logo信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">neofetch -l</span><br></pre></td></tr></table></figure><h5 id="渐变色logo"><a class="markdownIt-Anchor" href="#渐变色logo"></a> 渐变色logo</h5><p><strong>neofetch配合lolcat实现渐变色的logo</strong></p><p>安装lolcat</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install lolcat</span><br></pre></td></tr></table></figure><p>使用管道命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">neofetch | lolcat</span><br></pre></td></tr></table></figure><h5 id="自定义图片logo"><a class="markdownIt-Anchor" href="#自定义图片logo"></a> 自定义图片logo</h5><p><strong>neofetch配合w3m自定义图片作为logo在终端展示</strong></p><p>安装w3m-img</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install w3m-img</span><br></pre></td></tr></table></figure><p>测试一下能否显示图片</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">w3m www.baidu.com</span><br></pre></td></tr></table></figure><p>添加图片路径, 否则默认为桌面壁纸</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">neofetch --w3m img/logo.png <span class="comment"># 图片路径根据实际情况编写</span></span><br></pre></td></tr></table></figure><p>在这边的测试环境下w3m出现了一定的显示问题, 可仿照上述格式替换参数进行测试</p><p>其它的显示图片参数caca、jp2a显示的是字符组成的logo, chafa显示的是低像素图, iterm2、sixel显示的是高像素图</p><p><strong>注意: 测试环境为kde, 不同环境包括不同配置在终端展示的图片不一定具有同等效果, 且存在一定的瑕疵, 请根据实际情况进行配置</strong></p><h4 id="默认终端启动时自动执行neofetch"><a class="markdownIt-Anchor" href="#默认终端启动时自动执行neofetch"></a> 默认终端启动时自动执行neofetch</h4><p>查看shell配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/shells</span><br></pre></td></tr></table></figure><p>根据实际配置修改对应配置文件, Ubuntu22.04LTS默认为bash, 另外还有zsh</p><p>修改bash配置文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>修改zsh配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.zshrc</span><br></pre></td></tr></table></figure><p>在文件末尾添加<strong>neofetch</strong>即可</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在linux操作系统的桌面用户群体中, 一个能够打印linux发行版logo以及相关系统信息的命令, 一定程度上能够使不同用户的linux系统更加个性化。基于Ubuntu22.04LTS, 下面介绍两个相关命令</summary>
    
    
    
    <category term="linux" scheme="https://s-chance.github.io/categories/linux/"/>
    
    
    <category term="linux优化" scheme="https://s-chance.github.io/tags/linux%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前后端知识</title>
    <link href="https://s-chance.github.io/2022/12/18/font-back-end/"/>
    <id>https://s-chance.github.io/2022/12/18/font-back-end/</id>
    <published>2022-12-18T09:40:47.000Z</published>
    <updated>2022-12-18T17:13:20.591Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开发模式"><a class="markdownIt-Anchor" href="#开发模式"></a> 开发模式</h3><p><strong>前后端分离</strong>已成为web大型项目的标准开发方式, 主要解决了<strong>传统的前后端不分离</strong>所带来的一系列开发过程中的问题<span id="more"></span></p><h4 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h4><p><strong>前后端不分离</strong>: 前后端代码放在一个工程下或同一个目录下, 前端页面中含有后端的代码(如典型的jsp页面内嵌java代码)。前后端代码以及前后端工作开发<strong>耦合度极高</strong>, 前后端需要同时协作才能完成开发</p><p><strong>前后端分离</strong>: 前后端代码放在不同的工程下, 只需要<strong>提前约定好API数据规范</strong>, 前后端就可以各自独立开发。前端可以通过<strong>Mock技术模拟后端API服务</strong>来独立运行和测试; 后端也可以独立开发、运行、测试, 通过<strong>Swagger技术自动生成API文档</strong>提供给前端, 还能进行自动化接口测试API的可用性</p><h4 id="前后端分离涉及的技术"><a class="markdownIt-Anchor" href="#前后端分离涉及的技术"></a> 前后端分离涉及的技术</h4><p>1.Ajax、axios和json等基础交互技术</p><p>2.Http协议在同源策略下引发的跨域访问</p><p>3.Nodejs搭建中间层服务器以及前端Mock测试</p><h4 id="对比"><a class="markdownIt-Anchor" href="#对比"></a> 对比</h4><p><strong>以一个SpringBoot项目为例</strong></p><p>前后端不分离的情况下, <strong>直接使用SpringBoot启动即可</strong></p><ul><li>需要考虑静态资源所存放的相对路径(例如需要存放在某个指定的静态资源static目录下)</li><li>在测试过程中遇到问题难以快速定位到问题位于前端还是后端</li><li>运行时出现问题会直接导致SpringBoot项目无法启动或者运行时无法正确地进行前后端交互测试</li><li>对于**SEO(Search Engine Optimization, 搜索引擎优化)**的支持较好</li></ul><p>前后端分离的情况下, <strong>后端使用SpringBoot启动, 前端使用Nodejs启动</strong></p><ul><li>不再需要考虑相对路径的限制</li><li>可以使用特定的技术来模拟前后端进行数据交互测试, 从而准确定位问题</li><li>会有跨域访问的限制</li><li>由于前端与后端分离导致服务端无法去渲染前端页面, 即<strong>一般情况下不支持SSR(Server-Side-Rendering，服务器端渲染)</strong></li></ul><h3 id="渲染方式"><a class="markdownIt-Anchor" href="#渲染方式"></a> 渲染方式</h3><p>渲染方式可分为<strong>SSR服务端渲染</strong>和<strong>CSR客户端渲染</strong></p><p><strong>SSR服务端渲染</strong></p><ul><li><p>SSR拥有很好的SEO搜索引擎优化</p></li><li><p>SSR的首屏优化很好, 即首屏时间短</p></li><li><p>SSR加重了服务端的负载, 因为渲染需要在服务端完成</p></li><li><p>SSR的页面交互性较差</p></li><li><p>使用SSR基本说明了前后端不分离</p></li><li><p>SSR非常适合开发静态网站以及业务逻辑复杂的网站</p></li></ul><p><strong>CSR客户端渲染</strong></p><ul><li><p>CSR不支持SEO搜索引擎优化, 因为数据是异步获取的, 很难被SEO收录</p></li><li><p>CSR的首屏时间较长</p></li><li><p>CSR减轻了服务器的负载, 因为渲染是在客户端完成的</p></li><li><p>CSR的页面交互性非常好</p></li><li><p>使用CSR基本说明了前后端分离</p></li><li><p>CSR非常适合开发对即时交互性要求较高的Web应用程序以及app小程序</p></li></ul><p>基于不同的渲染方式又可以引出<strong>SPA</strong>和<strong>MPA</strong></p><h3 id="spa和mpa"><a class="markdownIt-Anchor" href="#spa和mpa"></a> SPA和MPA</h3><p><strong>SPA单页面应用模式</strong></p><ul><li>SPA模式只拥有一个主页面, 所有的静态资源都包含在主页面中, 只需要加载一次</li><li>所有的功能模块组件化, 通过刷新局部资源来实现功能</li><li>几乎不存在<strong>转发</strong>和<strong>重定向</strong>的概念</li><li>传统SPA通常都是CSR渲染, 也可以借助SSR渲染来优化SEO</li><li>SPA的实现核心是<strong>前端路由</strong>, 前端路由的核心: 改变视图的同时不会向后端发出请求</li><li>单个vue+vite的工程就是典型的SPA模式</li></ul><p><strong>MPA多页面应用模式</strong></p><ul><li>MPA模式拥有多个页面, 所有的静态资源都是公共资源, 每个页面都需要重新加载</li><li>所有的功能会划分到多个页面中, 通过转发和重定向页面来实现功能</li><li>MPA通常都是SSR渲染, 基本不会使用CSR渲染, 因为逻辑较为复杂</li><li>MPA中基本没有前端路由</li></ul><p>目前大型Web项目开发可能更多的是使用MPA+SPA的混合模式</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;开发模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#开发模式&quot;&gt;&lt;/a&gt; 开发模式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;前后端分离&lt;/strong&gt;已成为web大型项目的标准开发方式, 主要解决了&lt;strong&gt;传统的前后端不分离&lt;/strong&gt;所带来的一系列开发过程中的问题</summary>
    
    
    
    
    <category term="前后端" scheme="https://s-chance.github.io/tags/%E5%89%8D%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>在Linux上配置Java环境</title>
    <link href="https://s-chance.github.io/2022/11/26/java-in-linux/"/>
    <id>https://s-chance.github.io/2022/11/26/java-in-linux/</id>
    <published>2022-11-26T06:20:08.000Z</published>
    <updated>2022-12-29T16:23:48.670Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基于ubuntu2004lts配置java环境"><a class="markdownIt-Anchor" href="#基于ubuntu2004lts配置java环境"></a> 基于Ubuntu20.04LTS配置Java环境</h3><p>在Linux上配置Java环境的方式有3种, 系统级配置、用户级配置、临时配置</p><p>配置好Java环境就能够在Linux上运行基于Java环境运行的相关程序, 你可以在Linux系统上搭建基于Java实现的网站。这里以<strong>系统级配置</strong>为例, 适合个人开发者使用<span id="more"></span></p><h4 id="1下载targz压缩包-java官网"><a class="markdownIt-Anchor" href="#1下载targz压缩包-java官网"></a> 1.下载tar.gz压缩包 <a href="https://www.oracle.com/java/technologies/downloads/">Java官网</a></h4><p>tar.gz包先下载到windows中, 再通过远程文件传输工具, 将压缩包传送到Linux的目录下, 这里是/root目录</p><p>本文以<strong>jdk-8u151-linux-i586.tar.gz</strong>为例配置Java环境, 高版本可能有所区别, 32位与64位版本在不同linux发行版上可能有所区别</p><h4 id="2在linux中配置环境"><a class="markdownIt-Anchor" href="#2在linux中配置环境"></a> 2.在Linux中配置环境</h4><h5 id="1前提准备"><a class="markdownIt-Anchor" href="#1前提准备"></a> 1.前提准备</h5><p>默认当前目录是<strong>初始目录/root</strong>, 默认当前用户权限为<strong>root权限</strong>, 默认<strong>tar.gz包已经传送到/root目录下</strong></p><h5 id="2创建用于存放java文件夹的目录"><a class="markdownIt-Anchor" href="#2创建用于存放java文件夹的目录"></a> 2.创建用于存放Java文件夹的目录</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /usr/java</span><br></pre></td></tr></table></figure><h5 id="3解压targz压缩包到该目录"><a class="markdownIt-Anchor" href="#3解压targz压缩包到该目录"></a> 3.解压tar.gz压缩包到该目录</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tar -zxvf jdk-8u151-linux-i586.tar.gz -C /usr/java</span><br></pre></td></tr></table></figure><h5 id="4编辑环境变量文件"><a class="markdownIt-Anchor" href="#4编辑环境变量文件"></a> 4.编辑环境变量文件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure><p>在文件末尾追加下面内容, 具体目录根据实际情况编写</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.8.0_151</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><dl><dt><strong>一些特殊符号说明</strong></dt><dd>表示并列符号, 说明某个变量的值有多个, 用 : 来区分。相当于Windows下的 ;</dd></dl><p>$ 表示引用变量, {} 则用于限定变量边界, 如上面的 ${JAVA_HOME} 就表示 /usr/java/jdk1.8.0_151</p><h5 id="5使环境变量马上生效"><a class="markdownIt-Anchor" href="#5使环境变量马上生效"></a> 5.使环境变量马上生效</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h4 id="3测试java环境"><a class="markdownIt-Anchor" href="#3测试java环境"></a> 3.测试Java环境</h4><p>运行以下命令, 如果都成功运行, 则说明Java环境配置完成</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">java</span><br><span class="line">javac</span><br></pre></td></tr></table></figure><h5 id="可能遇到的问题"><a class="markdownIt-Anchor" href="#可能遇到的问题"></a> 可能遇到的问题</h5><p>安装i586后缀jdk, 即<strong>安装32位的jdk</strong>后测试Java环境时提示<strong>bash: /usr/lib/java/jdk1.8.0_151/bin/java: 没有那个文件或目录</strong>, 可能是由于当前Linux发行版<strong>默认没有用于amd64系统的32位libc开发包</strong></p><p>可通过以下5个常用命令查看Linux发行版的架构信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br><span class="line">dpkg --print-architecture <span class="comment"># 这条命令只适用于基于Debian和Ubuntu的Linux发行版</span></span><br><span class="line">getconf LONG_BIT</span><br><span class="line"><span class="built_in">arch</span></span><br><span class="line">file /sbin/init </span><br><span class="line"><span class="comment"># file命令需要配合它链接的另一个文件使用</span></span><br><span class="line"><span class="comment"># 在Ubuntu中是链接的是/lib/systemd/systemd</span></span><br><span class="line"><span class="comment"># 通过file /lib/systemd/systemd查看到架构信息</span></span><br></pre></td></tr></table></figure><h5 id="安装缺失的32位开发包"><a class="markdownIt-Anchor" href="#安装缺失的32位开发包"></a> 安装缺失的32位开发包</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libc6-i386</span><br></pre></td></tr></table></figure><p>如果安装libc6-i386失败, 请先更新软件列表, 再尝试重新安装, 并重新测试Java环境</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>如果还是失败请选择64位的jdk版本重新进行配置</p><h5 id="重新测试java环境"><a class="markdownIt-Anchor" href="#重新测试java环境"></a> 重新测试Java环境</h5><h4 id="4update-alternatives软件版本管理"><a class="markdownIt-Anchor" href="#4update-alternatives软件版本管理"></a> 4.update-alternatives软件版本管理</h4><h5 id="1系统注册jdk需要使用多个jdk版本时"><a class="markdownIt-Anchor" href="#1系统注册jdk需要使用多个jdk版本时"></a> 1.系统注册jdk(需要使用多个jdk版本时)</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/java java /usr/java/jdk1.8.0_151/bin/java 300</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><p>第一个参数: --install表示向update-alternatives注册服务名</p><p>第二个参数: 注册<strong>最终地址</strong>, 成功后将会把命令在这个固定的目的地址做真实命令的<strong>软链接</strong>, 通过管理这个软链就能实现不同版本jdk的切换</p><p>第三个参数: <strong>服务名</strong>, 管理时以它为关联依据</p><p>第四个参数: 被管理命令的<strong>绝对路径</strong></p><p>第五个参数: <strong>优先级</strong>, 数字越大优先级越高</p><h5 id="2交互式修改"><a class="markdownIt-Anchor" href="#2交互式修改"></a> 2.交互式修改</h5><p>如果有多个版本的jdk, 可执行下面的命令通过交互界面进行切换</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --config java</span><br></pre></td></tr></table></figure><p>查看多个版本的jdk以及当前状态</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --display java</span><br></pre></td></tr></table></figure><p>调整为<strong>auto</strong>模式, 如果上面查看的状态是<strong>manual</strong>, 则还不能自动选择优先级高的jdk版本, 需要调整为auto模式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --auto java</span><br></pre></td></tr></table></figure><h4 id="5补充"><a class="markdownIt-Anchor" href="#5补充"></a> 5.补充</h4><p><strong>将上述的/etc/profile替换成~/.bashrc就是用户级配置</strong></p><p><strong>/etc/profile</strong>: 此文件为系统的每个用户设置环境信息, 当用户第一次登录时, 该文件被执行, 是<strong>系统全局</strong>对终端环境的设置, 它是login时最先被系统加载的, 是它调用了/etc/bashrc, 以及/etc/profile.d目录下的*.sh文件, 如果有一个软件包, 系统上只安装一份, 供所有开发者使用, 建议在/etc/profile.d下创建一个新的xxx.sh, 配置环境变量</p><p><strong>~/.bashrc</strong>: 是<strong>用户</strong>相关的终端（shell）的环境设置, 通常打开一个新终端时, 默认会加载里面的设置, 在这里的设置不会影响其它用户。如果一个服务器多个开发者使用, 需要配置多个sdk, 则推荐使用该设置</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;基于ubuntu2004lts配置java环境&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基于ubuntu2004lts配置java环境&quot;&gt;&lt;/a&gt; 基于Ubuntu20.04LTS配置Java环境&lt;/h3&gt;
&lt;p&gt;在Linux上配置Java环境的方式有3种, 系统级配置、用户级配置、临时配置&lt;/p&gt;
&lt;p&gt;配置好Java环境就能够在Linux上运行基于Java环境运行的相关程序, 你可以在Linux系统上搭建基于Java实现的网站。这里以&lt;strong&gt;系统级配置&lt;/strong&gt;为例, 适合个人开发者使用</summary>
    
    
    
    <category term="linux" scheme="https://s-chance.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://s-chance.github.io/tags/linux/"/>
    
    <category term="Java" scheme="https://s-chance.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>linux-base</title>
    <link href="https://s-chance.github.io/2022/11/17/linux-base/"/>
    <id>https://s-chance.github.io/2022/11/17/linux-base/</id>
    <published>2022-11-17T11:58:38.000Z</published>
    <updated>2022-12-29T16:24:07.907Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于linux的通用操作"><a class="markdownIt-Anchor" href="#关于linux的通用操作"></a> 关于Linux的通用操作</h3><p>基于Ubuntu22.04发行版的环境，本文整理了一些在Linux系统下基本通用的操作，使初学者能初步学会Linux系统的操作或使老用户重新回顾一下常用操作<span id="more"></span></p><h4 id="参考文章-linux-幕布-mubucom-作者时光逝"><a class="markdownIt-Anchor" href="#参考文章-linux-幕布-mubucom-作者时光逝"></a> 参考文章 <a href="https://mubu.com/doc/28TtabEpGV3">Linux - 幕布 (mubu.com) 作者：时光＆逝 </a></h4><h4 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h4><p>远程连接工具<a href="https://www.xshell.com/zh/xshell/">XSHELL - NetSarang Website</a></p><p>远程文件传输工具 <a href="https://www.xshell.com/zh/xftp/">XFTP - NetSarang Website</a></p><p>配合XFTP可以较为直观地观察文件及目录的变化</p><p>注：一些发行版可能需要手动安装部分命令。另外，在执行命令时<strong>请确认自己所处的当前目录</strong></p><h4 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 提示</h4><p>一些命令可能需要在root权限下执行，或者在执行命令的前面都加上<code>sudo</code>的前缀，表示临时使用root权限执行这条命令</p><p>如果忘记了root密码可以通过以下方法重新设置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo passwd <span class="comment"># 进入密码设置</span></span><br><span class="line"><span class="comment"># 输入当初安装时设置的非root普通用户密码</span></span><br><span class="line"><span class="comment"># 输入新的root密码</span></span><br><span class="line"><span class="comment"># 重复输入root密码</span></span><br><span class="line">su <span class="comment"># 切换到root</span></span><br><span class="line"><span class="comment"># 输入刚刚设置的root密码，就能切换到root用户</span></span><br></pre></td></tr></table></figure><h4 id="vim文本编辑器"><a class="markdownIt-Anchor" href="#vim文本编辑器"></a> vim文本编辑器</h4><p><strong>查看vim配置信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim --version</span><br></pre></td></tr></table></figure><p><strong>简易配置一下vim</strong></p><p>用vim打开用户vimrc文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim <span class="variable">$HOME</span>/.vimrc</span><br></pre></td></tr></table></figure><p>写入以下内容（后面的注释不需要）</p><blockquote><p>syntax on   # 开启语法高亮</p><p>set ts = 4    #  设置tab的缩进显示为四个空格的宽度</p><p>set expandtab # 设置tab字符替换为等宽的4个空格字符</p><p>set autoindent # 开启自动缩进</p><p>set number # 开启行号显示</p><p>set relativenumber # 使用相对行号</p></blockquote><p>关于vim的基本操作可以参考其它文章 <a href="https://www.runoob.com/linux/linux-vim.html">Linux vi/vim | 菜鸟教程 (runoob.com)</a> 或者视频<a href="https://www.bilibili.com/video/BV13t4y1t7Wg/?share_source=copy_web&amp;vd_source=f4fedbdbfad10afdb2269285bd340510">【保姆级入门】Vim编辑器</a></p><h4 id="用户管理"><a class="markdownIt-Anchor" href="#用户管理"></a> 用户管理</h4><p>linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户都必须先向系统管理员申请一个账号，然后以这个账号的身份进入系统</p><p>linux的用户至少要属于一个组</p><h5 id="基本命令"><a class="markdownIt-Anchor" href="#基本命令"></a> 基本命令</h5><p><strong>useradd命令</strong>：创建一个用户</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># useradd [参数] 用户名</span></span><br><span class="line">useradd normal <span class="comment"># 创建一个名为normal的用户，用户目录默认家目录</span></span><br><span class="line">useradd -d /myuser normal <span class="comment"># 创建一个名为normal的用户，指定用户目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># useradd [参数] 组名 用户名</span></span><br><span class="line">useradd -g visitor vis <span class="comment"># 创建一个名为vis的用户的同时指定用户组为visitor</span></span><br></pre></td></tr></table></figure><p><strong>passwd命令</strong>：指定或修改用户的密码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># passwd 用户名</span></span><br><span class="line">passwd normal <span class="comment"># 指定或修改normal用户的密码</span></span><br></pre></td></tr></table></figure><p><strong>userdel命令</strong>：删除用户</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># userdel 用户名</span></span><br><span class="line">userdel normal <span class="comment"># 删除normal用户</span></span><br><span class="line">userdel -r normal <span class="comment"># 同时删除该用户的目录</span></span><br></pre></td></tr></table></figure><p><strong>usermod命令</strong>：修改用户信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># usermod [参数] 新用户名 旧用户名</span></span><br><span class="line">usermod -l vis normal <span class="comment"># 修改normal用户名为vis、</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># usermod [参数] 组名 用户名</span></span><br><span class="line">groupadd demo</span><br><span class="line">usermod -g demo vis <span class="comment"># 修改vis用户所在的用户组为demo组</span></span><br></pre></td></tr></table></figure><p><strong>id命令</strong>：查询用户信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># id 用户名</span></span><br><span class="line"><span class="built_in">id</span> normal <span class="comment"># 查询normal用户信息</span></span><br></pre></td></tr></table></figure><p><strong>su命令</strong>：用户切换</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># su [参数] 用户名</span></span><br><span class="line">su common <span class="comment"># 切换到一个名为common的用户</span></span><br><span class="line">su - common <span class="comment"># 将环境变量一并切换为common用户的环境变量</span></span><br></pre></td></tr></table></figure><p><strong>groupadd命令</strong>：添加一个名为visitor的用户组</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># groupadd 组名</span></span><br><span class="line">groupadd visitor</span><br></pre></td></tr></table></figure><p><strong>groupdel命令</strong>：删除visitor用户组</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># groupdel 组名</span></span><br><span class="line">groupdel visitor</span><br></pre></td></tr></table></figure><p><strong>groupmod命令</strong>：修改用户组</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># groupmod [选项 参数] 组名</span></span><br><span class="line">groupmod -n demo <span class="built_in">test</span> <span class="comment"># 修改test组名为demo</span></span><br><span class="line">groupmod -g 9999 <span class="built_in">test</span> <span class="comment"># 修改test组ID为9999</span></span><br></pre></td></tr></table></figure><h5 id="用户信息文件"><a class="markdownIt-Anchor" href="#用户信息文件"></a> 用户信息文件</h5><ul><li><p><strong>/etc/passwd</strong>是用户(user)的配置文件，记录用户的各种信息</p></li><li><p><strong>/ect/shadow</strong>是口令的配置文件</p></li><li><p><strong>/etc/group</strong>是组(group)的配置文件，记录组的各种信息</p></li></ul><h4 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h4><h5 id="进程命令"><a class="markdownIt-Anchor" href="#进程命令"></a> 进程命令</h5><p><strong>init命令</strong>：Linux下的进程初始化工具，用于切换运行级别</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">init 0 <span class="comment"># 停机(不要将initdefault设置为0)</span></span><br><span class="line">init 1 <span class="comment"># 单用户模式，一般用于系统级维护</span></span><br><span class="line">init 2 <span class="comment"># 多用户模式，无法使用NFS(网络文件系统)挂载，没有网络支持</span></span><br><span class="line">init 3 <span class="comment"># 多用户模式，标准的运行级，有网络支持</span></span><br><span class="line">init 4 <span class="comment"># 保留，未使用</span></span><br><span class="line">init 5 <span class="comment"># X11(xwindow)图形化界面模式，多用户，有网络支持，一般用于远程连接时使用Linux图形化界面</span></span><br><span class="line">init 6 <span class="comment"># 重新启动(不要将initdefault设置为6)</span></span><br></pre></td></tr></table></figure><h5 id="帮助命令"><a class="markdownIt-Anchor" href="#帮助命令"></a> 帮助命令</h5><p><strong>man命令</strong>：用于获取帮助手册</p><p><strong>help命令</strong>：获取shell内置命令的帮助信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man vim <span class="comment"># 获取vim的帮助手册</span></span><br><span class="line"><span class="built_in">help</span> <span class="built_in">cd</span> <span class="comment"># 获取cd命令的帮助信息</span></span><br><span class="line"><span class="built_in">help</span> <span class="built_in">mv</span> <span class="comment"># 获取mv命令的帮助信息，但会失败，因为mv不是内置命令</span></span><br><span class="line"><span class="built_in">type</span> <span class="built_in">mv</span> <span class="comment"># 查看mv命令的类型(内置命令或外部命令)</span></span><br></pre></td></tr></table></figure><h5 id="文件目录命令"><a class="markdownIt-Anchor" href="#文件目录命令"></a> 文件目录命令</h5><p><strong>pwd命令</strong>：查看当前所在目录的绝对路径</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><p><strong>ls命令</strong>：查看当前所在目录的所有文件和目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls [参数] [目录或文件名]</span></span><br><span class="line"><span class="built_in">ls</span> -a <span class="comment"># 显示当前所有文件和目录，包括不可见的</span></span><br><span class="line"><span class="built_in">ls</span> -l <span class="comment"># 以列表的形式显示信息</span></span><br></pre></td></tr></table></figure><p><strong>cd命令</strong>：切换到指定目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd [目录路径]</span></span><br><span class="line"><span class="built_in">cd</span> ~  <span class="comment"># 进入默认初始目录</span></span><br><span class="line"><span class="built_in">cd</span> .. <span class="comment"># 返回上一级目录</span></span><br><span class="line"><span class="built_in">cd</span> /opt <span class="comment"># 进入opt目录</span></span><br></pre></td></tr></table></figure><p><strong>mkdir命令</strong>：创建指定目录，可根据绝对路径或相对路径创建</p><p><strong>rmdir命令</strong>：删除指定的空目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkdir [参数] 目录名</span></span><br><span class="line"><span class="built_in">mkdir</span> <span class="built_in">test</span> <span class="comment"># 在当前目录下创建一个test目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p a/b/c <span class="comment"># 在当前目录下创建a/b/c的嵌套多级目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rmdir [参数] 目录名</span></span><br><span class="line"><span class="built_in">rmdir</span> <span class="built_in">test</span> <span class="comment"># 删除test目录，test目录下不能有其它内容</span></span><br><span class="line"><span class="comment"># 删除有其它内容的目录时需要使用rm -rf命令</span></span><br></pre></td></tr></table></figure><p><strong>touch命令</strong>：创建空文件，可根据绝对路径或相对路径创建</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># touch 文件名</span></span><br><span class="line"><span class="built_in">touch</span> demo.txt <span class="comment"># 在当前目录下创建demo.txt文件</span></span><br></pre></td></tr></table></figure><p><strong>cp命令</strong>：拷贝文件到指定目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cp [参数] 源目录 指定目录</span></span><br><span class="line"><span class="built_in">cp</span> demo.txt <span class="built_in">test</span> <span class="comment"># 复制demo.txt文件到当前同级的test目录下</span></span><br><span class="line"><span class="built_in">cp</span> -r <span class="built_in">source</span> <span class="built_in">test</span> <span class="comment"># 将source文件夹以及文件夹下所有内容复制到同级的test文件夹下(递归复制)</span></span><br></pre></td></tr></table></figure><p><strong>rm命令</strong>：删除文件或目录（文件夹）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rm [参数] 文件名</span></span><br><span class="line"><span class="built_in">rm</span> demo.txt <span class="comment"># 删除demo.txt文件</span></span><br><span class="line"><span class="built_in">rm</span> -r <span class="built_in">source</span> <span class="comment"># 递归删除整个source目录</span></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="built_in">test</span> <span class="comment"># 无提示地强制删除整个test目录 </span></span><br></pre></td></tr></table></figure><p><strong>cat命令</strong>：只读地查看文件内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat [参数] 文件名</span></span><br><span class="line"><span class="built_in">cat</span> demo.txt <span class="comment"># 查看demo.txt的内容</span></span><br><span class="line"><span class="built_in">cat</span> -n demo.txt <span class="comment"># 查看文件时显示行号</span></span><br></pre></td></tr></table></figure><p><strong>more命令</strong>：基于vi编辑器的文本过滤器，以全屏方式按页显示文件内容，适合阅读长内容的文本</p><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">具体功能</th></tr></thead><tbody><tr><td style="text-align:center">空格(space)</td><td style="text-align:center">向下翻一页</td></tr><tr><td style="text-align:center">Enter</td><td style="text-align:center">向下翻一行</td></tr><tr><td style="text-align:center">q</td><td style="text-align:center">退出</td></tr><tr><td style="text-align:center">Ctrl+F</td><td style="text-align:center">向下滚动一屏</td></tr><tr><td style="text-align:center">Ctrl+B</td><td style="text-align:center">返回上一屏</td></tr><tr><td style="text-align:center">=</td><td style="text-align:center">输出当前行行号</td></tr><tr><td style="text-align:center">:f</td><td style="text-align:center">输出文件名和行号</td></tr></tbody></table><p><strong>less命令</strong>： 来分屏查看文件内容，与<strong>more命令</strong>类似，但功能更加强大。能根据显示需要加载文件内容，而不是一次性加载，对于显示大型文件有较高的效率</p><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">具体功能</th></tr></thead><tbody><tr><td style="text-align:center">空格(space)</td><td style="text-align:center">向下翻一页</td></tr><tr><td style="text-align:center">[pagedown]</td><td style="text-align:center">向下翻一页</td></tr><tr><td style="text-align:center">[pageup]</td><td style="text-align:center">向上翻一页</td></tr><tr><td style="text-align:center">/字串</td><td style="text-align:center">向下搜寻字串 n向下 N向上</td></tr><tr><td style="text-align:center">?字串</td><td style="text-align:center">向上搜寻字串 n向上 N向下</td></tr><tr><td style="text-align:center">q</td><td style="text-align:center">退出</td></tr></tbody></table><p><strong>&gt;指令</strong>：输出重定向，会覆盖文件的内容</p><p><strong>&gt;&gt;指令</strong>：追加内容到文件尾部，不会覆盖文件的内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> &gt; info.txt <span class="comment"># 将当前目录的信息写入info.txt</span></span><br><span class="line"><span class="built_in">ls</span> -l &gt; info.txt <span class="comment"># 覆盖info.txt的内容为列表形式的目录信息</span></span><br><span class="line"><span class="built_in">ls</span> &gt;&gt; info.txt <span class="comment"># 将目录信息追加到文件末尾</span></span><br></pre></td></tr></table></figure><p><strong>echo命令</strong>：输出内容到控制台，可与**&gt;指令或&gt;&gt;指令**组合使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo [参数] [字符串]</span></span><br><span class="line"><span class="built_in">echo</span> hello world <span class="comment"># 输出hello world到控制台</span></span><br><span class="line"><span class="built_in">echo</span> happy &gt;&gt; info.txt <span class="comment"># 此时控制台不会输出内容，内容追加到info.txt中，具体内容可以自定义</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span> <span class="comment"># 获取PATH变量，PATH是原本就存在于Linux下的环境变量</span></span><br></pre></td></tr></table></figure><p><strong>head命令</strong>：查看文件前n行内容，n默认为10</p><p><strong>tail命令</strong>：查看文件后n行内容，n默认为10</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># head [参数] [行数] 文件名</span></span><br><span class="line"><span class="built_in">head</span> info.txt <span class="comment"># 查看info.txt的前10行内容</span></span><br><span class="line"><span class="built_in">head</span> -n 3 info.txt <span class="comment"># 查看info.txt的前3行内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tail [参数] [行数] 文件名</span></span><br><span class="line"><span class="built_in">tail</span> info.txt <span class="comment"># 查看info.txt的后10行内容</span></span><br><span class="line"><span class="built_in">tail</span> -n 3 info.txt <span class="comment"># 查看info.txt的后3行内容</span></span><br></pre></td></tr></table></figure><p><strong>ln命令</strong>：给源文件创建一个<strong>软链接</strong>。软链接也称符号链接，类似于快捷方式，主要存放了链接其他文件的路径。可以通过ln命令<strong>软链接的方式</strong>设置<strong>全局</strong>环境变量（这是一种方式）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ln -s 源文件路径 目标路径</span></span><br><span class="line"><span class="built_in">ln</span> -s info.txt <span class="built_in">test</span>/ <span class="comment"># 将info.txt软链接到同级的test目录下</span></span><br></pre></td></tr></table></figure><h5 id="时间日期命令"><a class="markdownIt-Anchor" href="#时间日期命令"></a> 时间日期命令</h5><p><strong>date命令</strong>：显示或设定系统的日期和时间</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># date [参数] [格式]</span></span><br><span class="line"><span class="built_in">date</span> <span class="comment"># 显示当前系统时间</span></span><br><span class="line"><span class="built_in">date</span> -u <span class="comment"># 显示UTC时间</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;+1 day&quot;</span> +%Y%m%d <span class="comment"># 显示后一天的日期</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;-1 month&quot;</span> +%Y%m%d <span class="comment"># 显示上一月的日期</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;2022-11-18 06:30:00&quot;</span> <span class="comment"># 设置系统时间为2022年11月18日 6时30分0秒，重启系统后会失效</span></span><br></pre></td></tr></table></figure><p><strong>cal命令</strong>：显示月历，需要手动安装命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install ncal <span class="comment"># 安装命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cal [参数] [月份] [年份]</span></span><br><span class="line">cal <span class="comment"># 查看本月月历</span></span><br><span class="line">cal 12 2022 <span class="comment"># 查看2022年12月月历</span></span><br></pre></td></tr></table></figure><h5 id="搜索查找命令"><a class="markdownIt-Anchor" href="#搜索查找命令"></a> 搜索查找命令</h5><p><strong>find命令</strong>：从指定目录向下递归地遍历各个子目录，将满足条件的文件或目录显示在终端</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># find [搜索范围] [参数] ...</span></span><br><span class="line">find . -name <span class="string">&quot;*.txt&quot;</span> <span class="comment"># 查找当前目录及子目录下文件名后缀为txt的文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f <span class="comment"># 查找当前目录及子目录下普通类型的文件</span></span><br><span class="line">find . -user root <span class="comment"># 查找当前目录及子目录下属于root用户的文件</span></span><br><span class="line">find . -size 0 <span class="comment"># 查找当前目录及子目录下长度为0的文件</span></span><br></pre></td></tr></table></figure><p><strong>locate命令</strong>：可以快速定位文件路径，需要手动安装命令。利用事先建立的包含系统中所有文件名称路径的locate数据库实现快速定位，无需遍历整个文件夹，查询速度较快。</p><p>locate数据库不是实时更新的(默认情况下每天自动更新一次)，无法查询当天新建的文件，但可以手动更新locate数据库</p><p><font color='red'>注意：测试命令需要新建文件时，记得随时手动更新locate数据库</font></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install plocate <span class="comment"># 安装命令</span></span><br><span class="line">updatedb <span class="comment"># 手动更新locate数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># locate [参数] [文件名]</span></span><br><span class="line">locate passwd <span class="comment"># 查找passwd文件</span></span><br><span class="line">locate /etc/sh <span class="comment"># 查找etc目录下所有以sh开头的文件</span></span><br><span class="line">locate -n 2 passwd <span class="comment"># 最多显示2个输出</span></span><br><span class="line">locate -i ~/r <span class="comment"># 忽略大小写查找当前用户目录下r开头的文件</span></span><br></pre></td></tr></table></figure><p><strong>grep命令</strong>：在指定文件里查找指定的内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># grep [内容] [文件名]</span></span><br><span class="line">grep root info.txt <span class="comment"># 在info.txt里查找root字符所在的行并输出到控制台</span></span><br><span class="line">grep -n root info.txt <span class="comment"># 显示在完整文本中对应匹配的行号</span></span><br><span class="line">grep -i root info.txt <span class="comment"># 忽略大小写进行查找</span></span><br></pre></td></tr></table></figure><h5 id="压缩与解压命令"><a class="markdownIt-Anchor" href="#压缩与解压命令"></a> 压缩与解压命令</h5><p><strong>gzip命令</strong>：压缩文件，格式只能为*.gz，它的设计目标是为了处理单个文件</p><p><strong>gunzip命令</strong>：解压文件，只能解压*.gz后缀的文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gzip 文件</span></span><br><span class="line">gzip info.txt <span class="comment"># 压缩info.txt文件为info.txt.gz文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gunzip 文件</span></span><br><span class="line">gunzip info.txt.gz <span class="comment"># 解压info.txt.gz文件为info.txt文件</span></span><br></pre></td></tr></table></figure><p><strong>zip命令</strong>：压缩文件和目录，适用于多个文件和目录</p><p><strong>unzip命令</strong>：解压文件和目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zip [参数] 文件名.zip 要压缩的文件名</span></span><br><span class="line">zip info.zip info.txt <span class="comment"># 将info.txt压缩到info.zip中</span></span><br><span class="line">zip -r test.zip <span class="built_in">test</span>/ <span class="comment"># 将test目录下所有文件和子目录递归压缩，用于处理多文件多目录的压缩</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># unzip [参数] 文件名.zip</span></span><br><span class="line">unzip test.zip <span class="comment"># 直接解压test.zip</span></span><br><span class="line">unzip -d beta/ test.zip <span class="comment"># 指定解压test.zip到同级的beta目录下 </span></span><br></pre></td></tr></table></figure><p><strong>tar命令</strong>：打包目录或解包tar文件，并且能附加压缩和解压功能</p><p>注意：打包和压缩包不是一个概念，解包和解压也不是</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tar 必填参数[选填参数] 打包文件名 源文件名</span></span><br><span class="line">tar -cvf info.tar info.txt <span class="comment"># 打包info.txt到info.tar中</span></span><br><span class="line">tar -zcvf info.tar.gz info.txt <span class="comment"># 打包的同时使用gzip进行压缩</span></span><br><span class="line"></span><br><span class="line">tar -xvf info.tar <span class="comment"># 解包info.tar</span></span><br><span class="line">tar -zxvf info.tar.gz <span class="comment"># 解压并解包info.tar.gz</span></span><br><span class="line"></span><br><span class="line">tar -tvf info.tar <span class="comment"># 不解压，仅查看包中的文件信息</span></span><br><span class="line"><span class="comment"># 指定解包到哪个目录</span></span><br><span class="line">tar -xvf info.tar -C /tmp <span class="comment"># 解包到tmp目录下</span></span><br></pre></td></tr></table></figure><h5 id="路由表命令"><a class="markdownIt-Anchor" href="#路由表命令"></a> 路由表命令</h5><p><strong>route命令</strong>： 显示和操作IP路由表</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># route [参数]</span></span><br><span class="line">route <span class="comment"># 查看路由表</span></span><br><span class="line">route -n <span class="comment"># 不解析名字</span></span><br></pre></td></tr></table></figure><h5 id="文本操作命令"><a class="markdownIt-Anchor" href="#文本操作命令"></a> 文本操作命令</h5><p><strong>sed命令</strong>：能够在不打开文件的情况下处理、编辑文本文件， 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sed [参数] 文件名</span></span><br><span class="line">sed -e <span class="string">&#x27;s/-/*/g&#x27;</span> info.txt &gt;&gt; info.txt <span class="comment"># 将info.txt中所有的字符-替换为*，并应用修改到info.txt中</span></span><br></pre></td></tr></table></figure><h4 id="组管理与权限管理"><a class="markdownIt-Anchor" href="#组管理与权限管理"></a> 组管理与权限管理</h4><h5 id="组管理"><a class="markdownIt-Anchor" href="#组管理"></a> 组管理</h5><p>在linux中的每个用户必须属于一个组，不能独立于组外</p><p>在linux中每个文件有所有者、所在组、其它组的概念</p><p>文件的所有者就是创建该文件的用户</p><p>除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组</p><p>提示：<strong>查看文件权限、所有者等信息</strong>可以使用<strong>ls -l 指定的文件名</strong>实现；<strong>查看用户相关信息</strong>可以使用<strong>id 指定的用户名</strong>实现</p><h5 id="基本命令-2"><a class="markdownIt-Anchor" href="#基本命令-2"></a> 基本命令</h5><p><strong>chown命令</strong>：修改文件所有者，但不改变组</p><p><strong>chgrp命令</strong>：修改文件所在组</p><p><strong>usermod命令</strong>：改变用户所在组</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chown 用户名 文件名</span></span><br><span class="line"><span class="built_in">chown</span> common info.txt <span class="comment"># info.txt所有者改为common用户</span></span><br><span class="line"><span class="built_in">ls</span> -l info.txt <span class="comment"># 查看info.txt的信息</span></span><br><span class="line"><span class="comment"># chgrp 组名 文件名</span></span><br><span class="line"><span class="built_in">chgrp</span> common info.txt <span class="comment"># info.txt所在组改为common组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># usermod -g 组名 用户名</span></span><br><span class="line">usermod -g ok common <span class="comment"># common用户所在组改为ok组</span></span><br><span class="line"><span class="built_in">id</span> common <span class="comment"># 查看common用户的信息</span></span><br></pre></td></tr></table></figure><h5 id="权限管理"><a class="markdownIt-Anchor" href="#权限管理"></a> 权限管理</h5><p>文件权限内容，通过ls -l 指定文件名查看</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一个示例</span></span><br><span class="line">-rw-r--r-- 1 root root 320 11月 18 17:49 info.txt</span><br></pre></td></tr></table></figure><p><strong>-rw-r–r--解读</strong>(下标从0开始)</p><ol><li>第0位确定文件类型(d, - , l , c , b)</li><li>第1-3位确定所有者（该文件的所有者）拥有该文件的权限</li><li>第4-6位确定所属组（同用户组的）拥有该文件的权限</li><li>第7-9位确定其他用户拥有该文件的权限</li></ol><p><strong>rwx权限说明</strong></p><ol><li><p>r表示可读read</p></li><li><p>w表示可写write</p></li><li><p>x表示可执行execute</p></li><li><p>对于文件来说</p><ul><li><p>r表示可以读取查看文件</p></li><li><p>w表示可以修改，但不能删除文件，删除一个文件必须拥有父文件夹的rwx权限(存在一个特例，在提前知道目录里的具体内容的情况下，手动指定对应的完整文件名进行删除)</p></li><li><p>x表示文件可执行</p></li></ul></li><li><p>对于目录来说</p><ul><li>r表示可以读取，查看目录内容</li><li>w表示可修改，<strong>目录内</strong>创建+删除+重命名目录</li><li>x表示可以进入该目录</li></ul></li></ol><h5 id="基本命令-3"><a class="markdownIt-Anchor" href="#基本命令-3"></a> 基本命令</h5><p><strong>chmod命令</strong>：修改文件或目录的权限</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数</span></span><br><span class="line"><span class="comment"># u:所有者 g:使用组 o:其他人 a:所有人</span></span><br><span class="line"><span class="comment"># +:添加权限 -:删除权限 =:设置权限</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> a=--- info.txt <span class="comment"># 取消所有人对info.txt的rwx权限</span></span><br><span class="line"><span class="built_in">chmod</span> u=rwx,g=rw-,o=r info.txt</span><br><span class="line"><span class="built_in">chmod</span> g+x,o-r info.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过rwx权限对应的数字设置权限</span></span><br><span class="line"><span class="comment"># r=4 w=2 x=1  rwx=4+2+1=7</span></span><br><span class="line"><span class="built_in">chmod</span> 611 info.txt</span><br></pre></td></tr></table></figure><h4 id="进程管理"><a class="markdownIt-Anchor" href="#进程管理"></a> 进程管理</h4><p>在linux中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个 ID 号</p><p>每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程</p><p>每个进程都可能以两种方式存在的：前台与后台</p><p>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，直到关机</p><h5 id="fg和bg命令进程前后台调度命令"><a class="markdownIt-Anchor" href="#fg和bg命令进程前后台调度命令"></a> fg和bg命令：进程前后台调度命令</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在前台结束一个进程</span></span><br><span class="line">Control+c</span><br><span class="line"><span class="comment"># 在前台暂停一个进程</span></span><br><span class="line">Control+z</span><br><span class="line"><span class="comment"># 查看后台执行进程的进程号</span></span><br><span class="line"><span class="built_in">jobs</span></span><br><span class="line"><span class="comment"># 运行命令时，在命令末尾加上&amp;可让命令在后台执行</span></span><br><span class="line">&amp;</span><br><span class="line"><span class="comment"># 将命令进程号码为N的命令进程放到前台执行</span></span><br><span class="line"><span class="built_in">fg</span> N</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">%N</span><br><span class="line"><span class="comment"># 将命令进程号码为N的命令进程放到后台执行</span></span><br><span class="line"><span class="built_in">bg</span> N</span><br></pre></td></tr></table></figure><h5 id="ps命令查看系统进程"><a class="markdownIt-Anchor" href="#ps命令查看系统进程"></a> ps命令查看系统进程</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ps [参数]</span></span><br><span class="line">ps -a <span class="comment"># 显示当前终端的所有进程信息</span></span><br><span class="line">ps -u <span class="comment"># 以用户的格式显示进程信息</span></span><br><span class="line">ps -x <span class="comment"># 显示后台进程运行的参数</span></span><br></pre></td></tr></table></figure><h5 id="kill命令终止进程"><a class="markdownIt-Anchor" href="#kill命令终止进程"></a> kill命令终止进程</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kill [参数] 进程号PID</span></span><br><span class="line"><span class="comment"># 参数(基本都使用9)</span></span><br><span class="line"><span class="comment"># 1:重新加载 9:强制停止 15:正常停止</span></span><br><span class="line"><span class="comment"># kill命令需要与ps命令配合使用</span></span><br><span class="line"><span class="built_in">kill</span> -9 9899 <span class="comment"># 9899是通过ps获取的PID号，强制停止9899的进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># killall命令能终止指定名称的所有进程，适合系统负载过大时使用</span></span><br><span class="line"><span class="comment"># killall -9 进程名称</span></span><br></pre></td></tr></table></figure><h5 id="pstree命令查看进程信息"><a class="markdownIt-Anchor" href="#pstree命令查看进程信息"></a> pstree命令查看进程信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pstree [参数]</span></span><br><span class="line"><span class="comment"># pstree相对ps可以更直观地查看进程信息</span></span><br><span class="line">pstree -p <span class="comment"># 额外显示进程的PID</span></span><br><span class="line">pstree -u <span class="comment"># 额外显示进程的所属用户</span></span><br></pre></td></tr></table></figure><h5 id="service命令操作进程后台服务"><a class="markdownIt-Anchor" href="#service命令操作进程后台服务"></a> service命令操作进程（后台服务）</h5><p>服务(service) 本质就是进程，但是是<strong>运行在后台的一个特殊进程</strong>。这个特殊进程通常都会监听某个端口等待其它程序的请求，比如(mysql , sshd 防火墙等)。因此这个进程又称为<strong>守护进程</strong>。</p><p><strong>telnet命令</strong>可以用于远程登录主机，也可以测试某个端口</p><p><strong>查看服务</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig --list | grep 8989 <span class="comment"># 该命令已被弃用</span></span><br></pre></td></tr></table></figure><p><strong>top命令持续监听运行状态</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># top [参数]</span></span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line"><span class="comment"># -d 秒数:指定每隔几秒更新，默认3秒</span></span><br><span class="line"><span class="comment"># -i:不显示任何闲置或僵死进程</span></span><br><span class="line"><span class="comment"># -p 进程PID:监控指定的PID的进程状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># top命令会进入一个交互页面，可以通过以下操作进行交互</span></span><br><span class="line"><span class="comment"># P:以CPU使用率排序，默认</span></span><br><span class="line"><span class="comment"># M:以内存的使用率排序</span></span><br><span class="line"><span class="comment"># N:以PID排序</span></span><br><span class="line"><span class="comment"># q:退出top交互页面</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;关于linux的通用操作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关于linux的通用操作&quot;&gt;&lt;/a&gt; 关于Linux的通用操作&lt;/h3&gt;
&lt;p&gt;基于Ubuntu22.04发行版的环境，本文整理了一些在Linux系统下基本通用的操作，使初学者能初步学会Linux系统的操作或使老用户重新回顾一下常用操作</summary>
    
    
    
    <category term="linux" scheme="https://s-chance.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://s-chance.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>一封数字签名邮件</title>
    <link href="https://s-chance.github.io/2022/11/10/digital-signature/"/>
    <id>https://s-chance.github.io/2022/11/10/digital-signature/</id>
    <published>2022-11-10T07:35:56.000Z</published>
    <updated>2022-11-10T17:46:25.981Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用outlook邮箱发送一封带有数字签名的邮件"><a class="markdownIt-Anchor" href="#使用outlook邮箱发送一封带有数字签名的邮件"></a> 使用outlook邮箱发送一封带有数字签名的邮件</h3><p>Digital Signature(数字签名)<strong>是</strong>Electronic Signature(电子签名)的一种特定类型, 是一种改进型的更加可信的电子方式签名。<span id="more"></span></p><p>数字签名是使用数字证书来验证签名者的身份, 并通过密码算法将签名者身份绑定到文档中来证明签名行为的不可否认, 已签名文档无需包含签名过程审计报告, 签名者的身份验证则由证书颁发机构(CA)或信任服务提供商(TSP)完成。</p><h4 id="1下载数字证书"><a class="markdownIt-Anchor" href="#1下载数字证书"></a> 1.下载数字证书</h4><p>数字证书需要先到网站上申请下载, 这里提供了一个申请90天免费证书的网站 <a href="https://www.cersign.com/smime-email-certificates.html">证签安全电子邮件证书 - CerSign</a></p><p>按照网站上提示完成申请以及邮箱验证即可。免费邮件证书大约几分钟后就会签发, 点击下载证书设置保护口令即可</p><h4 id="2在邮箱客户端中设置"><a class="markdownIt-Anchor" href="#2在邮箱客户端中设置"></a> 2.在邮箱客户端中设置</h4><p>outlook邮箱中导入数字证书: <strong>文件→选项→信任中心→电子邮件安全性</strong>, 然后设置加密以及数字签名。在默认设置中选择<strong>签名证书和加密证书</strong>(需要先找到之前下载好的证书文件双击运行并导入证书)</p><h4 id="3发送邮件进行测试"><a class="markdownIt-Anchor" href="#3发送邮件进行测试"></a> 3.发送邮件进行测试</h4><p>选择收件人(可以选择本地的另外一个邮箱)后输入邮件内容发送, 通过outlook客户端查看邮件内容会有一个额外的数字签名的图标, 点击该图标能够查看到发件人的数字证书信息。另外经过加密的邮件还会有一个🔒的图标, 在收件人拥有发件人的<strong>公钥</strong>时, 就能够进行解密获取正文内容。其他情况下, 则只有一个加密的smime.p7m文件(无法直接获取正文内容)</p><h4 id="4关于公钥和私钥的一些简单理解"><a class="markdownIt-Anchor" href="#4关于公钥和私钥的一些简单理解"></a> 4.关于公钥和私钥的一些简单理解</h4><p>公钥是一种<strong>非对称加密算法</strong>, 一般都是公布给对方用于加密解密</p><p>私钥是一种<strong>对称加密算法</strong>, 一般不对任何人公开, 同样可用于加密解密</p><p>公钥和私钥是<strong>成对出现</strong>的, 且<strong>唯一对应</strong></p><h5 id="思路1确保邮件只能由特定的收件人读取"><a class="markdownIt-Anchor" href="#思路1确保邮件只能由特定的收件人读取"></a> 思路1：确保邮件只能由特定的收件人读取</h5><p><strong>收件人的公钥</strong>提前就公布给所有发件人用于进行加密但不能进行解密, <strong>收件人的私钥</strong>则用于解密来自对应的公钥加密的邮件但不能进行加密(这也是一种非对称加密)</p><h5 id="思路2确认发件人的邮件未被篡改"><a class="markdownIt-Anchor" href="#思路2确认发件人的邮件未被篡改"></a> 思路2：确认发件人的邮件未被篡改</h5><p><strong>发件人的公钥</strong>提前就公布给所有收件人用于进行<strong>解密</strong>, <strong>发件人的私钥</strong>则用于<strong>加密</strong>邮件</p><p>具体流程：</p><p>发件人使用自己的私钥先对邮件加密<strong>一个hash值</strong>, 再用来自收件人的公钥对<strong>内容及hash值</strong>二次加密, 然后发送给收件人</p><p>收件人获取到了二次加密的邮件后, 先使用自己的私钥解密对应的公钥获取内容及<strong>加密的hash值</strong>, 再用来自收件人的公钥二次解密对应的私钥获取<strong>原始的hash值</strong>, 对内容进行hash计算, 如果计算的结果与之前hash值解密后的内容相同, 则说明内容未被篡改</p><p>需要注意的是：公钥和私钥的用法不是固定的, 在收件人和发件人两种情景下, 它们的用法恰恰是相反的</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;使用outlook邮箱发送一封带有数字签名的邮件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#使用outlook邮箱发送一封带有数字签名的邮件&quot;&gt;&lt;/a&gt; 使用outlook邮箱发送一封带有数字签名的邮件&lt;/h3&gt;
&lt;p&gt;Digital Signature(数字签名)&lt;strong&gt;是&lt;/strong&gt;Electronic Signature(电子签名)的一种特定类型, 是一种改进型的更加可信的电子方式签名。</summary>
    
    
    
    
    <category term="数字签名" scheme="https://s-chance.github.io/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    
    <category term="计算机网络" scheme="https://s-chance.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>后缀表达式</title>
    <link href="https://s-chance.github.io/2022/10/27/suffix-expression/"/>
    <id>https://s-chance.github.io/2022/10/27/suffix-expression/</id>
    <published>2022-10-26T16:28:58.000Z</published>
    <updated>2022-10-26T16:57:24.186Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基于stl的中缀转后缀实现"><a class="markdownIt-Anchor" href="#基于stl的中缀转后缀实现"></a> 基于STL的中缀转后缀实现</h3><h4 id="1定义分析"><a class="markdownIt-Anchor" href="#1定义分析"></a> 1.定义分析</h4><p><strong>首先明确后缀表达式的定义</strong></p><p>后缀表达式是一种不需要括号的表达式，这表示在将中缀表达式转化为后缀表达式时，如果中缀表达式中存在括号，<strong>不能将括号写入后缀表达式</strong><span id="more"></span></p><p>那么这里引出一个问题，后缀表达式中不存在括号那要如何表示运算的优先级？</p><p><strong>理解后缀表达式的运算过程</strong></p><p>以(1+5-4)*(6-9)为例，它的后缀表达式是15+4-69-*</p><p>先分析中缀表达式的运算过程，参与运算过程的操作符依次是+ - - *，正好是后缀表达式中从左往右的操作符顺序。而操作符所涉及到的2个操作数都是位于该操作符的前面。</p><p>那么回到上面的问题来看，中缀表达式中的<strong>括号的作用如何在后缀表达式中体现出来</strong>？</p><p>以1+2*3、(1+2)*3为例</p><p>1+2*3的后缀表达式为123*+</p><p>(1+2)*3的后缀表达式为12+3*</p><p>通过对比可以发现当表达式中存在括号时，<strong>括号中的操作符提前输出</strong>了，这表示在遇到括号的情况时，可以将括号内的操作符提前输出。</p><p><strong>此外，还需要考虑四则运算中，乘除的优先级高于加减</strong></p><p>以1+2*3为例，如果不加以判断直接转化后缀表达式，结果为12+3*，先运算+再运算*，这显然违背了基本的四则运算法则，实际上正确的结果应该是123*+</p><p>通过对比两个结果，可以发现优先级较低的操作符移到了后面，这表示在运算过程中可以<strong>先将优先级低的操作符存储起来</strong>，而将<strong>优先级高的运算符输出</strong>。</p><h4 id="2思路分析"><a class="markdownIt-Anchor" href="#2思路分析"></a> 2.思路分析</h4><p>采用STL模板实现中缀转后缀，这里使用的是stack。定义一个stack字符栈专门用于存储操作符</p><p><font color='red'>这里特别说明一下字符栈，字符栈栈底的操作符优先级最低，栈顶的操作符优先级最高</font></p><p><strong>1.输入中缀表达式的字符串依次获取字符串中的每个字符</strong></p><p><strong>2.对字符进行以下的判断和操作</strong></p><ul><li>数字字符，直接输出</li><li>左括号字符，直接存入stack</li><li>右括号字符，将stack中的操作符依次输出，直到遇到左括号时停止，将左括号出栈但不输出</li><li>加减乘除字符<ul><li>优先级高的字符直接存入stack</li><li>优先级低的字符，则比较当前字符栈栈顶操作符的优先级，遇到优先级更低的操作符或左括号字符时不出栈，并将当前操作符入栈</li></ul></li></ul><p><strong>3.当字符串遍历完成后，再依次输出字符栈内剩余的操作符</strong></p><h4 id="3实现过程分析"><a class="markdownIt-Anchor" href="#3实现过程分析"></a> 3.实现过程分析</h4><p>以(1+5-4)*(6-9)为例，字符串长度为13</p><p>获取到的字符：(</p><blockquote><p>表达式：</p><p>字符栈：(</p></blockquote><p>获取到的字符：1</p><blockquote><p>表达式：1</p><p>字符栈：(</p></blockquote><p>获取到的字符：+</p><blockquote><p>表达式：1</p><p>字符栈：(+</p></blockquote><p>获取到的字符：5</p><blockquote><p>表达式：15</p><p>字符栈：(+</p></blockquote><p>获取到的字符：-</p><blockquote><p>表达式：15+</p><p>字符栈：(-</p></blockquote><p>获取到的字符：4</p><blockquote><p>表达式：15+4</p><p>字符栈：(-</p></blockquote><p>获取到的字符：)</p><blockquote><p>表达式：15+4-</p><p>字符栈：</p></blockquote><p>获取到的字符：*</p><blockquote><p>表达式：15+4-</p><p>字符栈：*</p></blockquote><p>获取到的字符：(</p><blockquote><p>表达式：15+4-</p><p>字符栈：*(</p></blockquote><p>获取到的字符：6</p><blockquote><p>表达式：15+4-6</p><p>字符栈：*(</p></blockquote><p>获取到的字符：-</p><blockquote><p>表达式：15+4-6</p><p>字符栈：*(-</p></blockquote><p>获取到的字符：9</p><blockquote><p>表达式：15+4-69</p><p>字符栈：*(-</p></blockquote><p>获取到的字符：)</p><blockquote><p>表达式：15+4-69-</p><p>字符栈：*</p></blockquote><p>最后，依次输出字符栈中所有的操作符</p><blockquote><p>表达式：15+4-69-*</p></blockquote><h4 id="4源代码"><a class="markdownIt-Anchor" href="#4源代码"></a> 4.源代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">transfer</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">length</span>(); <span class="comment">//记录长度</span></span><br><span class="line">    list&lt;string&gt; listIn;  <span class="comment">//存储中缀表达式</span></span><br><span class="line">    list&lt;string&gt; listOut; <span class="comment">//存储后缀表达式</span></span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; symbol;   <span class="comment">//符号栈</span></span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; ans;      <span class="comment">//结果表达式</span></span><br><span class="line"></span><br><span class="line">    listIn.<span class="built_in">push_back</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//数字直接存入ans</span></span><br><span class="line">        <span class="comment">//运算符:</span></span><br><span class="line">        <span class="comment">//如果是&#x27;(&#x27;直接存入symbol</span></span><br><span class="line">        <span class="comment">//如果是&#x27;)&#x27;依次出栈symbol中的运算符并存入ans, 直到遇到&#x27;(&#x27;, &#x27;(&#x27;不存入ans</span></span><br><span class="line">        <span class="comment">//其他符号, 依次出栈symbol中的运算符并存入ans, 直到遇到优先级更低的运算符或&#x27;(&#x27;时, 将当前符号存入symbol</span></span><br><span class="line">        <span class="comment">//字符串遍历完成后, 依次出栈符号栈中剩余的运算符并存入ans</span></span><br><span class="line">        <span class="keyword">if</span> (listIn.<span class="built_in">back</span>()[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; listIn.<span class="built_in">back</span>()[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            ans.<span class="built_in">push</span>(listIn.<span class="built_in">back</span>()[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (listIn.<span class="built_in">back</span>()[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            symbol.<span class="built_in">push</span>(listIn.<span class="built_in">back</span>()[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (listIn.<span class="built_in">back</span>()[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (symbol.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push</span>(symbol.<span class="built_in">top</span>());</span><br><span class="line">                symbol.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            symbol.<span class="built_in">pop</span>(); <span class="comment">//将&#x27;(&#x27;出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里手动优先考虑乘除的优先级高于加减</span></span><br><span class="line">            <span class="keyword">if</span> (listIn.<span class="built_in">back</span>()[i] == <span class="string">&#x27;+&#x27;</span> || listIn.<span class="built_in">back</span>()[i] == <span class="string">&#x27;-&#x27;</span>) <span class="comment">//加减符号优先级最低</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (!symbol.<span class="built_in">empty</span>() &amp;&amp; symbol.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.<span class="built_in">push</span>(symbol.<span class="built_in">top</span>()); <span class="comment">//直接存入symbol中的运算符</span></span><br><span class="line">                    symbol.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                symbol.<span class="built_in">push</span>(listIn.<span class="built_in">back</span>()[i]); <span class="comment">//符号栈存入当前从listIn中获取的符号</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//乘除符号优先级高直接存入符号栈</span></span><br><span class="line">            &#123;</span><br><span class="line">                symbol.<span class="built_in">push</span>(listIn.<span class="built_in">back</span>()[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!symbol.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ans.<span class="built_in">push</span>(symbol.<span class="built_in">top</span>());</span><br><span class="line">        symbol.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将结果表达式的值存入listOut</span></span><br><span class="line">    <span class="comment">//先利用已经清空的symbol实现反转</span></span><br><span class="line">    <span class="keyword">while</span> (!ans.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        symbol.<span class="built_in">push</span>(ans.<span class="built_in">top</span>());</span><br><span class="line">        ans.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!symbol.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        res += symbol.<span class="built_in">top</span>();</span><br><span class="line">        symbol.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    listOut.<span class="built_in">push_back</span>(res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> listOut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        list&lt;string&gt; res = <span class="built_in">transfer</span>(s);</span><br><span class="line">        cout &lt;&lt; res.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;基于stl的中缀转后缀实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基于stl的中缀转后缀实现&quot;&gt;&lt;/a&gt; 基于STL的中缀转后缀实现&lt;/h3&gt;
&lt;h4 id=&quot;1定义分析&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1定义分析&quot;&gt;&lt;/a&gt; 1.定义分析&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;首先明确后缀表达式的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后缀表达式是一种不需要括号的表达式，这表示在将中缀表达式转化为后缀表达式时，如果中缀表达式中存在括号，&lt;strong&gt;不能将括号写入后缀表达式&lt;/strong&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="https://s-chance.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="cpp" scheme="https://s-chance.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础</title>
    <link href="https://s-chance.github.io/2022/09/14/Redis-Base/"/>
    <id>https://s-chance.github.io/2022/09/14/Redis-Base/</id>
    <published>2022-09-14T13:24:00.000Z</published>
    <updated>2022-09-15T12:19:13.484Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis基础"><a class="markdownIt-Anchor" href="#redis基础"></a> Redis基础</h3><h4 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h4><p>redis是一款高性能的NoSQL系列的非关系型数据库，全称Remote Dictionary Server远程字典服务器，是基于C语言开发的一个开源的高性能键值对数据库<span id="more"></span></p><p>NoSQL，全称Not-Only SQL，泛指非关系型的数据库，专门用于应对基于海量用户和海量数据下的数据处理问，不同于MySQL这类关系型数据库，NoSQL系列的非关系型数据库减少了磁盘读写次数、去除了数据间的关联性弥补关系型数据库在磁盘读写性能、复杂的数据关联性难于扩展的不足，专门用于应对大量用户<strong>高并发</strong>的问题</p><p>但非关系型数据库与关系型数据库在开发中一般会配合使用，非关系型数据库能实现大量数据的高效率访问，关系型数据库能实现复杂的数据查询以及保障安全性能的事务机制。单一的非关系数据库则无法实现复杂查询、安全保障，单一的关系型数据库也无法实现高效访问。因此联合使用非关系数据库和关系型数据库，相互弥补缺点，才能提供最好的用户体验。</p><h4 id="开始使用"><a class="markdownIt-Anchor" href="#开始使用"></a> 开始使用</h4><h5 id="下载安装"><a class="markdownIt-Anchor" href="#下载安装"></a> 下载安装</h5><p>redis<a href="https://redis.io">官网</a>以及<a href="http://www.redis.net.cn/">中文官网</a>主要提供的是Linux发行版下的redis版本，用于投入开发使用。本文章以windows系统下的redis版本做为学习使用，在GitHub上的<a href="https://github.com/microsoftarchive/redis/releases">Releases · microsoftarchive/redis</a>下载zip压缩包找到内部的release目录下含有redis主要的exe文件的压缩包后解压即可（这里是以2.8.9版本为例）</p><p>关于redis的图形化管理工具<a href="https://github.com/uglide/RedisDesktopManager">下载</a>(最新版本需要收费使用)</p><h5 id="重要文件"><a class="markdownIt-Anchor" href="#重要文件"></a> 重要文件</h5><p>redis压缩包解压后目录下的重要文件主要是以下文件：</p><ul><li>redis.windows.conf：配置文件</li><li>redis-cli.exe：redis客户端</li><li>redis-server.exe：redis服务器端</li></ul><h5 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h5><p><strong>请确保redis服务器端先启动，否则redis客户端在启动后将会无法连接至redis服务器端</strong></p><p>redis数据类型：string、hash、list、set、sorted_set/zset</p><p>注意：在未持久化redis中的数据时，关闭redis服务器端会导致在redis客户端存储的数据全部丢失，因此请在确保redis服务器端一直运行的前提下，测试下面的命令操作</p><ol><li><p>字符串类型：string</p><p>主要用于存储单个数据，是最简单也是最常用的数据存储类型</p><p>一个存储空间存储一个数据</p><p>存储的数据如果是整数类型，则可进行数字操作</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 存储命令</span></span><br><span class="line"><span class="comment"># 格式: set key value</span></span><br><span class="line"><span class="comment"># 存储一个键为name, 值为tom的字符串数据</span></span><br><span class="line"><span class="built_in">set</span> name tom</span><br><span class="line"><span class="comment"># 存储一个键为age, 值为26的字符串数据</span></span><br><span class="line"><span class="built_in">set</span> age 26</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取命令</span></span><br><span class="line"><span class="comment"># 格式: get key</span></span><br><span class="line"><span class="comment"># 获取name键对应的值</span></span><br><span class="line">get name</span><br><span class="line"><span class="comment"># 获取age键对应的值</span></span><br><span class="line">get age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除命令</span></span><br><span class="line"><span class="comment"># 格式: del key</span></span><br><span class="line"><span class="comment"># 删除name键对应的值</span></span><br><span class="line">del name</span><br><span class="line"><span class="comment">#删除age键对应的值</span></span><br><span class="line">del age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新获取值, 确认是否已经删除</span></span><br><span class="line">get name</span><br><span class="line">get age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数字操作命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自增处理incr key, 当key不存在时会自动创建, 默认自增值1</span></span><br><span class="line">incr num <span class="comment">#num键若不存在, 则自动创建</span></span><br><span class="line"><span class="comment"># 自增指定数据incrby key increment</span></span><br><span class="line">incrby num 20 <span class="comment">#指定num键的值自增20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自减处理decr key, 同样的若key不存在会自动创建, 默认自减值1</span></span><br><span class="line">decr num</span><br><span class="line"><span class="comment"># 自减指定数据decrby key decrement</span></span><br><span class="line">decrby num 30</span><br></pre></td></tr></table></figure></li><li><p>哈希类型：hash</p><p>主要用于分组存储有一定关联性的数据，比如java对象中的一系列成员变量数据</p><p>一个存储空间存储多个键值对数据</p><p>底层使用哈希表结构实现数据存储</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 存储命令</span></span><br><span class="line"><span class="comment"># 格式: hset key field value</span></span><br><span class="line"><span class="comment"># 在myhash键中存储一个name字段, 值为jerry的数据</span></span><br><span class="line">hset myhash name jerry</span><br><span class="line"><span class="comment"># 在myhash键中存储一个password字段, 值为pass的数据</span></span><br><span class="line">hset myhash password pass</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取命令</span></span><br><span class="line"><span class="comment"># 格式一: hget key field 获取指定的field所对应的值</span></span><br><span class="line"><span class="comment"># 获取myhash键中name字段的值</span></span><br><span class="line">hget myhash name</span><br><span class="line"><span class="comment"># 格式二: hgetall key 获取指定key下的所有field和value</span></span><br><span class="line"><span class="comment"># 获取myhash键下的所有键值对数据</span></span><br><span class="line">hgetall myhash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除命令</span></span><br><span class="line"><span class="comment"># 格式: hdel key field</span></span><br><span class="line"><span class="comment"># 删除myhash键下的name字段及其对应的值</span></span><br><span class="line">hdel myhash name</span><br></pre></td></tr></table></figure></li><li><p>列表类型：list</p><p>主要用于存储多个数据，并对数据先后进入存储空间的顺序进行区分</p><p>一个存储空间存储多个数据，且区分数据存储的先后顺序</p><p>底层使用双向链表结构实现数据存储</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 存储命令</span></span><br><span class="line"><span class="comment"># 格式一: lpush key value 在列表左边(头部)添加数据</span></span><br><span class="line"><span class="comment"># 格式二: rpush key value 在列表右边(尾部)添加数据</span></span><br><span class="line"><span class="comment"># 先任意添加一个测试的初始数据</span></span><br><span class="line">lpush mylist origin</span><br><span class="line"><span class="comment"># 在mylist键列表头部添加一个数据</span></span><br><span class="line">lpush mylist <span class="built_in">head</span></span><br><span class="line"><span class="comment"># 在mylist键列表尾部添加一个数据</span></span><br><span class="line">rpush mylist <span class="built_in">tail</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取命令</span></span><br><span class="line"><span class="comment"># lrange key start end 根据start和end的范围获取</span></span><br><span class="line"><span class="comment"># list数据下标从0开始, 若使用负数, 则表示从列表尾部倒数第几个数据</span></span><br><span class="line"><span class="comment"># 获取mylist下标0-2的数据</span></span><br><span class="line">lrange mylist 0 2</span><br><span class="line">lrange mylist 0 -1 <span class="comment">#-1表示列表倒数第一个数据, 即正数最后一个数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除命令</span></span><br><span class="line"><span class="comment"># 格式一: lpop key 删除列表最左边的数据</span></span><br><span class="line"><span class="comment"># 格式二: rpop key 删除列表最右边的数据</span></span><br><span class="line"><span class="comment"># 删除mylist键列表头部的一个数据</span></span><br><span class="line">lpop mylist</span><br><span class="line"><span class="comment"># 删除mylist键列表尾部的一个数据</span></span><br><span class="line">rpop mylist</span><br></pre></td></tr></table></figure></li><li><p>集合类型：set</p><p>主要用于存储大量的数据，提供更高的数据查询效率</p><p>一个存储空间能够存储大量数据，且具有高效的内部存储机制</p><p>底层与hash存储结构相同，并且不允许存储重复的值</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 存储命令</span></span><br><span class="line"><span class="comment"># 格式: sadd key value</span></span><br><span class="line"><span class="comment"># 在myset键存储一个值为a的数据</span></span><br><span class="line">sadd myset a <span class="comment">#第二次重复执行, 不会再新增数据</span></span><br><span class="line">sadd myset b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取命令</span></span><br><span class="line"><span class="comment"># 格式: smembers key</span></span><br><span class="line"><span class="comment"># 获取myset键中的所有数据</span></span><br><span class="line">smembers myset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除命令</span></span><br><span class="line"><span class="comment"># 格式: srem key value</span></span><br><span class="line"><span class="comment"># 删除myset键中值为a的数据</span></span><br><span class="line">srem myset a</span><br></pre></td></tr></table></figure></li><li><p>有序集合类型：sorted_set</p><p>不允许存储重复数据，并且存储的数据是有顺序的，每个数据会关联一个double类型的分数作为排序的依据</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 存储命令</span></span><br><span class="line"><span class="comment"># 格式: zadd key score value</span></span><br><span class="line"><span class="comment"># 在mysort键存储一个分数为3, 值为pascal的数据</span></span><br><span class="line">zadd mysort 3 pascal</span><br><span class="line"><span class="comment"># 在mysort键存储一个分数为1, 值为visual的数据</span></span><br><span class="line">zadd mysort 1 visual</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取命令</span></span><br><span class="line"><span class="comment"># 格式: zrange key start end 范围获取, 可参考list列表类型的获取命令来理解</span></span><br><span class="line"><span class="comment"># 获取mysort键下的所有数据</span></span><br><span class="line">zrange mysort 0 -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除命令</span></span><br><span class="line"><span class="comment"># 格式: zrem key value</span></span><br><span class="line"><span class="comment"># 删除mysort键下值为visual的数据</span></span><br><span class="line">zrem mysort visual</span><br></pre></td></tr></table></figure><p><strong>通用命令操作</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询所有的键</span></span><br><span class="line">keys *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定键对应的数据类型</span></span><br><span class="line"><span class="comment"># 获取mysort键对应的数据类型</span></span><br><span class="line"><span class="built_in">type</span> mysort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的键及其数据</span></span><br><span class="line"><span class="comment"># 删除myhash键下的所有键值对数据</span></span><br><span class="line">del myhash</span><br></pre></td></tr></table></figure></li></ol><h4 id="持久化"><a class="markdownIt-Anchor" href="#持久化"></a> 持久化</h4><h5 id="rdb方式"><a class="markdownIt-Anchor" href="#rdb方式"></a> RDB方式</h5><p>redis作为一个内存数据库，当redis服务器重启后，数据就会丢失。为了能够在redis服务器重启后能够快速恢复缓存的数据，就需要使用持久化技术</p><ul><li><p>redis持久化机制：每隔一定时间检测key的变化情况，根据配置决定是否进行持久化。持久化的数据就存储在dump.rdb文件中。</p></li><li><p>持久化配置过程：打开redis.windows.conf文件，找到<code># Save the DB on disk</code>所在的位置，在#注释的下方可以看到<code>save 900 1</code>的字样，这些原始的字样就是默认的持久化机制。通过修改这些字样就能设置持久化机制。</p></li><li><p>关于持久化配置的简单说明：</p><p><code>save 900 1</code></p><h6 id="after-900-sec-15-min-if-at-least-1-key-changed"><a class="markdownIt-Anchor" href="#after-900-sec-15-min-if-at-least-1-key-changed"></a> after 900 sec (15 min) if at least 1 key changed</h6><h6 id="经过15分钟如果至少有一个key发生变化那么就进行一次持久化"><a class="markdownIt-Anchor" href="#经过15分钟如果至少有一个key发生变化那么就进行一次持久化"></a> 经过15分钟，如果至少有一个key发生变化，那么就进行一次持久化</h6><p><code>save 300 10</code></p><h6 id="after-300-sec-5-min-if-at-least-10-keys-changed"><a class="markdownIt-Anchor" href="#after-300-sec-5-min-if-at-least-10-keys-changed"></a> after 300 sec (5 min) if at least 10 keys changed</h6><h6 id="经过5分钟如果至少有10个key发生变化那么就进行一次持久化"><a class="markdownIt-Anchor" href="#经过5分钟如果至少有10个key发生变化那么就进行一次持久化"></a> 经过5分钟，如果至少有10个key发生变化，那么就进行一次持久化</h6><p><code>save 60 10000</code></p><h6 id="after-60-sec-1-min-if-at-least-10000-keys-changed"><a class="markdownIt-Anchor" href="#after-60-sec-1-min-if-at-least-10000-keys-changed"></a> after 60 sec (1 min) if at least 10000 keys changed</h6><h6 id="经过1分钟如果至少有10000个key发生变化那么就进行一次持久化"><a class="markdownIt-Anchor" href="#经过1分钟如果至少有10000个key发生变化那么就进行一次持久化"></a> 经过1分钟，如果至少有10000个key发生变化，那么就进行一次持久化</h6></li><li><p>持久化机制测试：</p><blockquote><p>配置之前请先确保关闭redis服务器，以防配置无法生效</p><ol><li><p>修改配置文件在指定位置添加字样<code>save 10 5</code>，10秒后有5个key发生变化，则持久化</p></li><li><p>在redis根目录下打开cmd，通过<code>redis-server.exe redis.windows.conf</code>命令启动redis服务器，否则持久化机制还是使用默认方式，如果觉得麻烦可以看<a href="#bc">补充</a></p></li><li><p>打开redis客户端</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试数据, 修改5个key</span></span><br><span class="line"><span class="built_in">set</span> name 1</span><br><span class="line"><span class="built_in">set</span> name 2</span><br><span class="line"><span class="built_in">set</span> name 3</span><br><span class="line"><span class="built_in">set</span> name 4</span><br><span class="line"><span class="built_in">set</span> name 5</span><br><span class="line"><span class="comment"># 之后根据save 10 5的配置, 会在redis的根目录下生成dump.rdb文件</span></span><br></pre></td></tr></table></figure></li><li><p>关闭redis服务器和客户端，再重启服务器和客户端重新查询数据，测试数据是否实现持久化</p></li></ol></blockquote></li></ul><h5 id="aof方式"><a class="markdownIt-Anchor" href="#aof方式"></a> AOF方式</h5><p>AOF是一种日志记录，用于记录redis每一条命令执行的历史操作，可在每一次命令操作后持久化数据</p><p>AOF配置过程：打开redis.windows.conf文件，找到<code>appendonly no</code>字样修改<code>no</code>为<code>yes</code>开启AOF支持。再找到<code>#appendfsync</code>开头的字样，去掉前面的<code>#</code>启动持久化机制</p><p>AOF持久化机制简单说明：<code>appendfsync always</code>每一次操作进行一次持久化，<code>appendfsync everysec</code>每隔一秒进行一次持久化，<code>appendfsync no</code>不进行持久化</p><p>注意：在redis根目录下用cmd执行<code>redis-server.exe redis.windows.conf</code>命令启动服务器，否则配置可能不生效</p><h4 id="span-idbc补充span"><a class="markdownIt-Anchor" href="#span-idbc补充span"></a> <span id='bc'>补充</span></h4><h5 id="关于redis-serverexe启动时默认加载配置文件"><a class="markdownIt-Anchor" href="#关于redis-serverexe启动时默认加载配置文件"></a> 关于redis-server.exe启动时默认加载配置文件</h5><p>右击文件<strong>创建快捷方式</strong>，右击快捷方式<strong>设置属性</strong>，在<strong>目标</strong>的后面<strong>添加空格和配置文件名</strong>，配置完后的示例<code>D:\redis-2.8.9\redis-server.exe redis.windows.conf</code>，前面的exe文件路径根据本地实际情况配置，默认是已有的，然后<strong>点击应用</strong>。之后使用该快捷方式启动服务器就能自动加载配置文件</p><h5 id="关于redisqfork_8412dat文件"><a class="markdownIt-Anchor" href="#关于redisqfork_8412dat文件"></a> 关于RedisQFork_8412.dat文件</h5><p>这是redis的内存映射文件。当redis启动时会自动创建，redis关闭后会自动消失。不过这个文件会随数据量的增长而增长，没有限制能够增长到几十G的大小，如果硬盘空间无法容纳这几十G的大小，就无法启动redis服务。可以通过修改配置文件中的<code>maxheap</code>字样后的参数实现（单位B），如设置最大为4G，则填写4294967296（4GB换算成B）</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;redis基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redis基础&quot;&gt;&lt;/a&gt; Redis基础&lt;/h3&gt;
&lt;h4 id=&quot;概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概念&quot;&gt;&lt;/a&gt; 概念&lt;/h4&gt;
&lt;p&gt;redis是一款高性能的NoSQL系列的非关系型数据库，全称Remote Dictionary Server远程字典服务器，是基于C语言开发的一个开源的高性能键值对数据库</summary>
    
    
    
    
    <category term="Redis" scheme="https://s-chance.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Git分支重命名</title>
    <link href="https://s-chance.github.io/2022/09/08/Git-Branch-Rename/"/>
    <id>https://s-chance.github.io/2022/09/08/Git-Branch-Rename/</id>
    <published>2022-09-08T04:20:19.000Z</published>
    <updated>2022-09-20T17:43:08.119Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git重命名分支"><a class="markdownIt-Anchor" href="#git重命名分支"></a> Git重命名分支</h3><p>在开发过程中，有时需要对分支进行重命名。重命名分支需要考虑到分支是否已经推送到远端的情况<span id="more"></span></p><h4 id="git重命名本地分支还未推送到远端"><a class="markdownIt-Anchor" href="#git重命名本地分支还未推送到远端"></a> Git重命名本地分支（还未推送到远端）</h4><ul><li><p>在需要重命名的分支处</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -m <span class="string">&#x27;新的分支名&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>不在需要重命名的分支处</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -m <span class="string">&#x27;需要重命名的分支名&#x27;</span> <span class="string">&#x27;新的分支名&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="git重命名远端分支已经推送到远端"><a class="markdownIt-Anchor" href="#git重命名远端分支已经推送到远端"></a> Git重命名远端分支（已经推送到远端）</h4><p><strong>假设已经处于需要重命名的分支上，参考上面的操作，并且在通过命令修改分支名之前没有手动去远端进行过修改，即修改之前本地分支名与远端分支名仍保持一致</strong></p><ul><li><p>重命名本地分支</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -m 新的分支名</span><br></pre></td></tr></table></figure></li><li><p>删除远程分支</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --delete origin 要删除的分支名</span><br></pre></td></tr></table></figure></li><li><p>上传新命名的分支</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin 新的分支名</span><br></pre></td></tr></table></figure></li><li><p>关联修改后的本地分支与远端分支</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to origin/新的分支名</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;git重命名分支&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#git重命名分支&quot;&gt;&lt;/a&gt; Git重命名分支&lt;/h3&gt;
&lt;p&gt;在开发过程中，有时需要对分支进行重命名。重命名分支需要考虑到分支是否已经推送到远端的情况</summary>
    
    
    
    
    <category term="Git" scheme="https://s-chance.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>关于yarn禁止在此系统上运行脚本</title>
    <link href="https://s-chance.github.io/2022/09/05/yarn-problem/"/>
    <id>https://s-chance.github.io/2022/09/05/yarn-problem/</id>
    <published>2022-09-05T13:36:27.000Z</published>
    <updated>2022-09-05T14:02:21.336Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nodejs中使用yarn安装依赖失败"><a class="markdownIt-Anchor" href="#nodejs中使用yarn安装依赖失败"></a> nodejs中使用yarn安装依赖失败</h3><h4 id="错误原因"><a class="markdownIt-Anchor" href="#错误原因"></a> 错误原因</h4><p>windows默认执行策略禁止脚本<span id="more"></span></p><h4 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h4><ol><li>在电脑的开始菜单中，搜索<strong>PowerShell</strong>，并<strong>以管理员身份运行</strong></li><li>在窗口输入命令<code>get-ExecutionPolicy</code>查看权限，如果返回值是<strong>Restricted</strong>，则表示当前是禁用状态</li><li>在窗口输入命令<code>set-ExecutionPolicy</code>设置权限</li><li>为<strong>ExecutionPolicy</strong>参数提供值<strong>RemoteSigned</strong>，后面输入<strong>A</strong>之后再回车（默认为否），开启所有脚本权限</li><li>重新测试yarn命令</li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;nodejs中使用yarn安装依赖失败&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#nodejs中使用yarn安装依赖失败&quot;&gt;&lt;/a&gt; nodejs中使用yarn安装依赖失败&lt;/h3&gt;
&lt;h4 id=&quot;错误原因&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#错误原因&quot;&gt;&lt;/a&gt; 错误原因&lt;/h4&gt;
&lt;p&gt;windows默认执行策略禁止脚本</summary>
    
    
    
    
    <category term="nodejs" scheme="https://s-chance.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>RSS订阅的使用以及优势</title>
    <link href="https://s-chance.github.io/2022/09/04/RSS/"/>
    <id>https://s-chance.github.io/2022/09/04/RSS/</id>
    <published>2022-09-04T11:38:08.000Z</published>
    <updated>2022-09-05T13:37:09.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="rssreally-simple-syndication简易信息聚合"><a class="markdownIt-Anchor" href="#rssreally-simple-syndication简易信息聚合"></a> RSS(Really Simple Syndication)简易信息聚合</h3><h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4><p>RSS本身是一种消息来源格式规范，主要用于聚合数据时效性很强的网站，例如个人博客文章、新闻，以及很多社交网站。RSS文件包含全文或者部分内容。<span id="more"></span></p><h4 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h4><ul><li>能够自主选择您感兴趣的内容和信息进行浏览</li><li>通过RSS，您可以把需要的信息从网站中筛选出来，排除掉那些不需要的信息，例如广告</li><li>通过RSS，您可以创建自己的新闻频道，并发布到互联网上供其他人以RSS订阅您的新闻频道</li><li>使用RSS的客户端，能够在不打开网站内容页面的情况下阅读支持RSS输出的网站内容</li></ul><h4 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h4><p>windows平台这里推荐微软商店的Fluent Reader<a href="https://apps.microsoft.com/store/detail/9P71FC94LRH8">官网链接</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;rssreally-simple-syndication简易信息聚合&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#rssreally-simple-syndication简易信息聚合&quot;&gt;&lt;/a&gt; RSS(Really Simple Syndication)简易信息聚合&lt;/h3&gt;
&lt;h4 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义&quot;&gt;&lt;/a&gt; 定义&lt;/h4&gt;
&lt;p&gt;RSS本身是一种消息来源格式规范，主要用于聚合数据时效性很强的网站，例如个人博客文章、新闻，以及很多社交网站。RSS文件包含全文或者部分内容。</summary>
    
    
    
    
    <category term="RSS" scheme="https://s-chance.github.io/tags/RSS/"/>
    
  </entry>
  
</feed>
